<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计网Note</title>
      <link href="/2022/03/09/%E8%AE%A1%E7%BD%91Note/"/>
      <url>/2022/03/09/%E8%AE%A1%E7%BD%91Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><ul><li>计算机设备<ul><li>主机 = 端系统</li><li>运行网络应用程序</li></ul></li><li>连接设备的通信链路<ul><li>光纤，铜缆，无线电，人造卫星</li><li>传输速率 = 带宽</li></ul></li><li>转发数据的分组交换机<ul><li>链路层交换机</li><li>路由器</li></ul></li><li>因特网服务提供商（<code>ISP</code>）</li><li>协议<ul><li>定义了在两个或两个以上通信实体之间交换的报文格式和次序，以及报文发送和接收一条报文或其他事件所采取的动作</li></ul></li></ul><h2 id="网络边缘：主机；接入网；物理介质网络"><a href="#网络边缘：主机；接入网；物理介质网络" class="headerlink" title="网络边缘：主机；接入网；物理介质网络"></a>网络边缘：主机；接入网；物理介质网络</h2><ul><li>网络边缘<ul><li>主机：客户端和服务器</li><li>数据中心的服务器</li></ul></li><li>网络边缘的构成<ul><li>端系统（主机）<ul><li>运行应用程序，如：运行浏览器、微信等的网络应用程序的设备</li></ul></li></ul></li><li>网络应用的通信模型<ul><li>客户/服务器模型（<code>C/S</code>）</li><li>对等模型（<code>P2P</code>）</li></ul></li><li>接入网<ul><li>将网络边缘与网络核心连接起来，通常是将端系统连接到边缘路由器上</li><li>边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器</li></ul></li><li>接入的方式<ul><li>家庭：<code>Modem</code>拨号，<code>ADSL</code>拨号，<code>HFC</code>，<code>FTTH</code>，卫星</li><li>企业：以太网，<code>WIFI</code></li><li>广域无线接入：<code>3G</code>，<code>LTE</code>，<code>5G</code></li><li>局域网接入<ul><li>公司/大学的局域网（LAN）将端系统连接到边缘路由器</li><li>以太网</li></ul></li><li>无线接入<ul><li>共享的无线接入网络连接端系统和路由器</li><li>无线局域网</li><li>广域无线接入</li></ul></li></ul></li><li>物理媒体分类<ul><li>导引型媒体：信号沿着固体媒体被导引</li><li>非导引型媒体：信号自由传播</li><li>导引型媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ul></li></ul></li></ul><h2 id="网络核心：分组-x2F-电路交换；网络结构"><a href="#网络核心：分组-x2F-电路交换；网络结构" class="headerlink" title="网络核心：分组/电路交换；网络结构"></a>网络核心：分组/电路交换；网络结构</h2><ul><li><p>电路交换网络</p><ul><li>数据交换过程<ul><li>第一步：建立连接；第二步：交换数据；第三步：释放链接</li></ul></li><li>电路交换的特性<ul><li>电路交换网络中（数字通信）</li><li>数据交换前需建立起一条从发端到收端的电路（预留资源）</li><li>在数据交换的全部时间内用户始终占用端到端的固定传输信道</li><li>交换双方可实时进行数据交换而不会存在任何延迟</li><li>电路交换的用户始终占用端到端的通信资源<ul><li>独占链路，链路利用率太低</li></ul></li></ul></li><li>电路交换中的复用<ul><li>时分复用<ul><li>时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228212931943.png" alt="image-20211228212931943"></li></ul></li><li>频分复用<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228213021455.png" alt="image-20211228213021455"></li></ul></li></ul></li></ul></li><li><p>分组交换</p><ul><li><p>数据被截断划分为分组</p></li><li><p>分组交换机（路由器）转发分组</p></li><li><p>使用链路最大传输速率</p></li><li><p>为什么要分组</p><ul><li>提高传输效率</li><li>提高传输质量</li><li>链路利用率高</li></ul></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228213245233.png" alt="image-20211228213245233"></p></li><li><p>怎么分组</p><ul><li>在发送端，先把较长的报文划分成较短的、固定长度的数据段</li><li>每个数据段前面添加上首部构成分组</li><li>分组交换网以“分组”作为数据传输单元</li><li>依次把各分组发送到接收端</li><li>接收端收到分组后剥去首部还原成报文</li></ul></li><li><p>分组传输的模式</p><ul><li><p>存储转发传输</p><p>分组交换机（链路层交换机或路由器）将整个分组收下并存储存储后再发出去</p></li><li><p>原因：校验</p></li></ul></li><li><p>分组交换的特征</p><ul><li>数据分成若干组分别传送</li><li>不必预先确定分组的传输路径</li><li>交换节点均为共享节点，选择路径</li><li>存储/转发</li><li>断续（动态）分配传输带宽</li></ul></li><li><p>存储转发的效率和可靠性</p><ul><li>传输时延（发送时延）<ul><li>将分组推向链路的时间，L/R，其中R为链路带宽</li></ul></li><li>排队时延<ul><li>存储需要缓存，缓存的过程中可能需要排队（等待前面的分组处理）</li></ul></li><li>分组丢失<ul><li>缓存满，随即丢弃等方式</li></ul></li></ul></li><li><p>分组转发的路径（寻路）</p><ul><li>分组首部包含目的地址</li><li>路由表里面有转发表</li></ul></li></ul></li><li><p>分组交换 VS 电路交换</p><ul><li>分组交换网络存在的问题<ul><li>分组在各节点村存储转发时因为需要排队总会造成一定的时延，当网络通信量过大时，这种时延可能会很大</li><li>各分组必须携带一定的控制信息（说明信息），从而带来额外的开销</li><li>整个分组交换网的管理和控制比较复杂</li></ul></li><li>若要连续传送大量数据，且其传送时间远大于呼叫建立时间，则采用在数据通信之前预先分配传输带宽的电路交换较为合适</li><li>分组交换不需要预先分配带宽，在传送突发数据时可提高整个网络的信道利用率</li></ul></li></ul><h2 id="分组交换网的时延、丢包和吞吐量"><a href="#分组交换网的时延、丢包和吞吐量" class="headerlink" title="分组交换网的时延、丢包和吞吐量"></a>分组交换网的时延、丢包和吞吐量</h2><ul><li>分组交换比电路交换不足之处<ul><li>网络延迟<ul><li>时延、丢包等</li></ul></li></ul></li><li>数据丢失和产生时延的原因<ul><li>在路由器缓存中的分组队列<ul><li>分组到达输入链路的速率超出输出链路的能力</li><li>分组队列，等待转发</li></ul></li><li>节点处理实验<code>dproc</code><ul><li>检测比特差错</li><li>确定输出链路</li></ul></li><li>排队时延<code>dqueue</code><ul><li>在输出链路中等待被发送</li><li>取决于路由器的拥塞程度</li></ul></li><li>传输时延<code>dtrans</code><ul><li>R=链路带宽，L=分组长度</li><li>将分组比特流发送到链路上的时间=L/R</li></ul></li><li>传播时延<code>dprop</code><ul><li>d=物理链路的长度，s=媒体中的传播速度</li><li>传播时延=d/s</li></ul></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228215605760.png" alt="image-20211228215605760"></li></ul></li><li>吞吐量<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228215721466.png" alt="image-20211228215721466"></li></ul></li></ul><h2 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h2><ul><li><p>因特网的协议栈</p><ul><li>应用层，支持网络应用<ul><li><code>FTP</code>，<code>SMTP</code>，<code>HTTP</code></li></ul></li><li>运输层，主机间的数据传输<ul><li><code>TCP</code>，<code>UDP</code></li></ul></li><li>网络层，将数据报从源<strong>端</strong>传送到目的<strong>端</strong><ul><li><code>IP</code>，路由协议</li></ul></li><li>链路层，数据在网络相邻节点之间传输<ul><li><code>PPP</code>，以太网</li></ul></li><li>物理层，在线路上传输比特流</li></ul></li><li><p>封装</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228220205436.png" alt="image-20211228220205436"></li></ul></li></ul><hr><h1 id="第二章-应用层（报文）"><a href="#第二章-应用层（报文）" class="headerlink" title="第二章 应用层（报文）"></a>第二章 应用层（报文）</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><ul><li>网络应用的架构<ul><li>客户端/服务器</li><li>对等网（<code>P2P</code>）</li></ul></li><li>套接字<ul><li>每个网络应用进程都有一个属于自己的套接字，该套接字在整个因特网上独一无二<ul><li>主机地址：标识该网络进程运行在因特网上哪一台主机上，通产使用32位<code>IP</code>地址标识</li><li>端口地址：在该主机上标识该网络应用进程通常使用16位端口号标识</li></ul></li><li>长度为16+32=48位</li></ul></li></ul><h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><ul><li><code>URL</code><ul><li>任何一个对象都可以用URL来定位</li><li>例子：<code>www.hust.edu.cn/cs/pic.gif</code></li></ul></li><li>持续连接与非持续连接<ul><li>非持续连接<ul><li>每个请求/响应对是经过一个单独的TCP连接发送</li></ul></li><li>持续连接<ul><li>非流水线方式<ul><li>一个对象传输完成方能传输下一个</li></ul></li><li>流水线方式<ul><li>可以一次性发送所有请求，慢慢接收</li></ul></li></ul></li></ul></li><li><code>cookie</code><ul><li><code>web</code>使用<code>cookie</code>的目的<ul><li>限制用户的身份</li><li>把内容与用户身份关联起来</li></ul></li><li><code>cookie</code>技术的组成部分<ul><li>在HTTP响应报文中有一个<code>cookie</code>首部行</li><li>在HTTP请求报文中有一个<code>cookie</code>首部行</li><li>在用户的端系统中保留了一个<code>cookie</code>文件，由用户浏览器负责管理</li><li>在<code>web</code>站点有一个后端数据库</li></ul></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221647835.png" alt="image-20211228221647835"></li></ul></li></ul><h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a><code>DNS</code>：因特网的目录服务</h2><ul><li><p><code>DNS</code>系统，用于<code>IP</code>地址和域名之间的转换</p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221847533.png" alt="image-20211228221847533"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221826781.png" alt="image-20211228221826781"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221922645.png" alt="image-20211228221922645"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221931346.png" alt="image-20211228221931346"></p></li></ul><hr><h1 id="第三章-运输层（报文段）"><a href="#第三章-运输层（报文段）" class="headerlink" title="第三章 运输层（报文段）"></a>第三章 运输层（报文段）</h1><h2 id="概述与运输层服务"><a href="#概述与运输层服务" class="headerlink" title="概述与运输层服务"></a>概述与运输层服务</h2><ul><li>运输层的功能<ul><li>为不同主机上运行的应用程序之间提供逻辑通信</li></ul></li><li>运输层和网络层的区别<ul><li>网络层：不同主机间的逻辑通信</li><li>运输层：应用进程之间的逻辑通信</li></ul></li></ul><h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><ul><li>端口<ul><li>端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li></ul></li><li>套接字、端口和<code>IP</code><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228222740251-16407016614241.png" alt="image-20211228222740251"></li></ul></li><li><code>UDP</code>套接字由一个二元组标识<ul><li>包括一个目的<code>IP</code>地址和一个目的端口号</li><li>如果两个<code>UDP</code>报文段上述二元组相同，则通过同一个目的套接字被定向到相同的目的进程</li></ul></li><li><code>TCP</code>套接字由一个四元组标识<ul><li>(源<code>IP</code>地址，源端口号，目的<code>IP</code>地址，目的端口号)</li><li>接收方主机根据这四个值将报文段定向到相应的套接字</li><li><code>web</code>服务器为其每一个客户连接创建不同的套接字</li></ul></li></ul><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：<code>UDP</code></h2><ul><li>一个最简单的运输层协议必须提供<ul><li>多路复用/多路分解</li><li>差错检查</li></ul></li><li><code>UDP</code>处理数据的流程<ul><li>发送方<ul><li>从应用程序得到数据</li><li>附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段</li><li>递交给网络层，尽力而为的交付给接收主机</li></ul></li><li>接收方<ul><li>从网络层接收报文段</li><li>根据目的端口号，将数据交付给相应的应用进程</li></ul></li></ul></li><li><code>UDP</code>的优势<ul><li>无需建立连接</li><li>简单</li><li>段首部开销小（<code>8Byte</code>）</li><li>无拥塞控制</li></ul></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228223920354.png" alt="image-20211228223920354"></li><li><code>UDP</code>的检验和<ul><li>发送方<ul><li>把报文段看作是<code>16bit字</code>的序列</li><li>检验和：对报文段的所有<code>16bit字</code>的和进行反码运算（溢出回卷）</li><li>发送方将校验和写入<code>UDP</code>检验和字段中</li></ul></li><li>接收方<ul><li>计算接收到报文段的和</li><li>与发送方的检验和相加<ul><li>不全为1——检测出错</li><li>全为1——未检测到出错</li></ul></li></ul></li></ul></li></ul><h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><ul><li><p><code>rdt2.0</code></p><ul><li>假设<ul><li>分组比特可能受损</li><li>所有传输的分组都将按序被接收，不会丢失</li></ul></li><li>处理机制<ul><li>如如判断分组受损——差错检测（<code>ACK</code>和<code>NAK</code>）</li></ul></li></ul></li><li><p><code>rdt2.1</code></p><ul><li><p>问题引入</p><ul><li><code>ACK</code>和<code>NAK</code>的分组可能受损</li></ul></li><li><p>处理机制</p><ul><li><p>发送发重发——若收到被破坏的<code>ACK</code>或<code>NAK</code></p></li><li><p>为每一个数据报加上<strong>序号</strong></p></li><li><p>接收方收到重复序号则丢弃</p></li></ul></li></ul></li><li><p><code>rdt2.2</code></p><ul><li>改进<ul><li>只使用<code>ACK</code></li><li>取消<code>NAK</code>接收方对最后一个正确接收到的分组发送<code>ACK</code></li><li>发送方接收到重复的<code>ACK</code>将按照<code>NAK</code>处理</li></ul></li><li>停等协议<ul><li>发送方发送数据报之后等待接收方的响应</li></ul></li></ul></li><li><p><code>rdt3.0</code></p><ul><li>假设<ul><li>底层信道不但可能出错，而且可能会丢包</li></ul></li><li>处理机制<ul><li>丢包后重传</li><li>设置定时器</li></ul></li><li>性能低下<ul><li>停等操作</li></ul></li></ul></li><li><p>提高性能的方法——流水线技术</p><ul><li>允许发送方发送多个分组而无需等待确认<ul><li>增大序号范围（原来的0,1不够用）</li><li>发送方最低限度应当能缓存那些已发送但未被确认的分组</li><li>或许需要缓存那些已经正确接收的分组</li></ul></li><li>工作原理<ul><li>分组首部用k位<code>bit</code>字段表示序号</li><li>未被传输和已被传输但还未确认的分组的许可序号范围可以看作是一个在序号范围内大小为N的“窗口”</li></ul></li></ul></li><li><p>问题：当流水线技术中丢失一个分组后，如何进行重传</p><ul><li><code>Go-Back-N</code>协议：其后分组全部重传<ul><li>特点<ul><li><strong>累积确认</strong>——<code>ACK(n)</code>接收方对序号n之前包括n在内的所有分组进行确认</li><li><strong>一个定时器</strong>——从一次流水的最老分组开始计时</li><li><strong>超时</strong>——重传分组n和窗口中所有序号大于n的分组</li><li><strong>接收方无缓存</strong></li></ul></li><li>思考<ul><li>收到重复的分组怎么处理？</li><li>丢弃分组，重发<code>ACK</code></li><li>分组失序怎么办？</li><li>丢弃不缓存，重发按序到达的最高序号分组的<code>ACK</code></li></ul></li><li>发送端窗口<code>&lt;=</code> 2^k - 1</li></ul></li><li><code>SR</code>选择重传协议<ul><li>发送方<ul><li><strong>超时</strong>——为每个分组定义定时器，重传分组n，重置定时器</li><li>收到确认(n)在[<code>sendbase</code>,<code>sendbase+N</code>-1]范围内<ul><li>标记分组n为已接收</li><li>如果n是发送窗口基序号<code>sendbase</code>，则将窗口基序号前推倒下一个未确认序号</li><li>若窗口移动，新进入窗口的未发送分组会被发送</li></ul></li></ul></li><li>接收方<ul><li>分组序号n在[<code>rcvbase</code>,<code>rcvbase+N</code>-1]范围内<ul><li>发送n的确认<code>ACK</code></li><li>如果分组序号不连续：将其缓存</li><li>按序分组：将该分组以及缓存的序号连续的分组一起交付给上层，将窗口前推到下一个未收到的分组</li></ul></li><li>分组序号n在[<code>rcvbase</code>-N,<code>rcvbase</code>-1]范围内<ul><li>虽然确认过，仍再次发送<code>ACK</code></li></ul></li></ul></li><li>接收方窗口<code>&lt;=</code> 2^(k-1)</li></ul></li></ul></li></ul><h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：<code>TCP</code></h2><ul><li><p><code>RTT</code>的估算</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232243824.png" alt="image-20211228232243824"></li><li>参考值<code>0.125</code></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232341455.png" alt="image-20211228232341455"></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232414379.png" alt="image-20211228232414379"></li></ul></li><li><p><code>TCP</code>的特别之处</p><ul><li><code>TCP</code>采用按字节编号，而非按报文段序号</li><li><code>TCP</code>仅采用唯一的定时器</li><li><strong>超时</strong>——重传认为超时的报文段，重启定时器</li><li>**收到<code>ACK</code>**——如果是对之前未确认的报文段确认，跟新<code>sendbase</code>，如果还有未被确认的报文段，<code>TCP</code>重启定时器</li><li><strong>累计确认</strong></li><li><strong>超时间隔加倍</strong><ul><li>每一次<code>TCP</code>重传均将下一次超时间隔设为先前值的两倍</li><li>超时间隔由<code>EstimatedRTT</code>和<code>DevRTT</code>决定</li><li>发生以下两个事件，超时间隔重新计算<ul><li>收到上层应用的数据</li><li>收到对未确认的数据的<code>ACK</code></li></ul></li></ul></li><li><strong>快速重传</strong><ul><li>超时周期往往太长——增加重发丢失分组的延时</li><li>通过重复的<code>ACK</code>来检测丢失报文段<ul><li>发送方常要连续的发送大量报文段</li><li>如果一个报文段丢失，会引起很多连读的重复<code>ACK</code></li></ul></li><li>如果发送方收到一个数据的**3个<code>ACK</code>**，他会认为确认数据之后的报文段丢失</li><li>在超时到来之前重传报文段<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228233915888.png" alt="image-20211228233915888"></li></ul></li></ul></li><li>产生<code>TCP ACK</code>的建议<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228233400620.png" alt="image-20211228233400620"></li></ul></li></ul></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232921174.png" alt="image-20211228232921174"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232953609.png" alt="image-20211228232953609"></p></li><li><p>流量控制</p><ul><li><p>目标</p><ul><li>发送方不会由于传的太多太快而是的接收方缓存溢出</li></ul></li><li><p>手段</p><ul><li>接收方在反馈时，将缓冲区的剩余空间大小填充在报文段首部的窗口字段中，通知发送方</li></ul></li><li><p>窗口值的计算</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228234101652.png" alt="image-20211228234101652"></li></ul></li><li><p>发送方持续向接收方发送只有一个字节数据的报文段，目的是试探</p></li></ul></li></ul><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul><li>拥塞窗口(<code>cwnd</code>)</li><li>发送方如何感知拥塞<ul><li>超时</li><li>三个冗余<code>ACK</code></li></ul></li><li>拥塞处理<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228234651088.png" alt="image-20211228234651088"></li><li>看题目</li></ul></li><li><code>TCP</code>的吞吐量<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228235133034.png" alt="image-20211228235133034"></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228235145021.png" alt="image-20211228235145021"></li></ul></li></ul><hr><h1 id="第四章-网络层—数据平面（数据报）"><a href="#第四章-网络层—数据平面（数据报）" class="headerlink" title="第四章 网络层—数据平面（数据报）"></a>第四章 网络层—数据平面（数据报）</h1><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><ul><li>网络层的目标<ul><li>实现主机到主机之间的通信</li></ul></li><li>网络层在计算机网络中的地位<ul><li>为运输层提供支持<ul><li>运输层实现进程到进程的通信</li><li>运输层功能的实现依赖于网络层提供的服务</li></ul></li></ul></li><li>网络层的主要功能<ul><li>在全局范畴为主机之间的通信进行选路，选路的结果反应为分组交换机的转发表</li><li>分组交换设备上的网络层根据 以及分组头部信息，将分组向适当链路进行转发</li></ul></li><li>分组交换机设备分类<ul><li>根据<strong>链路层首部信息</strong>进行转发的——链路层节点交换机</li><li>根据<strong>网络层首部信息</strong>进行转发的——路由器</li></ul></li></ul><h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><ul><li>最长前缀匹配<ul><li>查找给定目标地址的转发表项时，请使用与目标地址匹配的最长地址前缀</li></ul></li><li>输入端口排队<ul><li>输入端口的处理速率超过了交换结构的速率</li><li>线头阻塞：在输入队列中排队的分组必须等待通过交换结构发送，因为它被位于线头的另一个分组阻塞了</li><li>输入缓冲区溢出可能导致排队时延和丢包</li></ul></li><li>交换结构<ul><li>经内存交换</li><li>经总线交换</li><li>经内联网络交换</li></ul></li><li>输出端口<ul><li>交换结构将分组交付给输出端口的速率超过输出链路的速率</li></ul></li></ul><h2 id="网际协议：IPv4、寻址"><a href="#网际协议：IPv4、寻址" class="headerlink" title="网际协议：IPv4、寻址"></a>网际协议：<code>IPv4</code>、寻址</h2><ul><li><p><code>IP</code>分片和分组</p><ul><li>网络链路具有<code>MTU(最大传输单位)</code>属性——由链路层最大帧决定</li><li>不同类型的链路有不同的<code>MTU</code>值</li><li>大的<code>IP</code>数据报在网络中会被分为小的分片<ul><li>一个数据报变成了几个数据报</li><li>重组只在目的主机进行</li><li>数据报头部的<strong>标识、标志、片偏移、长度字段</strong>用于目的主机对接收的分片进行重组</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229095807949.png" alt="image-20211229095807949"></li></ul></li></ul></li><li><p><code>IP</code>地址</p><ul><li><p>高位：网络号；低位：主机号</p></li><li><p><code>IP</code>地址的分类</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229095919777.png" alt="image-20211229095919777"></li></ul></li><li><p>划分子网：从主机号中借一部分作为子网号</p><ul><li><p>子网掩码</p><ul><li>作用：对外隐藏子网的存在，对内指示网络号和子网号的位置</li><li>获得方法：通过在网络号的子网号相应的位置全置1，主机号相应的位置全置0，即可得到子网掩码</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229100206074.png" alt="image-20211229100206074"></li></ul></li><li><p>网络地址</p><ul><li><strong><code>IP</code>地址</strong> AND <strong>子网掩码</strong> = <strong>网络地址</strong></li></ul></li><li><p>引入子网掩码后的寻址</p><ul><li><p>检查分组目的地址的<code>IP</code>地址的网络号</p><p>若网络号不是本网络，则从路由表中找出相应的转发节点地址将其转发出去</p></li><li><p>检查子网号</p><p>当网络号是本网络时，路由器将检查子网号，向相应的子网转发此分组</p></li></ul></li></ul></li><li><p><code>IP</code>地址的扩展——构造超网</p><ul><li>从网络号中借用一部分作为主机号</li></ul></li></ul></li><li><p><code>CIDR</code></p><ul><li>最长前缀匹配<ul><li>使用<code>CIDR</code>时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成，在查找路由表时可能得到不止一个匹配结果</li><li>网络前缀越长，启迪之快就越小，因而路由越具体</li></ul></li></ul></li><li><p><code>DHCP</code>协议——动态主机配置协议</p><ul><li>工作在<strong>应用层</strong></li><li><code>IP</code>地址请求过程（全广播）<ul><li>主机广播“<code>DHCP</code>发现”报文</li><li><code>DHCP</code>服务器使用“<code>DHCP</code>提供”报文应答</li><li>主机使用“<code>DHCP</code>请求”报文请求<code>IP</code>地址</li><li><code>DHCP</code>服务器使用“<code>DHCP ACK</code> ”报文响应</li></ul></li><li><code>DHCP</code>除获取<code>IP</code>地址外，还能获取<strong>网关地址、<code>DNS</code>地址、子网掩码</strong></li></ul></li><li><p><code>NAT</code>协议</p><ul><li>动机：本地网络只需要使用一个<code>IP</code>地址就可以与外部网络相连</li><li>实现<ul><li>发送数据报：将每个外出报文的<strong>源<code>IP</code>地址，端口号</strong>替换为**<code>NAT IP</code>地址以及新的端口号**</li><li>记住每一个地址转换对</li><li>接收数据报：根据<code>NAT</code>转换表将每个进入报文的<code>NAT IP</code>地址，端口号替换为相应的源<code>IP</code>地址以及端口号</li></ul></li><li>三种地址转换方式<ul><li>静态<code>NAT</code></li><li>动态<code>NAT</code></li><li>端口<code>NAT</code></li></ul></li><li>属于<strong>网络层</strong>协议</li></ul></li><li><p><code>ICMP</code>：因特网控制报文协议</p><ul><li>用于主机、路由器、网关之间交换网络层信息<ul><li>错误报告：如住家、网络、端口、协议不可达等</li><li>回声请求/回答（用于<code>ping</code>程序）</li></ul></li><li>网络层协议</li></ul></li></ul><h1 id="第五章-网络层—控制平面"><a href="#第五章-网络层—控制平面" class="headerlink" title="第五章 网络层—控制平面"></a>第五章 网络层—控制平面</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><ul><li><p>几个概念</p><ul><li>默认路由器：一台主机“直接”连接到的路由器</li><li>源路由器：源主机的默认路由器</li><li>目的路由器：目的主机的默认路由器</li></ul></li><li><p>选路算法的目的</p><ul><li>给定一组路由器以及连接路由器的链路，从这找出一条从源路由器到目标路由器“好的”路径</li></ul></li><li><p>选路算法的分类</p><ul><li><p>根据信息是全局性的还是分散式的进行分类</p><ul><li><p>全局选路算法</p><p>所有路由器都知道整个网络拓扑图以及链路的费用信息</p><p><strong>链路状态算法</strong></p></li><li><p>分散式选路算法</p><p>每个路由器仅有与其相连链路的费用信息</p><p><strong>距离向量算法</strong></p></li></ul></li><li><p>根据信息是静态的还是动态的进行分类</p><ul><li><p>静态选路算法</p><p>随着时间的流逝，路由变换非常缓</p></li><li><p>动态选路算法</p><p>路由信息周期性的更新</p></li></ul></li><li><p>根据是否对负载敏感进行分类</p><ul><li>负载敏感算法</li><li>负载迟钝算法</li></ul></li></ul></li><li><p>迪杰斯特拉算法——链路状态算法</p><ul><li><code>OSPF</code>协议——链路状态协议<ul><li>使用迪杰斯特拉算法</li></ul></li><li>在哪一层有争议</li></ul></li><li><p>距离向量算法</p><ul><li>好消息传的快</li><li>坏消息传的慢</li></ul></li><li><p>层次路由</p><ul><li>将路由器聚合到一个区域——<strong>自治系统(<code>AS</code>)</strong><ul><li>在相同<code>AS</code>内的路由器可全部运行同样的选路算法</li><li>一般使用<code>OSPF</code>协议（或<code>RIP</code>协议）</li><li>在不同的<code>AS</code>内可以使用不同的选路算法</li></ul></li><li>转发表是由<code>AS</code>内部选路算法和<code>AS</code>间选路算法共同决定的<ul><li><code>AS</code>内部选路算法为内部目的地址设置转发表信息</li><li><code>AS</code>内部选路算法和<code>AS</code>间选路算法共同为外部目的地址设置转发表信息</li></ul></li><li>因特网上的<code>AS</code>内层次路由——层次<code>OSPF</code><ul><li>为了使<code>OSPF</code>能够用于规模很大的网络，<code>OSPF</code>将一个自制系统再划分为若干个更小的范围，叫做区域</li><li>划分区域的好处是将利用洪泛法交换链路信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量</li><li><code>OSPF</code>使用层次结构的区域划分，在上层的区域叫作主干区域</li></ul></li></ul></li><li><p>因特网上的<code>AS</code>间路由——<code>BGP(边界网关协议)</code></p><ul><li>每一个自治系统的管理员要选择至少一个路由作为该自治系统的“<code>BGP</code>发言人”</li><li>使用<code>TCP</code>，因此是<strong>应用层</strong>协议</li><li><code>BGP</code>路由通告<ul><li><code>AS2</code>可以聚合多个前缀为一个，并使用<code>BGP</code>向<code>AS1</code>通告单一前缀，则<code>AS2</code>承诺它将沿着朝向该前缀的路径，转发指向该前缀的任何数据报</li><li>当路由器通告一个前缀时，它随着前缀包含一些<code>BGP</code>属性</li><li>两个重要属性<ul><li><code>AS-PATH</code>：该属性包含了前缀的通告已经经过的那些<code>AS</code></li><li><code>NEXT-HOP</code>：指明到下一跳<code>AS</code>的具体的路由器</li></ul></li></ul></li><li><code>BGP</code>路由选择<ul><li>一台路由器可能知道一条前缀的多条路由路径，路由器必须在可能的路由中选择一条</li><li>消除规则<ul><li>本地偏好值</li><li>最短<code>AS-PATH</code>：在余下的路由中，具有最短<code>AS-PATH</code>的路由将被选择</li><li>从余下的路由中，选择具有最靠近<code>NEXT-HOP</code>路由器的路由：热土豆路由</li><li>如果仍余下多条路由，该路由器使用<code>BGP</code>标识以选择路由</li></ul></li></ul></li></ul></li></ul><h1 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h1><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><ul><li>术语<ul><li>节点：主机和路由器</li><li>链路：沿着通信路径连接相邻节点的通信信道<ul><li>有线链路</li><li>无线链路</li></ul></li></ul></li><li>链路层的主要功能<ul><li>负责将数据报通过链路从一个节点传输到物理上相邻的节点</li></ul></li><li>链路层提供的服务<ul><li>成帧<ul><li>将数据加上头部和尾部，封装成数据帧</li><li>帧头部用<code>MAC</code>地址标识源和目的</li></ul></li><li>链路接入<ul><li>共享介质的信道访问</li></ul></li><li>可靠交付</li></ul></li><li>差错检测和纠正</li><li>流量控制</li><li>发送方和接收方<ul><li>发送方<ul><li>在一个帧内封装数据报</li><li>增加差错检测位，可靠交付，流量检测</li></ul></li><li>接收方<ul><li>查找错误，可靠交付，流量控制</li><li>取出数据报，交给网络层</li></ul></li></ul></li></ul><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><ul><li>奇偶校验</li><li>因特网检查和</li><li>循环冗余校验码(<code>CRC</code>)<ul><li><code>D*2^r</code>除以<code>G</code>，得到余数<code>R</code></li></ul></li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul><li><p>两种链路</p><ul><li>点到点链路<ul><li><code>PPP</code>、<code>HDLC</code></li></ul></li><li>广播链路（贡献链路或介质）<ul><li>传统以太网</li><li>802.11无线LAN</li><li><code>HFC</code></li></ul></li></ul></li><li><p>广播链路的特点</p><ul><li>单个共享广播信道</li><li>两个或多个节点同时传输：相互干扰</li></ul></li><li><p>多路访问协议</p><ul><li><p>信道划分协议：将信道划分成小的“片”</p><ul><li><code>TDMA</code><ul><li>循环访问信道，每个节点在每次循环中得到固定长度的时隙</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229111057712.png" alt="image-20211229111057712"></li></ul></li><li><code>FDMA</code><ul><li>信道按频谱分成若干频段</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229111137570.png" alt="image-20211229111137570"></li></ul></li></ul></li><li><p>随机接入协议：信道没有被划分，允许碰撞</p><ul><li><p>当节点有数据时</p><ul><li>以信道全部速率<code>R</code>传输</li><li>没有主节点起协调作用</li></ul></li><li><p>协议举例</p><ul><li>ALOHA、时隙ALOHA</li><li><code>CSMA</code>、<code>CSMA/CD</code>、<code>CSMA/CA</code></li></ul></li><li><p><code>CSMA</code></p><ul><li><p>非坚持<code>CSMA</code></p><p>一旦监听到信道忙就不再监听下去，而是根据协议的算法延迟一个随机的时间后重新再监听</p></li><li><p>时隙非坚持<code>CSMA</code></p><p>规定只能在每个时隙开始时传输帧</p></li><li><p>1坚持<code>CSMA</code></p><p>若信道正忙，则持续监听直到空闲</p></li><li><p>P坚持<code>CSMA</code></p></li></ul></li><li><p><code>CSMA/CD</code></p><ul><li><p>强化碰撞</p><p>当发送数据的站一旦发现了碰撞，除了立即停止发送外，还要继续发送若干比特的人为干扰信号</p><p>拥塞信号：<code>48bit</code></p></li><li><p><strong>争用期</strong></p><ul><li>最先发送数据帧的站，在发送数据帧后至多经过时间<code>2t</code>（两倍的端到端往返时延），就可以知道发送的数据帧是否遭受了碰撞</li><li>以太网端到端往返时延<code>2t</code>被称为争用期</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112733511.png" alt="image-20211229112733511"></li></ul></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112122332.png" alt="image-20211229112122332"></p></li></ul></li></ul></li><li><p>轮流协议：节点轮流传送，但数据量大的节点轮流时间更长</p><ul><li>轮询协议</li><li>令牌传递协议</li></ul></li></ul></li></ul><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><ul><li>链路层寻址和<code>ARP</code><ul><li><code>MAC</code>地址<ul><li>在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点</li><li><code>48bit</code></li></ul></li><li><code>ARP</code>协议<ul><li>根据目标的<code>IP</code>地址获取其<code>MAC</code>地址</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112548785.png" alt="image-20211229112548785"></li></ul></li></ul></li><li>信号编码<ul><li>曼彻斯特编码<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112922234-16407485643571.png" alt="image-20211229112922234"></li></ul></li><li>差分曼彻斯特<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229113027981.png" alt="image-20211229113027981"></li></ul></li></ul></li><li>交换机的自学习</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>协议<ul><li><code>DCHP</code>——应用层，使用<code>UDP</code></li><li><code>BGP</code>——应用层，使用<code>TCP</code></li><li><code>ICMP</code>——网络层</li><li><code>ARP</code>——网络层</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>osNote</title>
      <link href="/2022/03/09/osNote/"/>
      <url>/2022/03/09/osNote/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="操作系统的定义和特性"><a href="#操作系统的定义和特性" class="headerlink" title="操作系统的定义和特性"></a>操作系统的定义和特性</h2><ul><li>桌面常见的四大操作系统<ul><li><code>Windows</code>系统</li><li><code>Linux</code>系统<ul><li><code>RedHat</code>小红帽</li></ul></li><li><code>Mac</code>系统</li><li><code>Unix</code>系统</li></ul></li><li>没有安装操作系统的计算机能干什么<ul><li>无法继续启动</li><li>没有安装操作系统的计算机开机进入<code>DOS</code>界面，需要输入指令来进行操作，无法使用鼠标、键盘等，裸机启动过程分为三步（也就是会进入<code>BIOS</code>）：<ol><li>裸机上电后，会启动自检程序，自检程序会对硬件进行检测，判断计算机情况是否正常，若有问题则提示；</li><li>初始化操作，对一些外部设备进行初始化和检测；</li><li>引导程序，引导DOS</li></ol></li></ul></li><li>操作系统的基本功能<ul><li>提供操作界面</li><li>控制程序运行</li><li>管理系统资源</li><li>配置系统参数</li><li>监控系统状态</li><li>工具软件集合</li></ul></li><li>操作系统的定义<ul><li>操作系统是一个大型系统程序，它负责计算机系统软、硬件资源的分配；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境</li><li>简而言之，管理并调度资源，为用户提供接口</li></ul></li><li>不同角度理解操作系统<ul><li>终端用户<ul><li>界面和命令</li></ul></li><li>应用程序员<ul><li>编程接口<code>API</code></li></ul></li><li>系统程序员<ul><li>管理和调度硬件资源</li><li>提供接口</li></ul></li></ul></li><li>操作系统的地位<ul><li><img src="/2022/03/09/osNote/image-20211231210548905.png" alt="image-20211231210548905"></li></ul></li><li>操作系统的特性（<strong>重点</strong>）<ul><li>并发性<ul><li>同时处理多个任务的能力</li></ul></li><li>共享性<ul><li>为多个并发任务提供资源共享</li></ul></li><li>不确定性<ul><li>具有处理随机事件的能力<ul><li>中断处理的能力</li><li>自动化能力</li></ul></li></ul></li></ul></li></ul><h2 id="操作系统的功能（重点）"><a href="#操作系统的功能（重点）" class="headerlink" title="操作系统的功能（重点）"></a>操作系统的功能（<strong>重点</strong>）</h2><ul><li>进程管理功能、存储管理功能、设备管理功能、文件管理功能</li><li>进程管理<ul><li>处理机分配</li><li><code>CPU</code>管理</li><li>处理机管理</li><li>多个程序如何共享<code>CPU</code></li><li>具体功能：<ul><li>进程控制：创建，暂停，唤醒，撤销</li><li>进程调度：调度策略，优先级</li><li>进程通信：进程间通信</li></ul></li></ul></li><li>存储管理<ul><li>为应用程序运行高效提供内存空间</li><li>支持多道程序设计</li><li>作用：<ul><li>内存分配</li><li>内存共享</li><li>内存保护</li><li>虚拟内存</li></ul></li></ul></li><li>设备管理<ul><li>提供统一的设备使用接口，管理设备分配和使用<ul><li>设备无关性</li><li>设备的传输控制</li><li>设备的驱动</li></ul></li></ul></li><li>文件管理<ul><li>文件和目录的管理</li><li>提供简便统一的信息存取和管理方法，解决信息共享、数据的存取控制等问题<ul><li>存储空间管理</li><li>文件的操作</li><li>目录的操作</li><li>文件和目录的存取权限管理</li></ul></li></ul></li></ul><h2 id="操作系统的性能"><a href="#操作系统的性能" class="headerlink" title="操作系统的性能"></a>操作系统的性能</h2><ul><li>吞吐率<ul><li>在单位时间内处理信息的能力</li></ul></li><li>响应能力<ul><li>从接收数据到输出结果的时间间隔</li></ul></li><li>资源利用率<ul><li>设备使用的频度</li></ul></li><li>可移植性<ul><li>改变硬件环境仍能正常工作的能力：代码修改量</li></ul></li><li>可靠性<ul><li>发现、诊断和恢复系统故障的能力</li></ul></li></ul><h2 id="操作系统的发展历史"><a href="#操作系统的发展历史" class="headerlink" title="操作系统的发展历史"></a>操作系统的发展历史</h2><ul><li><p>计算机硬件发展的四个典型阶段</p><ul><li>电子管时代</li><li>晶体管时代</li><li>集成电路时代</li><li>大规模集成电路时代</li></ul></li><li><p>操作系统发展的四个典型阶段</p><ol><li>手工操作</li><li>单道批处理系统</li><li>多道批处理系统</li><li>分时操作系统</li></ol></li><li><p>手工操作</p><ul><li>使用特点<ul><li>上机：编程（打孔），预约，操作机器（开关/接线）</li><li>程序启动与结束：手工处理</li></ul></li><li>缺点<ul><li>效率低：<code>CPU</code>运行时间少，例：100分钟 = 50分钟(装) + 10(<code>CPU</code>运行) + 40(拆)</li><li>用户独占</li><li>缺少交互</li></ul></li></ul></li><li><p>单道批处理系统</p><ul><li>工作过程<ul><li>管理员将多个作业输入到磁盘形成作业队列</li><li>监控程序依次自动处理磁盘中的每个作业<ul><li>装入—运行—撤出—装入—运行—撤出—……</li></ul></li><li>运行完毕，通知用户取出结果</li></ul></li><li>工作特点<ul><li>一批：作业队列</li><li>自动：识别作业</li><li>单道：串行</li></ul></li><li>单道批处理的两种实现方式<ul><li>联机批处理<ul><li><img src="/2022/03/09/osNote/image-20220101113211078.png" alt="image-20220101113211078"></li><li>特点：主机控制输入/输出</li><li>缺点：系统效率低</li></ul></li><li>脱机批处理<ul><li><img src="/2022/03/09/osNote/image-20220101113304832.png" alt="image-20220101113304832"></li><li>特点：卫星机控制输入/输出</li><li>优点：系统效率高</li><li>缺点：调度不灵活；保护问题</li></ul></li></ul></li><li>单道批处理系统中<code>CPU</code>的使用情况<ul><li><img src="/2022/03/09/osNote/image-20220101113722924.png" alt="image-20220101113722924"></li><li>现象：外设工作时<code>CPU</code>空闲，<code>CPU</code>工作时外设空闲</li><li>结论：<code>CPU</code>和外设效率低</li></ul></li><li>单道批处理系统程序的改进<ul><li><img src="/2022/03/09/osNote/image-20220101113908340.png" alt="image-20220101113908340"></li><li>程序设计合理<ul><li>使得<code>IO</code>发生时，程序可以继续做一些其他的工作，例如上图中的<code>WhileReading()</code>函数</li></ul></li><li>系统必须提供工具<ul><li>程序可以启动设备和测试设备</li></ul></li></ul></li></ul></li><li><p>多道批处理系统（<strong>重点</strong>）</p><ul><li>多道程序设计技术<ul><li>在内存中存放多道程序，当某道程序因为某种原因（例如请求<code>IO</code>时）不能继续运行，监控程序便调度另一程序投入运行，这样可以使<code>CPU</code>尽量处于忙绿状态，提高系统效率</li></ul></li><li>多道批处理系统<ul><li>采用多道程序设计技术实现的处理系统称为多道批处理系统</li></ul></li><li>多道批处理系统的设计目的<ul><li>提高系统的利用率（或吞吐量）<ul><li><code>CPU</code>和外设并行</li><li>外设之间也并行</li></ul></li></ul></li><li>多道程序相互穿插的运行过程<ul><li><img src="/2022/03/09/osNote/image-20220101114517467.png" alt="image-20220101114517467"></li><li><code>A、B</code>两道程序相互穿插的运行，使<code>CPU</code>和外设都尽量忙碌</li></ul></li><li>多道程序设计思想<ul><li>多个程序同时在计算机/虚拟机上运行</li><li>物理资源的共享<ul><li>时分：分成多个时段，不同进程错开使用不同时段</li><li>空分：分成多个单元，不同进程同时使用不同单元</li><li><img src="/2022/03/09/osNote/image-20220101114840918.png" alt="image-20220101114840918"></li></ul></li></ul></li><li>多道批处理系统的特点<ul><li>多道：内存同时存放多道程序</li><li>并行：宏观上</li><li>串行：微观上</li></ul></li><li>意义：多道技术出现——操作系统形成</li><li>多道批处理系统的缺点<ul><li>作业处理时间长</li><li>运行过程不确定</li><li>交互能力差</li><li><img src="/2022/03/09/osNote/image-20220101115115243.png" alt="image-20220101115115243"></li></ul></li><li>60年代硬件的两个重大进展<ul><li>中断技术<ul><li>当<code>CPU</code>收到外部信号（中断信号）后，停止当前的工作，转去处理该外部事件，处理完毕后回到原来工作的中断处（断点）继续原来的工作</li></ul></li><li>通道技术<ul><li>专门处理外设和内存之间的数据传输的处理机</li></ul></li></ul></li></ul></li><li><p>分时技术与多道批批处理系统都能完成多个程序的切换，这两种切换有何差别</p><ul><li>分时技术采用的方法是，主机以很短的时间片为单位把<code>CPU</code>轮流分配给每个终端使用，直到作业被全部运行完，让终端认为自己独占<code>CPU</code></li><li>多道批操作系统是内存中存放了多个程序，程序相互穿插运行，当某道程序没有使用<code>CPU</code>时，系统调度另一程序投入执行；多道批处理本质在微观上还是相当于单道批，但是分时技术可以把多个程序真正地“同时”（差别时间不大）运行</li></ul></li><li><p>分时操作系统</p><ul><li><p>背景</p><ul><li>中断技术</li><li>大规模集成电路</li><li>事务性任务和程序的涌现<ul><li>交互性高</li><li>响应快速</li></ul></li><li>要求：多任务多用户</li></ul></li><li><p>多终端计算机</p><ul><li>主机采用分时技术轮流为每个终端服务，每个终端都感觉到是“独占”主机</li></ul></li><li><p>分时技术（<strong>重点</strong>）</p><ul><li><p>概念</p><ul><li>主机以很短的“<strong>时间片</strong>”为单位，把<code>CPU</code>循环的轮流分配给每个作业（终端/用户）使用，直到全部作业被运行完</li></ul></li><li><p>特点</p><ul><li><p>时间片：较短时间间隔</p></li><li><p>响应及时：独占主机</p></li></ul></li></ul></li><li><p>分时系统的特点</p><ul><li>多路调制性<ul><li>多用户联机使用同一台计算机</li></ul></li><li>独占性<ul><li>用户感觉独占一台计算机</li></ul></li><li>交互性<ul><li>及时响应用户的请求</li></ul></li></ul></li></ul></li><li><p><code>UNIX</code></p><ul><li>第一个实用化的分时操作系统</li><li>革新和创造<ul><li>实现了操作系统的可移植性</li><li>“特殊文件”：外设看作文件</li></ul></li></ul></li><li><p>操作系统的进一步发展</p><ul><li>实时操作系统/嵌入式操作系统</li><li>微机操作系统</li><li>多处理机操作系统</li><li>网络操作系统</li><li>分布式操作系统</li><li>嵌入式操纵系统</li></ul></li></ul><h1 id="第二章-操作系统结构与硬件支持"><a href="#第二章-操作系统结构与硬件支持" class="headerlink" title="第二章 操作系统结构与硬件支持"></a>第二章 操作系统结构与硬件支持</h1><h2 id="操作系统虚拟机（重点）"><a href="#操作系统虚拟机（重点）" class="headerlink" title="操作系统虚拟机（重点）"></a>操作系统虚拟机（重点）</h2><ul><li>面对用户，裸机配置操作系统后称为操作系统虚拟机<ul><li>用户界面</li><li>屏蔽硬件细节</li><li>扩展硬件功能</li><li>系统更安全</li><li>系统更可靠</li><li>效率更高</li></ul></li></ul><h2 id="操作系统的逻辑结构"><a href="#操作系统的逻辑结构" class="headerlink" title="操作系统的逻辑结构"></a>操作系统的逻辑结构</h2><ul><li><p>逻辑结构</p><ul><li><code>OS</code>的设计和实现思路</li></ul></li><li><p>逻辑结构的种类</p><ul><li>整体式结构（单体式结构、宏内核结构）</li><li>微内核结构</li><li>层次式结构</li></ul></li><li><p>整体式结构</p><ul><li>以模块为基本单位构建<ul><li>每个模块具有特定的功能</li></ul></li><li>定义<ul><li>模块化结构/单体内核结构/宏内核结构</li><li>操作系统由大量的过程构成，每个过程都有明确参数列表、返回值类型，大多数过程是可以相互间调用的</li><li><img src="/2022/03/09/osNote/image-20220101142121165.png" alt="image-20220101142121165"></li></ul></li><li>优点<ul><li>模块的设计、编码和调试独立</li><li>模块之间可以相互调用</li></ul></li><li>缺点<ul><li>错误容易扩散</li><li>开发和维护困难</li><li>可伸缩性差</li></ul></li><li>实例<code>os</code>——<code>UNIX</code><ul><li>采用单一内核模块（单体结构）实现</li><li>对外提供一组系统调用</li><li>设备驱动与内核其他部分分开</li></ul></li><li>实例<code>os</code>——<code>Linux</code><ul><li>宏内核，单体内核</li><li>支持动态可安装模块</li><li>模块可以在操作系统中动态安装或去除</li><li>模块可以在内核运行时编译或安装</li></ul></li></ul></li><li><p>层次式结构</p><ul><li><p>层次结构的软件例子——<code>TCP/IP</code>协议栈</p></li><li><p>定义</p><ul><li>功能模块按调用次序排成若干层，各层单向依赖或单向调用</li><li><img src="/2022/03/09/osNote/image-20220101142104116.png" alt="image-20220101142104116"></li></ul></li><li><p>分层原则</p><ul><li>硬件相关——最底层</li><li>外部特性——最外层</li><li>中间层——调用次序或消息传递顺序</li><li>共性服务——较低层</li><li>活跃功能——较低层</li></ul><ol><li>硬件相关的放在最底层</li><li>与用户策略或用户交互相关的功能放在最顶层</li><li>中间层各层按调用次序或消息传递次序安排</li><li>共性的和活跃的服务放在较低的层次</li></ol></li><li><p>层次结构的优点</p><ul><li>结构清晰，避免循环调用</li><li>整体结构局部化，系统的正确性容易保证</li><li>有利于操作系统的维护、扩充和移植</li></ul></li></ul></li><li><p>微内核结构（客户/服务器结构）</p><ul><li>客户——应用程序</li><li>服务器——操作系统<ul><li>微内核<ul><li>足够小，提供<code>OS</code>最基本的核心功能和服务</li><li>足够与硬件紧密相关的处理</li><li>实现一些较基本的功能</li><li>负责客户与服务器之间的通信</li></ul></li><li>核外服务器<ul><li>完成<code>OS</code>的绝大多数功能，等待用户提供请求</li><li>由若干服务器或进程共同构成<ul><li>例如：进程/线程服务器，虚存服务器，设备管理服务器等，以进程形式运行在用户态</li></ul></li></ul></li><li><img src="/2022/03/09/osNote/image-20220101142309979.png" alt="image-20220101142309979"></li></ul></li></ul></li><li><p>微内核和单体内核（宏内核）的比较</p><ul><li><img src="/2022/03/09/osNote/image-20220101142441329.png" alt="image-20220101142441329"></li></ul></li></ul><h2 id="操作系统依赖的基本硬件环境"><a href="#操作系统依赖的基本硬件环境" class="headerlink" title="操作系统依赖的基本硬件环境"></a>操作系统依赖的基本硬件环境</h2><h3 id="处理机的态（重点）"><a href="#处理机的态（重点）" class="headerlink" title="处理机的态（重点）"></a>处理机的态（<strong>重点</strong>）</h3><ul><li><p>支持操作系统的最基本的硬件结构</p><ul><li><code>CPU</code>、内存、中断、时钟</li></ul></li><li><p>操作系统考虑的安全问题</p><ul><li>共享/安全<ul><li>防止进程的信息被非法访问</li><li>防止进程随意存取系统资源</li><li>防止进程修改系统安全机制</li><li><img src="/2022/03/09/osNote/image-20220101142817081.png" alt="image-20220101142817081"></li></ul></li><li>解决策略<ol><li>软件被设置为可信软件和不可信软件两类<ul><li>保护机制能区分可信软件和不可信软件</li><li>可信软件权限高<ul><li>可以修改安全保护机制</li><li>可以存取系统资源</li></ul></li><li>不可信软件<ul><li>功能受限</li></ul></li><li><code>CPU</code>能区分当前软件的类型并设置不同的工作模式</li></ul></li><li>设置访问屏障<ul><li><code>CPU</code>根据当前的工作模式，限制可使用的指令集</li><li>设置可信软件和不可信软件之间的访问屏障</li></ul></li></ol></li></ul></li><li><p><code>CPU</code></p><ul><li><code>CPU</code>态（<code>Mode</code>）<ul><li><code>CPU</code>的工作状态</li><li>对<strong>资源和指令使用</strong>权限的描述</li></ul></li><li>硬件描述<ul><li>在处理器中包含有一个模式位，表明当前的权限状态</li><li>指令执行前增加“权限状态是否满足”的条件判断</li><li><code>Intel CPU</code><ul><li><code>PE</code>位，<code>PG</code>位</li><li>地址映射机制</li><li>权限核验</li></ul></li></ul></li><li>特权指令<ul><li>类别<ol><li>涉及外部设备的输入/输出指令</li><li>修改特殊寄存器的指令</li><li>改变机器状态的指令</li></ol></li></ul></li><li><code>CPU</code>态的分类<ul><li>核态<ul><li>能够访问所有资源和执行所有指令</li><li>管理程序/<code>OS</code>内核</li></ul></li><li>用户态<ul><li>仅能访问部分资源，其他资源受限</li><li>用户进程</li></ul></li><li>管态<ul><li>介于核态和用户态之间</li></ul></li></ul></li><li>硬件和<code>OS</code>对<code>CPU</code>的观察<ul><li>硬件按“态”来区分<code>CPU</code>的状态</li><li><code>OS</code>按“进程”来区分<code>CPU</code>的状态</li><li><img src="/2022/03/09/osNote/image-20220101145115299.png" alt="image-20220101145115299"></li></ul></li><li>用户态和核态之间的转换<ul><li>用户态向核态转换<ul><li>用户请求<code>OS</code>提供服务</li><li>发生中断</li><li>用户进程产生错误（内部中断）</li><li>用户态企图执行特权指令</li></ul></li><li>核态向用户态转换的情形<ul><li>一般是中断返回：<code>IRET</code></li></ul></li></ul></li></ul></li><li><p>内存</p><ul><li>存储器：存储程序和数据的部件</li><li>存储器分类<ul><li>按与<code>CPU</code>的联系<ul><li>主存：直接与<code>CPU</code>交换信息</li><li>辅存：不能直接和<code>CPU</code>交换信息</li></ul></li><li>按存储器（半导体存储器）读写工作方式<ul><li>RAM</li><li>ROM</li></ul></li></ul></li><li>理想体系<ul><li>理想存储体系：速度快、容量大、成本低</li><li>实际存储体系<ul><li>寄存器</li><li>高速缓存</li><li>主存</li><li>磁盘</li></ul></li></ul></li><li>分级存储系统的工作原理<ul><li><code>CPU</code>读取指令或数据时的访问顺序<ol><li>访问缓存</li><li>访问内存</li><li>访问辅存</li></ol></li><li><img src="/2022/03/09/osNote/image-20220101150413394.png" alt="image-20220101150413394"></li></ul></li></ul></li><li><p>时钟</p><ul><li>以固定时间间隔产生时钟信号，提供计算机所需的节拍</li><li>时钟的作用：<ul><li>时间片</li><li>提供绝对时间</li><li>提供预定的时间间隔</li></ul></li><li>时钟的类型<ul><li>绝对时钟</li><li>相对时钟</li></ul></li></ul></li></ul><h3 id="中断机制（重点）"><a href="#中断机制（重点）" class="headerlink" title="中断机制（重点）"></a>中断机制（<strong>重点</strong>）</h3><ul><li>中断<ul><li><p>中断定义</p><ul><li>只<code>CPU</code>对突发的外部事件的反应过程或机制</li><li><code>CPU</code>收到外部信号后，停止当前工作，转去处理该外部事件，处理完毕后回到原来工作的地方继续原来的工作</li></ul></li><li><p>引入中断的目的</p><ul><li>实现并发活动</li><li>实现实时处理</li><li>故障自动处理</li></ul></li><li><p><img src="/2022/03/09/osNote/image-20220101150816219.png" alt="image-20220101150816219"></p></li><li><p>中断的一些概念</p><ul><li><p>中断源</p><ul><li>引起系统中断的事件称为中断源</li></ul></li><li><p>中断类型</p><ul><li><p>强迫中断和自愿中断</p><ul><li>强迫中断：程序没有预期，例如：<code>IO</code>、外部中断</li><li>自愿中断：程序有预期，例如：执行访管指令</li></ul></li><li><p>外中断（中断）和内中断（俘获）</p><ul><li>外中断：由<code>CPU</code>外部事件引起，例如：<code>IO</code>、外部事件</li><li>内中断：由<code>CPU</code>内部事件引起，例如：访管指令、程序中断</li></ul></li><li><p>外中断：不可屏蔽中断和可屏蔽中断</p><ul><li>不可屏蔽中断：中断的原因很紧要，<code>CPU</code>必须响应</li><li>可屏蔽中断：中断的原因不很紧要，<code>CPU</code>可以不响应</li></ul></li></ul></li><li><p>断点</p><ul><li>程序中断的地方，将要执行的下一条指令的地址</li><li><code>CS：IP</code></li></ul></li><li><p>现场</p><ul><li>程序正确运行所依赖的信息集合</li><li><code>PSW</code>程序状态字，<code>PC</code>，相关寄存器</li></ul></li><li><p>进入中断服务程序：破坏主程序的现场</p></li><li><p>现场的两个处理过程</p><ul><li>现场的保护：进入中断服务程序之前，入栈</li><li>现场的恢复：退出中断服务程序之后，出栈</li></ul></li></ul></li><li><p>中断响应过程</p><ol><li>识别中断源</li><li>保护断点和现场</li><li>装入中断服务程序</li><li>进入中断服务程序</li><li>恢复现场和断点</li><li>中断返回：<code>IRET</code></li><li><img src="/2022/03/09/osNote/image-20220101152157861.png" alt="image-20220101152157861"></li></ol></li><li><p><img src="/2022/03/09/osNote/image-20220101152600617.png" alt="image-20220101152600617"></p></li><li><p>中断响应的实质</p><ul><li>交换指令执行地址</li><li>交换<code>CPU</code>的态</li><li>工作<ul><li>现场保护和恢复</li><li>参数传递（通信）</li></ul></li></ul></li></ul></li></ul><h1 id="第三章-用户界面"><a href="#第三章-用户界面" class="headerlink" title="第三章 用户界面"></a>第三章 用户界面</h1><h2 id="用户环境和构造"><a href="#用户环境和构造" class="headerlink" title="用户环境和构造"></a>用户环境和构造</h2><ul><li>用户环境<ul><li>用户工作的软件环境<ul><li>桌面环境</li><li>命令行环境</li></ul></li></ul></li><li>用户环境构造<ul><li>按照用户要求和硬件特性按照和配置操作系统<ul><li>提供操作命令和界面</li><li>提供系统用户手册</li></ul></li></ul></li></ul><h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><ul><li><p>相关背景知识</p><ul><li>实模式和保护模式</li><li><code>BIOS</code>(<code>Basic I/O System</code>)</li><li><code>POST</code>(<code>Power On Self Test</code>)</li><li><code>CMOS</code></li></ul></li><li><p>启动过程</p></li><li><p>操作系统的安装</p><ul><li><code>MBR</code>（主引导程序）</li><li>安装过程</li><li>多操作系统安装和启动</li></ul></li><li><p>实模式（实地址模式）</p><ul><li>程序按照8086寻址方式访问0-<code>FFFFFh</code>（<code>1MB</code>）空间</li><li>寻址方式：物理地址（20位）</li><li><code>CPU</code>单任务运行</li><li>实模式存取的<code>1M</code>空间<ul><li>前面<code>640K</code>：基本内存</li><li>中间<code>128K</code>：显卡显存</li><li>末尾<code>256K</code>：<code>BIOS</code></li></ul></li></ul></li><li><p><code>MBR</code></p><ul><li>和<code>os</code>启动相关的数据和代码</li><li>存放在主启动扇区</li><li><code>MBR</code>读取分区表，查找并确认唯一活动分区，<code>MBR</code>读取活动分区<code>PBR</code>，并加载到内存</li><li><code>PBR</code>控制后续引导进程</li></ul></li><li><p><code>BIOS</code></p><ul><li>基本输入输出系统</li><li>功能：<ul><li><code>CMOS</code>设置</li><li>基本<code>IO</code>设备中断服务</li><li><code>POST</code>上电自检</li><li>系统自举/加载<code>OS</code></li></ul></li></ul></li><li><p><code>POST</code></p><ul><li>加电自检</li><li>初始化基本硬件<ul><li><code>CPU</code>、内存、显卡</li></ul></li></ul></li><li><p>系统自举/加载<code>OS</code></p><ul><li>开机时将<code>OS</code>载入内存并运行，为用户建立用户环境</li></ul></li><li><p>操作系统的启动</p><ul><li>从加电到用户工作环境准备好的过程</li></ul><ol><li>初始引导</li><li>核心初始化</li><li>系统初始化</li></ol></li></ul><ol><li>初始引导<ul><li>目的：把<code>OS</code>内核装入内存并使之开始工作，接管计算机系统</li><li>过程：<ul><li>加电，<code>jump POST</code></li><li>跳入<code>BIOS</code>的启动程序<ul><li>读取第0面0道1扇区的内容</li><li><code>MBR</code>：主启动记录，引导程序</li></ul></li><li>运行引导程序<ul><li>根据相关参数，读取硬盘指定位置的<code>OS</code>内核到内存</li><li>初始化基本参数</li></ul></li><li><code>OS</code>内核：逐步加载<code>OS</code>剩余部分，直到最后完全控制计算机</li></ul></li></ul></li><li>核心初始化<ul><li>目的：<code>OS</code>内核初始化系统的核心数据</li></ul></li><li>系统初始化<ul><li>目的：为用户使用系统做准备，使系统处于待命状态</li></ul></li></ol><h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><ul><li><p>用户界面的定义</p><ul><li><code>OS</code>提供给用户控制计算机的机制，又称用户接口</li><li><img src="/2022/03/09/osNote/image-20220101160545346.png" alt="image-20220101160545346"></li></ul></li><li><p>用户界面的类型</p><ul><li><p>操作界面</p></li><li><p>系统调用</p></li></ul></li></ul><h3 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h3><ul><li>图形用户接口</li><li>键盘命令<ul><li>普通命令：<code>ls、cd、ps</code>等</li><li>批处理程序：普通命令的集合，批执行</li><li><code>shell</code>：操作系统和用户交互的界面<ul><li><code>shell</code>表现为通过控制台执行用户命令的方式</li><li><code>shell</code>本身不执行命令，仅仅是组织和管理命令</li></ul></li></ul></li></ul><h3 id="系统调用（重点）"><a href="#系统调用（重点）" class="headerlink" title="系统调用（重点）"></a>系统调用（<strong>重点</strong>）</h3><ul><li>系统调用<ul><li>操作系统内核为应用程序提供的一系列服务/函数</li></ul></li><li>特点<ul><li>一般涉及核心资源或硬件的操作</li><li>系统调用运行于核态</li><li>每个系统调用有唯一的编号：<code>ID</code></li><li>系统调用过程会产生中断：自愿中断</li></ul></li><li>具体<code>OS</code>中系统调用的实现<ul><li><code>DOS</code>：<code>int 21h</code></li><li><code>Linux</code>：<code>int 80h</code></li></ul></li><li>访管指令<ul><li>用于实现在用户态下运行的进程调用操作系统内核程序</li><li>执行过程<ol><li>设置模式位</li><li>转入内核某固定位置（自陷中断处理）</li><li>跳转到相应的<code>OS</code>服务例程，执行</li><li>返回用户空间</li></ol></li></ul></li></ul><h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ul><li>进程定义<ul><li>进程是程序在某个数据集合上的一次运行活动<ul><li>数据集合：软硬件环境，多个进程共存/共享的环境</li></ul></li></ul></li><li>进程的特征<ul><li>动态性：进程是程序的一次执行过程，动态产生/消亡</li><li>并发性：进程可以同其他进程一起向前推进</li><li>异步性：进程按各自的速度向前推进</li><li>独立性：进程是系统分配资源和调度<code>CPU</code>的单位</li></ul></li><li>进程和程序的区别<ul><li>动态和静态<ul><li>进程是动态的：程序的一次执行过程</li><li>程序是静态的：一组指令的有序集合</li></ul></li><li>暂存和长存<ul><li>进程是暂存的：在内存上驻留</li><li>程序是长存的：在介质上长期保存</li></ul></li><li>一个程序可能有多个进程</li></ul></li><li>进程的类型<ul><li>按使用资源的权限<ul><li>系统进程：指系统内核相关的进程</li><li>用户进程：运行于用户态的进程</li></ul></li><li>按对<code>CPU</code>的依赖性<ul><li>偏<code>CPU</code>进程：计算型进程</li><li>偏<code>IO</code>进程：侧重于<code>IO</code>的进程</li></ul></li></ul></li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li>进程的状态<ul><li>运行状态：进程已经占有<code>CPU</code>，在<code>CPU</code>上运行</li><li>就绪状态：具有运行条件但由于无<code>CPU</code>，暂时不能运行</li><li>阻塞状态：因为等待某项服务完成或信号到来而不能运行的状态，例如：系统调用，<code>IO</code>操作，合作进程的信号或服务</li><li>进程状态的变迁：<ul><li><img src="/2022/03/09/osNote/image-20220101185108807.png" alt="image-20220101185108807"></li><li><img src="/2022/03/09/osNote/image-20220101185137670.png" alt="image-20220101185137670"></li></ul></li></ul></li><li>支持挂起和解挂操作的进程状态<ul><li><img src="/2022/03/09/osNote/image-20220101185328397.png" alt="image-20220101185328397"></li></ul></li></ul><h2 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2><ul><li>进程的描述——进程控制块<ul><li>描述进程的状态、资源、和相关进程的关系的一种数据结构</li><li><code>PCB</code>是进程的标志</li><li>创建进程时创建<code>PCB</code>，进程撤销后<code>PCB</code>同时撤销</li></ul></li><li>和进程标识相关的成员变量<ul><li><code>PID</code>：进程ID</li><li><code>PPID</code>：父进程ID</li><li><code>PGID</code>：进程组ID</li></ul></li></ul><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><ul><li>线程的概念<ul><li>线程是进程内的一个执行路径</li><li>一个进程可以包含多个线程</li><li>线程之间共享<code>CPU</code>可以实现并发运行</li><li>创建线程比创建进程开销要小</li><li>线程间通信十分方便</li></ul></li><li>适用场景<ul><li>程序的多个功能需要并发运行</li><li>提高窗口的交互性</li><li>改善程序的结构</li><li>多核<code>CPU</code>上的应用，充分发挥多核性能</li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><ul><li><p>进程控制的概念</p><ul><li>在进程的生存全期间，对其全部行为的控制</li><li>四个典型的进程控制<ul><li>创建进程：创建一个具有指定标识ID的进程<ul><li>参数：进程标识、优先级、进程起始地址、<code>CPU</code>初始状态、资源清单等</li></ul></li><li>撤销进程：撤销一个指定的进程<ul><li>收回进程所占有的资源，撤销该进程的<code>PCB</code></li><li>撤销的时机：正常结束、异常结束、外界干预</li><li>参数：被撤销的进程名ID</li></ul></li><li>阻塞进程：停止进程执行，变为阻塞<ul><li>阻塞的时机：请求系统服务、启动某种操作、新数据未到、无新工作</li><li>参数：阻塞原因，不同原因有不同的阻塞队列</li></ul></li><li>唤醒进程：唤醒处于阻塞队列中的某个进程<ul><li>唤醒的时机：系统服务满足，<code>IO</code>完成、新数据到达、进程提出新要求</li><li>参数：被唤醒进程的标识</li></ul></li></ul></li></ul></li><li><p>创建进程的过程</p><ul><li>创建一个空白的<code>PCB</code></li><li>赋予进程标识符ID</li><li>为进程分配空间</li><li>初始化<code>PCB</code>：默认值</li><li>插入相应的进程队列：新进程插入就绪队列</li></ul></li><li><p>进程撤销的实现</p><ul><li>在<code>PCB</code>队列中检索出该<code>PCB</code></li><li>获取该进程的状态</li><li>若该进程处在运行态，立即终止该进程<ul><li>（递归）先撤销子进程</li><li>子进程挂到<code>init</code>进程下</li></ul></li><li>释放进程占有的资源</li><li>将进程从<code>PCB</code>队列中移除</li></ul></li><li><p>进程阻塞的实现</p><ul><li>停止运行</li><li>将<code>PCB</code>运行态改为阻塞态</li><li>插入对应的阻塞队列</li><li>转调度程序</li></ul></li><li><p>原语</p><ul><li>由若干指令构成的具有特定功能的函数</li><li>具有原子性，其操作不可分割</li><li>创建原语、撤销原语、阻塞原语、唤醒原语</li></ul></li><li><p><code>windows</code>进程控制</p><ul><li><code>CreateProcess</code>函数</li></ul></li><li><p><code>Linux</code>进程控制——<code>fork</code></p><ul><li><code>fork</code>创建进程<ul><li>子进程是父进程的复制</li><li>父进程和子进程并发运行（在<code>fork</code>函数之后）</li><li><code>fork</code>的返回值：子进程返回<code>0</code>，父进程返回子进程<code>ID</code>，出错返回<code>-1</code></li></ul></li><li>进程执行特定的功能<ul><li><code>exec</code>函数族，功能：装入一个指定的可执行程序运行，使子进程具有和父进程完全不同的新功能</li></ul></li><li><code>fork</code>常规用法<ul><li><img src="/2022/03/09/osNote/image-20220101192451127.png" alt="image-20220101192451127"></li></ul></li></ul></li><li><p><code>linux</code>进程控制——<code>wait(int &amp;status)</code></p><ul><li>进程调用<code>wait</code>来阻塞自己<ul><li>检测子进程是否结束<ul><li>未结束：等待子进程结束，继续阻塞</li><li>已结束：<code>wait</code>收集该子进程信息并彻底销毁它后返回</li></ul></li><li><code>Status</code>接收子进程退出时的退出代码<ul><li>若忽略子进程的退出信息：<code>wait(NULL)</code></li></ul></li></ul></li></ul></li><li><p><code>linux</code>进程控制——<code>exit(int status)</code></p><ul><li>调用<code>exit</code>终结进程</li><li>进程终结时要释放资源并向父进程报告<ul><li>利用<code>status</code>向父进程传递退出代码</li><li>变为僵尸进程，保留部分<code>PCB</code>信息供<code>wait</code>收集</li><li>调用<code>schedule</code>函数，选择新进程运行</li></ul></li></ul></li><li><p><code>Linux</code>进程控制——<code>sleep(int nSecond)</code></p><ul><li>进程暂停执行<code>nSecond</code>秒</li></ul></li></ul><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>进程的互斥关系<ul><li>多个进程由于共享具有独占性的资源，必须协调各进程对资源的存取顺序：确保没有任何两个或以上的进程同时进行资源的存取</li><li>临界资源：一次只允许一个进程独占访问的资源，例如：共享变量<code>i</code></li><li>临界区：进程中访问临界资源的程序段</li><li>临界资源和临界区的共享特点<ul><li>临界资源的访问具有排他性</li><li>并发进程不能同时进入“临界区”</li></ul></li><li>访问临界区的方法<ul><li>锁机制</li><li>信号量</li></ul></li></ul></li><li>进程的同步关系<ul><li>若干合作进程为了共同完成一个任务，需要相互协调运行步伐，一个进程A开始某个操作之前要求另一个进程B必须已经完成另一个操作，否则进程A只能等待</li><li>互斥关系属于特殊的同步关系</li></ul></li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><ul><li>锁机制<ul><li>基本原理<ul><li>设置一个标识<code>S</code>：表明临界资源是否可用</li><li>在进入临界区之前先检查标志是否可用</li><li>进入临界区后，将标志修改为不可用——上锁</li><li>退出临界区，将标志修改为可用——解锁</li></ul></li><li>上锁原语和解锁原语</li></ul></li><li>设置临界区的四个原则<ul><li>忙则等待</li><li>空闲让进</li><li>有限等待</li><li>让权等待：等待进程放弃<code>CPU</code>（锁机制不满足）</li></ul></li></ul><h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和<code>PV</code>操作</h2><ul><li><p>信号灯机制</p><ul><li><p>信号灯数据结构</p><ul><li>信号灯定义为一个二元矢量(S, q)</li><li><code>S</code>信号量：整数，初值非负</li><li><code>q</code>队列：进程<code>PCB</code>集合</li></ul></li><li><p>两个操作</p><ul><li><code>P、V</code>操作</li></ul></li><li><p><code>P</code>操作</p><ul><li><img src="/2022/03/09/osNote/image-20220101201058298.png" alt="image-20220101201058298"></li></ul></li><li><p><code>V</code>操作</p><ul><li><img src="/2022/03/09/osNote/image-20220101201126834.png" alt="image-20220101201126834"></li></ul></li><li><p>信号灯与<code>PV</code>操作的应用</p><ul><li><p>实现进程互斥</p><ul><li><p>实质是实现对临界区的互斥访问</p><p>1个临界资源：允许最多一个进程处于临界区</p><p>M个临界资源：允许最多<code>M</code>个程序同时处于临界区</p></li><li><p>应用过程</p><p>进入临界区之前先执行<code>P</code>操作</p><p>离开临界区之后再执行<code>V</code>操作</p><p><code>S</code>的初值设置要合理（S初值为临界资源的数量）</p></li><li><p>例子：<img src="/2022/03/09/osNote/image-20220101201527187.png" alt="image-20220101201527187"></p></li></ul></li><li><p>实现进程的同步</p><ul><li><p>同步机制实质</p><p>运行条件不满足时，能让进程暂停</p><p>运行条件满足时，能让进程立即继续</p></li><li><p><code>PV</code>操作应用于进程同步的基本思路</p><p>暂停当前进程：在关键操作之前执行<code>P</code>操作</p><p>继续进程：在关键操作之后执行<code>V</code>操作</p><p>定义有意义的信号量<code>S</code>，并设置合适的初值（不合理的初值会引发死锁）</p></li></ul></li></ul></li></ul></li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ul><li>生产者、消费者问题</li><li>读者、编者问题</li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>进程通信方式<ul><li>低级通信原语<ul><li>交换信息量较少</li></ul></li><li>高级通信原语<ul><li>交换信息较多</li></ul></li></ul></li><li><code>linux</code>软中断通信机制<ul><li><code>kill(pid,sig)</code>：传递软中断信号</li><li><code>signal(sig,func)</code>：注册软中断信号</li><li><code>wait()</code>：用于父子进程间的同步</li><li><code>sleep()</code>：使当前进程睡眠</li></ul></li><li>管道通信<ul><li>父进程创建管道<code>fd[0]</code>读句柄、<code>fd[1]</code>写句柄</li><li>父进程<code>fork</code>、<code>createprocess</code>创建子进程</li><li>单向通信（双向通信创建两个管道）</li><li>特点<ul><li>只允许有血缘关系的进程间通信</li><li>面向字节流</li><li>跟随进程</li></ul></li></ul></li></ul><h1 id="第五章-资源分配与调度"><a href="#第五章-资源分配与调度" class="headerlink" title="第五章 资源分配与调度"></a>第五章 资源分配与调度</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><ul><li>死锁的定义<ul><li>两个或多个进程无限期地等待永远不会发生的条件的一种系统状态</li></ul></li></ul><h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><ul><li>死锁的原因<ul><li>系统资源有限<ul><li>资源数目不足以满足所有进程的需要，引起进程对资源的竞争而产生死锁</li></ul></li><li>并发进程的推进顺序不当<ul><li>进程在运行过程中，请求和释放资源的顺序不当，导致进程产生死锁</li></ul></li></ul></li><li>关于死锁的一些结论<ul><li>陷入死锁的进程至少是2个</li><li>参与死锁的进程至少有两个已经占用资源</li><li>参与死锁的所有进程都在等待资源</li><li>参与死锁的进程是当前系统中所有进程的子集</li><li>死锁会浪费大量的系统资源，甚至导致系统崩溃</li></ul></li><li>死锁的必要条件<ul><li>互斥条件<ul><li>资源具有独占性，进程互斥的使用资源</li></ul></li><li>不剥夺条件<ul><li>进程在释放资源前不能被其他程序剥夺</li></ul></li><li>部分分配条件<ul><li>进程所需要的资源逐步分配，需要时申请和分配</li></ul></li><li>环路条件<ul><li>多个进程构成环路：环中每个进程已经占用的资源被前一进程申请，而自己所需要的新资源又被环中后一进程所占用</li></ul></li></ul></li></ul><h2 id="解决死锁问题的策略"><a href="#解决死锁问题的策略" class="headerlink" title="解决死锁问题的策略"></a>解决死锁问题的策略</h2><ul><li>预防死锁<ul><li>通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁<ul><li>破坏互斥条件——难</li><li>破坏不剥夺条件——代价大</li><li>破坏部分分配条件——预先静态分配</li><li>破坏环路条件——有序资源分配</li></ul></li><li>由于限制太严格，导致资源利用率和吞吐率降低</li></ul></li><li>避免死锁——银行家算法</li><li>检测和恢复死锁<ul><li>允许死锁发生，但可通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统从已发生的死锁中清除，将程序从死锁状态解脱出来</li></ul></li></ul><h1 id="第六章-处理机调度（进程调度）"><a href="#第六章-处理机调度（进程调度）" class="headerlink" title="第六章 处理机调度（进程调度）"></a>第六章 处理机调度（进程调度）</h1><h2 id="进程调度概念"><a href="#进程调度概念" class="headerlink" title="进程调度概念"></a>进程调度概念</h2><ul><li>调度定义<ul><li>在一个队列中，按某种策略选择一个最合适的个体</li></ul></li><li>调度分类<ul><li>长程调度/宏观调度/作业调度</li><li>中程调度/交换调度</li><li>短程调度/进程调度</li><li><code>IO</code>调度/设备调度</li><li><img src="/2022/03/09/osNote/image-20220101213941318.png" alt="image-20220101213941318"></li></ul></li><li>进程调度的目标<ul><li>响应速度尽可能快</li><li>进程处理时间尽可能短</li><li>系统吞吐量尽可能大</li><li>资源利用率尽可能高</li><li>对所有进程要公平</li><li>避免饥饿</li><li>避免死锁</li></ul></li><li>进程调度的量化指标<ul><li>周转时间/平均周转时间</li><li>带权周转时间/平均带权周转时间</li></ul></li><li>周转时间<ul><li>进程提交给计算机到完成所花费的时间<code>t = tc - ts</code><ul><li><code>ts</code>——进程的提交时间</li><li><code>tc</code>——进程的完成时间</li></ul></li><li>意义：说明进程在系统中停留的时间长短</li></ul></li><li>平均周转时间<ul><li><code>t = (t1 + t2 + ...... +tn)/n</code></li><li>平均周转时间越短，意味着这些进程在系统中停留的时间越短，因而系统吞吐量也越大，资源利用率越高</li></ul></li><li>带权周转时间<ul><li><code>w = t/tr</code><ul><li><code>t</code>——进程的周转时间</li><li><code>tr</code>——进程的运行时间</li></ul></li><li>意义：进程在系统中的相对停留时间</li></ul></li><li>平均带权周转时间<ul><li><code>w = (w1 + w2 + ...... +wn)/n</code></li></ul></li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>先来先服务调度<ul><li>晚来但是很短的作业可能需要等待很长时间，不利于短作业</li></ul></li><li>短作业优先调度<ul><li>忽视了等待时间，一个早来但是很长的作业将会得不到调度</li></ul></li><li>响应比高者优先调度<ul><li>响应比 = 加权周转时间</li></ul></li><li>优先数调度<ul><li>优先数 = 静态优先数 + 动态优先数</li><li>静态优先数：在进程创建时确定，在整个进程运行期间不再改变</li><li>动态优先数：动态优先数在进程期间可以改变</li></ul></li><li>循环轮转调度<ul><li>把所有就绪进程按先进先出的原则排成队列，进程以时间片为单位轮流使用<code>CPU</code><ul><li>时间片太大则会退化成先来先服务算法</li><li>时间片太小则会引起进程切换频繁，系统开销增大</li></ul></li></ul></li><li>可变时间片轮转调度</li><li>多重时间片循环调度</li><li>调度方式<ul><li>定义<ul><li>当一进程正在<code>CPU</code>上运行时，若有更高优先级的进程需要运行，系统如何分配<code>CPU</code></li></ul></li><li>非剥夺方式<ul><li>让正在运行的进程继续执行，直到该进程完成或发生某事件而进入完成或阻塞的状态，才把<code>CPU</code>分配给新来的更高优先级的进程</li></ul></li><li>剥夺方式<ul><li>当更高优先级的进程来到时，便暂停正在运行的进程，立即把<code>CPU</code>分配给新来的优先级更高的进程</li></ul></li></ul></li></ul><h2 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h2><ul><li>基本特点<ul><li>基于优先级调度</li><li>支持普通进程，也支持实时进程</li><li>实时进程优先于普通进程</li><li>普通进程公平使用<code>CPU</code>时间</li></ul></li></ul><h1 id="第七章-主存管理"><a href="#第七章-主存管理" class="headerlink" title="第七章 主存管理"></a>第七章 主存管理</h1><h2 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h2><ul><li>实际存储体系<ul><li>三级存储体系</li><li><code>Cache</code>+内存+辅存</li><li>基本原理<ul><li>当内存太小不够时，用辅存来支援内存</li><li>暂时不运行的模块换出到辅存上，必要时再换入内存</li></ul></li></ul></li><li>存储管理的功能<ol><li>地址映射</li><li>虚拟存储（存储扩充）</li><li>内存分配</li><li>存储保护</li></ol></li><li>地址映射<ul><li>定义<ul><li>把程序中的地址（虚拟地址/虚地址/逻辑地址）变换为真实的内存地址（实地址/物理地址）的过程</li></ul></li><li>方式<ul><li>固定地址映射</li><li>静态地址映射</li><li>动态地址映射</li></ul></li><li>固态地址映射<ul><li>定义：编程或编译时确定逻辑地址和物理地址间的映射关系</li><li>特点<ul><li>程序加载时必须放到指定的内存区域</li><li>容易产生地址冲突，运行失败</li><li>不能适应多道环境</li></ul></li></ul></li><li>静态地址映射<ul><li>定义：程序装入时由操作系统完成逻辑地址到物理地址的映射<ul><li>保证在运行之前将所有地址都绑定到主存</li></ul></li><li><code>MA = BA + VA</code><ul><li><code>MA</code>——物理地址</li><li><code>BA</code>——装入基址，基址寄存器</li><li><code>VA</code>——逻辑地址</li></ul></li><li>特点<ul><li>程序运行之前确定映射关系</li><li>程序装入后不能移动</li><li>程序占用连续的内存空间</li></ul></li></ul></li><li>动态地址映射<ul><li>定义：在程序执行过程中把逻辑地址转换为物理地址<ul><li>例如：<code>MOV AX, [500]</code>，访问500单元时执行地址转换</li></ul></li><li><code>MA = BA + VA</code><ul><li><code>MA</code>——物理地址</li><li><code>BA</code>——装入基址，基址寄存器</li><li><code>VA</code>——逻辑地址</li></ul></li><li>特点<ul><li>程序占用的内存空间可动态变化<ul><li>若程序移动及时更新基址<code>BA</code></li></ul></li><li>程序不要求占用连续的内存空间<ul><li>需要记录每段放置的基址<code>BA</code></li></ul></li><li>便于多个进程共享代码<ul><li>共享代码作为独立的一段存放</li></ul></li></ul></li></ul></li></ul></li><li>虚拟存储（存储扩充）<ul><li>解决的问题<ul><li>程序过大或过多时，内存不够，不能运行</li><li>多个程序并发时地址冲突，不能运行</li></ul></li><li>虚拟存储的基本原理<ul><li>借助辅存在逻辑上扩充主存，解决内存不足</li><li>过程<ul><li>迁入：将要运行的部分装入内存，把辅存存放的部分临时按需调入内存</li><li>迁出：把当前不运行的部分暂时存放在辅存，尽量腾出足够的内存供进程正常运行</li></ul></li><li>前提：短时间内进程不运行的部分往往占大部分</li><li>用户体验了足够大的线性内存——虚拟内存</li></ul></li><li>程序局部性原理<ul><li>时间局部性<ul><li>一条指令或数据，会在较短的时间内被重复访问</li><li>例如：循环语句</li></ul></li><li>空间局部性<ul><li>任一内存单元及其临近单元会在短时间内被集中访问</li><li>短时间内，<code>CPU</code>对内存的访问往往会集中在一个较小区域内</li><li>例如：表，数组的操作</li></ul></li><li>结论<ul><li>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内，因此，一般情况下，把程序的一部分装入内存在较大概率上也足够让其运行一段时间</li></ul></li></ul></li><li>实现虚拟存储的前提<ul><li>足够的辅存</li><li>适量容量的内存</li><li>地址变换结构</li></ul></li><li>虚拟存储的应用<ul><li>页式虚拟存储</li><li>段式虚拟存储</li></ul></li></ul></li><li>内存分配<ul><li>为程序运行分配足够的内存空间</li><li>需要解决的问题<ul><li>放置策略<ul><li>程序调入内存时将其放在哪个位置</li><li>全部分配或部分分配</li></ul></li><li>调入策略<ul><li>何时把要运行的代码或访问的数据调入内存</li></ul></li><li>淘汰策略<ul><li>迁出哪些代码和数据以腾出内存空间</li></ul></li></ul></li></ul></li><li>存储保护<ul><li>保证内存中的多道程序只能在给定的存储区域活动并互不干扰</li><li>保护方法<ul><li>界址寄存器<ul><li>在<code>CPU</code>中设置一对下限寄存器和上限寄存器，存放程序在内存中的下限地址和上限地址</li><li>基址寄存器和限长寄存器</li><li>适用于连续物理分区中的情形</li></ul></li><li>存储键保护<ul><li>适用于不连续物理分块的情形，也可用于共享中的权限</li></ul></li></ul></li></ul></li></ul><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><ul><li>物理内存管理方法<ul><li>单一区存储管理（不分区存储管理）</li><li>分区存储管理</li><li>内存覆盖技术</li><li>内存交换技术</li></ul></li><li>单一区存储管理<ul><li>内存的用户区不分区，完全被一个程序所占用</li></ul></li></ul><h3 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h3><ul><li><p>定义：把用户区内存划分成若干大小不等的分区，供不同程序使用</p></li><li><p>分类</p><ul><li>固定分区</li><li>动态分区</li></ul></li><li><p>固定分区</p><ul><li>把内存固定的划分为若干个大小不等的分区供各个程序使用，每个分区的大小和位置都固定，系统运行期间不再重新划分</li><li>分区表：记录分区的位置、大小和使用标志</li><li>例子：<img src="/2022/03/09/osNote/image-20220102091501217.png" alt="image-20220102091501217"></li><li>使用特点<ul><li>在程序装入之前，内存已被分区，不再改变</li><li>每个分区大小不同，适应于不同大小的程序</li><li>系统需要维护分区表</li></ul></li><li>固定分区缺点<ul><li>浪费内存：程序比所在分区小</li><li>大的程序可能无法运行：程序比最大分区大，无法装入</li></ul></li><li>应用建议<ul><li>程序大小、个数、装入顺序都是固定的情形</li><li>根据分区表安排程序装入顺序</li></ul></li></ul></li><li><p>动态分区</p><ul><li><p>在程序装入时创建分区，使分区的大小刚好与程序的大小相等</p></li><li><p>例子：<img src="/2022/03/09/osNote/image-20220102091843105.png" alt="image-20220102091843105"></p><p><img src="/2022/03/09/osNote/image-20220102091931479.png" alt="image-20220102091931479"></p></li><li><p>特点</p><ul><li>分区动态建立</li><li>分区的个数和大小均可变</li><li>存在内存碎片</li></ul></li><li><p>动态分区需要解决的问题</p><ul><li>分区的选择</li><li>分区的分配</li><li>分区的回收</li><li>解决内存的碎片问题</li></ul></li><li><p>分区的选择（放置策略）</p><ul><li><p>程序装入空闲区时，尽量往高地址靠拢</p></li><li><p>空闲区表：描述内存空闲区的位置和大小的数据结构</p></li><li><p>分区选择：</p><ul><li>从空闲区表中选择一个空闲区给用户使用</li><li>选择策略/放置策略</li></ul></li><li><p>放置策略</p><ul><li>从排序好的空闲区表中选择第一个大小够大的分区</li><li>选择分区与空闲区表排序方式有关</li></ul></li><li><p>空闲区表的排序原则</p><ul><li>首次适应算法：按空闲区位置递增排序<ul><li>尽可能先利用低地址空间</li></ul></li><li>最佳适应法：按空闲区大小递增排序<ul><li>尽量选择满足要求的最小空闲区</li></ul></li><li>最坏适应法：按空闲区大小递减排序<ul><li>尽量使用最大的空闲区</li><li>仅作一次查找就可以找到所要分区</li></ul></li></ul></li></ul></li><li><p>分区的分配</p><ul><li>从用户选中的分区中分配/分割所需大小给用户</li><li>剩余部分依然作为空闲区登记在空闲区表中</li><li>注意：分割空闲区时，一般把底部分割给用户（因此，空闲区表只需修改大小即可）</li></ul></li><li><p>分区的回收</p><ul><li>回收程序占用的分区（释放区），将其适当处理后登记到空闲区表中，以便再分配</li><li>若释放区与现有空闲区相邻则合并</li></ul></li><li><p>碎片问题</p><ul><li>动态分区的缺点<ul><li>容易产生内存碎片：内存反复分配和分割</li><li>首次适应法，最佳适应法，最坏适应法</li></ul></li><li>解决碎片的方法<ul><li>规定门限值：分割空闲区时，若剩余部分小于门限值，则此空闲区不进行分割，而是全部分配给用户</li><li>内存拼接技术：将所有空闲区集中一起构成一个大的空闲区</li><li>把程序分拆成几个部分装入不同分区，充分利用碎片</li></ul></li></ul></li></ul></li></ul><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul><li>目的：在较小的内存空间中运行较大的程序</li><li>内存分区<ul><li>常驻区：被某段单独使用且固定的占用的分区，可划分多个</li><li>覆盖区：能被多段共用（覆盖）的区域，可划分多个</li></ul></li><li>工作原理<ul><li>程序划分成若干代码段或数据段</li><li>将程序常用的段装入常驻区</li><li>将程序不常用的段装入覆盖区<ul><li>正在运行的段处于覆盖区</li><li>暂时不运行的段放在硬盘中（覆盖文件）</li><li>即将运行的段装入覆盖区（覆盖旧内容）</li></ul></li><li>意义：减少程序对内存的需求</li><li>例子：<img src="/2022/03/09/osNote/image-20220102094233950.png" alt="image-20220102094233950"></li></ul></li></ul><h3 id="对换技术"><a href="#对换技术" class="headerlink" title="对换技术"></a>对换技术</h3><ul><li>原理<ul><li>当内存不够时把进程写到磁盘，当进程要运行时重新写回内存</li></ul></li><li>优点<ul><li>增加进程并发数</li><li>不考虑程序结构</li></ul></li><li>缺点<ul><li>换入和换出增加<code>CPU</code>开销</li><li>对换单位太大</li></ul></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><ul><li>物理内存（即实内存）管理<ul><li><img src="/2022/03/09/osNote/image-20220102094616055.png" alt="image-20220102094616055"></li></ul></li><li>改善物理内存管理的相关技术<ul><li>内存拼接</li><li>对换技术</li><li>覆盖技术</li></ul></li><li>虚拟内存的概念<ul><li>虚拟内存是面向用户的虚拟封闭存储空间</li><li>线性地址空间</li><li>容量<code>4G</code></li><li>封闭空间（进程空间）</li><li>和物理地址分离（地址无冲突）</li><li>程序员编程时使用线性虚拟地址</li></ul></li><li>虚拟内存管理<ul><li>目标<ul><li>使得大的程序能在较小的内存中运行</li><li>使得多个程序能在较小的内存中运行</li><li>使得多个程序并发运行时地址不冲突</li><li>使得内存利用效率高</li></ul></li><li>虚拟内存管理的实现思路<ul><li>把程序一小部分装入内存在较大概率上也足够让其运行一小段时间</li><li>程序的局部性<ul><li>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内</li></ul></li></ul></li><li>典型虚拟内存管理方式<ul><li>页式虚拟内存管理</li><li>段式虚拟内存管理</li><li>段页式虚拟内存管理</li></ul></li></ul></li></ul><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><ul><li>页式虚拟内存管理<ul><li>概念<ul><li>把进程空间（虚拟）和内存空间都划分成等大小的小片<ul><li>进程的小片——页</li><li>内存的小片——页框</li><li>小片的典型大小：<code>1K、2K、4K</code></li></ul></li></ul></li><li>程序装入和使用内存的原则<ul><li>内存以页框为单位分配使用</li><li>进程以页为单位装入内存<ul><li>只把程序部分页装入内存便可运行</li><li>页在内存中占用的页框不必相邻</li><li>需要新页时，按需从硬盘调入内存</li><li>不在运行的页及时删除，腾出空间</li></ul></li></ul></li><li>页式系统中的地址<ul><li>虚拟地址<code>VA</code>是线性的，从0开始</li><li><code>VA</code>分成页号<code>P</code>和页内偏移<code>W</code><ul><li>所处页编号<code>P = VA/页大小</code></li><li>所处页偏移<code>W = VA%页大小</code></li></ul></li></ul></li><li>地址映射过程<ul><li>页面映射表：记录页与页框之间的对应关系，也叫页表</li><li>例子：<img src="/2022/03/09/osNote/image-20220102100141218.png" alt="image-20220102100141218"></li><li>过程：<ol><li>从<code>VA</code>中分离页号<code>P</code>和页内偏移<code>W</code></li><li>查找页表，以<code>P</code>为索引查找页框号<code>P'</code></li><li>计算物理地址<code>MA = P' * 页大小 + W</code></li></ol></li><li>快表：页表部分存放在<code>Cache</code>中称为快表<ul><li>地址映射时优先访问快表</li><li>合理的页面调度策略能使快表具有较高的命中率</li></ul></li><li>页面的共享<ul><li>在页表中填上共享的页框号，从而实现页面共享</li><li>共享页面在内存中只有一份真实存储，节省内存</li></ul></li></ul></li><li>页表的建立<ul><li>操作系统为每个进程创建一个页表<ul><li>页表长度和首地址存放在进程控制块中</li></ul></li><li>当前运行进程的页表驻留在内存<ul><li>页表长度和首地址由页表长度寄存器和页表首址寄存器指示</li></ul></li></ul></li><li>页表扩充<ul><li>扩充有中断位<code>I</code>和辅存地址的页表</li><li>中断位<code>I</code>——标识该页是否在内存中，为<code>1</code>标识不在内存，为<code>0</code>标识在内存</li><li>辅存地址——该页在辅存上的位置</li><li>扩充有访问位（引用位）和修改位的页表</li><li>访问位——标识该页是否最近被访问</li><li>修改位——标识该页的数据是否已被修改</li></ul></li><li>缺页中断<ul><li>在地址映射的过程中，当要访问的目的页不在内存时，则系统产生异常中断——缺页中断</li><li>缺页中断处理程序<ul><li>中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位<code>I</code>为0</li><li><img src="/2022/03/09/osNote/image-20220102102025891.png" alt="image-20220102102025891"></li></ul></li><li>缺页率：<code>f = 缺页次数/访问页面总次数</code></li><li>缺页中断和普通中断<ul><li>相同点：保护现场、中断处理、恢复现场</li><li>不同点：响应时机：普通中断在指令完成后响应，缺页中断在指令执行时响应</li></ul></li></ul></li><li>二级页表<ul><li>页表实现时的问题<ul><li>页表全部装入过度消耗内存（<code>4M</code>）</li><li>难以找到连续的<code>1k</code>个页框存放页表</li></ul></li><li>解决办法<ul><li>仅将页表的部分内容调入内存</li><li>将<code>4M</code>的超大页表分拆存储到离散的<code>1k</code>个页框中</li></ul></li><li><img src="/2022/03/09/osNote/image-20220102102800509.png" alt="image-20220102102800509"></li><li><img src="/2022/03/09/osNote/image-20220102102814871.png" alt="image-20220102102814871"></li><li><img src="/2022/03/09/osNote/image-20220102102824123.png" alt="image-20220102102824123"></li></ul></li><li>淘汰策略<ul><li>选择淘汰哪一页的规则称为淘汰策略</li><li>页面抖动：页面在内存和辅存之间频繁交换的现象</li><li>好的淘汰策略<ul><li>较低的缺页率</li><li>页面抖动较少</li></ul></li><li>常用的淘汰算法<ul><li>最佳算法</li><li>先进先出算法</li><li>最久未使用算法</li><li>最不经常使用算法</li></ul></li></ul></li><li>最佳算法<ul><li>淘汰不再需要或最远的将来才会使用的页面</li></ul></li><li>先进先出淘汰算法<ul><li>淘汰在内存中停留时间最长的页面</li></ul></li><li>最久未使用淘汰算法<ul><li>淘汰最长时间未使用的页面</li></ul></li><li>最不经常使用淘汰算法<ul><li>选择到当前时间为止被访问次数最少的页面</li><li>每页设置访问计数器，每当页面被访问时，该页面的访问计数器加一</li><li>发生缺页中断时，淘汰计数值最小的页面，并将<strong>所有计数</strong>清零</li></ul></li><li>页面大小选择<ul><li>页面过大：浪费内存，极限是分区存储</li><li>页面过小：页面增多，页表长度增加，浪费内存，换页频繁，系统效率低</li></ul></li><li>影响缺页次数的因素<ul><li>淘汰算法</li><li>分配给进程的页框数</li><li>页本身的大小：页面越小越容易缺页</li><li>程序的编制方法<ul><li>局部性越好，越不容易缺页</li><li>跳转或分支越多越容易缺页</li></ul></li></ul></li><li>页式系统的不足<ul><li>页面划分无逻辑含义</li><li>页的共享不灵活</li><li>页内碎片</li></ul></li></ul></li></ul><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><ul><li>进程分段<ul><li>把进程按逻辑意义划分成多个段，每段有段名，长度不定，进程由多段组成</li><li>例如：一个具有代码段、数据段、堆栈段的进程</li></ul></li><li>段式内存管理系统的内存分配<ul><li>以段为单位装入，每段分配相邻的内存</li><li>但是段与段之间不要求相邻</li></ul></li><li>段式系统的虚拟地址<ul><li>段式虚拟地址<code>VA</code>包含段号<code>S</code>和段内偏移<code>W</code></li></ul></li><li>段表<ul><li>记录每段在内存中映射的位置</li><li>段号|段长|基地址</li><li>段表的字段<ul><li>段号<code>S</code>——段的唯一编号</li><li>段长<code>L</code>——该段的长度</li><li>基地址<code>B</code>——该段在内存中的首地址</li></ul></li></ul></li><li>段式地址的映射机制<ul><li>过程<ol><li>由逻辑地址<code>VA</code>分离出(<code>S</code>,<code>W</code>)</li><li>查询段表：检索段号<code>S</code>，查询该段基地址<code>B</code>和长度<code>L</code></li><li>物理地址<code>MA = B + W</code></li></ol></li></ul></li><li>段表的扩充<ul><li>基本字段：段号，长度，基址</li><li>扩展字段：中断位，访问位，修改位，<code>R/W/X</code></li></ul></li><li>段的共享<ul><li>共享段在内存中只有一份存储</li><li>共享段被进程映射到自己的空间（写入段表）</li><li>所有共享的模块都可以设置为单独的段</li></ul></li><li>段式系统的缺点<ul><li>段需要连续的存储空间</li><li>段的最大尺寸收到内存大小的限制</li><li>在辅存中管理可变尺寸的段比较困难</li></ul></li><li>段式系统与页式系统<ul><li>地址空间的区别<ul><li>页式系统：一位地址空间</li><li>段式系统：二维地址空间</li></ul></li><li>段与页的区别<ul><li>段长可变——页面固定大小</li><li>段的划分有意义——页面划分无意义</li><li>段方便共享——页面不方便共享</li><li>段用户可见——页面用户不可见</li><li>段偏移有溢出——页偏移无溢出</li><li>段式系统不会产生碎片问题——页式系统会产生碎片</li></ul></li></ul></li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><ul><li>在段式存储管理中结合页式存储管理技术</li><li>在段中划分页面</li><li>段页式系统的地址构成：段号|页号|页内偏移<ul><li>逻辑地址：段号<code>S</code>，页号<code>P</code>，页内偏移<code>W</code></li><li>内存按页划分，按页装入</li></ul></li><li>段页式地址的映射结构<ul><li>同时采用段表和页表实现地址映射<ul><li>系统为每个进程建立一个段表</li><li>系统为每个段建立一个页表</li><li>段表给出每段的页表基地址和页表长度（段长）</li><li>页表给出每页对应的框</li></ul></li><li><img src="/2022/03/09/osNote/image-20220102110251274.png" alt="image-20220102110251274"></li></ul></li></ul><h2 id="Linux存储管理"><a href="#Linux存储管理" class="headerlink" title="Linux存储管理"></a>Linux存储管理</h2><ul><li><code>/proc</code>文件系统<ul><li>特点<ul><li>内存文件系统</li><li>为用户访问内核信息提供接口<ul><li>例：<code>CPU</code>信息</li><li>例：内核信息（进程信息）</li></ul></li></ul></li></ul></li></ul><h1 id="第八章-设备管理（输入-x2F-输出管理）"><a href="#第八章-设备管理（输入-x2F-输出管理）" class="headerlink" title="第八章 设备管理（输入/输出管理）"></a>第八章 设备管理（输入/输出管理）</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><ul><li>设备管理功能<ul><li>状态跟踪<ul><li>生成设备管理器的数据结构，动态的记录各种设备的状态</li></ul></li><li>设备分配<ul><li>设备分配功能是设备管理的基本任务</li></ul></li><li>设备映射<ul><li>设备的两种名字：设备逻辑名、设备物理名</li><li>从应用软件的角度看，逻辑设备是一类物理设备的抽象</li><li>从设备管理程序的角度看，物理设备是逻辑设备的实例</li><li>设备独立性<ul><li>逻辑设备对用户透明</li><li>用户使用统一规范的方式使用设备</li></ul></li></ul></li><li>设备控制和设备驱动<ul><li>对物理设备进行控制，实现<code>IO</code>操作</li><li>把来自应用的服务请求（例如：读写命令）转换为一系列<code>IO</code>指令，控制设备完成相关操作</li><li>向用户提供统一的设备使用接口：<code>read、write</code></li><li>设备驱动程序的特点<ul><li>设备驱动程序与硬件密切相关</li><li>每类设备都要配置特定的驱动程序</li></ul></li></ul></li><li>缓冲区管理<ul><li>组织<code>IO</code>缓冲区</li></ul></li></ul></li></ul><h2 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h2><ul><li>缓冲作用<ol><li>连接有着不同数据传输速度的设备</li><li>协调数据记录大小的不一致</li><li>正确执行应用程序的语义拷贝<ul><li><code>write(Data,Len)</code>向磁盘写入<code>Data</code></li><li>方法：<ul><li>内核写完再返回（实时性差）</li><li>内核设置缓冲区，完成内核复制即返回，之后由内核把缓冲区写到磁盘（实时性好）</li></ul></li></ul></li></ol></li><li>提前读和延后写<ul><li>存储设备</li><li>提高数据传输效率</li><li>减少进程访问目标设备的次数</li></ul></li><li>提前读<ul><li>进程处理一个输入数据时，直接从<code>IO</code>缓冲区读入，正确的数据已被提前读入到<code>IO</code>缓冲区中<ul><li>结论：内核提前从输入设备把数据读到<code>IO</code>缓冲区中</li><li>但不一定是正确数据</li><li>注意同步问题</li></ul></li></ul></li><li>延后写<ul><li>进程输出数据时，仅把数据写入<code>IO</code>缓冲区，此后，待输出设备空闲时，内核把<code>IO</code>缓冲区的数据写入输出设备<ul><li>结论：用户处理数据的同时内核输出（有延后）前一数据</li></ul></li></ul></li><li>常用的缓冲技术——环形缓冲<ul><li>若干缓冲单元首尾链接成一个环：环形缓存区</li><li><img src="/2022/03/09/osNote/image-20220102134336158.png" alt="image-20220102134336158"></li><li><img src="/2022/03/09/osNote/image-20220102134419834.png" alt="image-20220102134419834"></li></ul></li></ul><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><ul><li>设备分配方法<ul><li>独享分配</li><li>共享分配</li><li>虚拟分配</li></ul></li><li>独占设备<ul><li>每次只能供一个进程单独使用的设备<ul><li>打印机、键盘、鼠标等</li></ul></li></ul></li><li>共享设备<ul><li>允许多个进程同时使用的设备<ul><li>块设备、硬盘等</li></ul></li></ul></li><li>虚拟设备<ul><li>借助虚拟技术，在共享设备上模逆独占型设备<ul><li>一般是辅存上模逆独占型设备</li></ul></li></ul></li><li>设备分配<ul><li>独享分配<ul><li>申请成功——开始使用——用完释放</li></ul></li><li>共享分配<ul><li>即时申请即时分配，不阻塞</li></ul></li><li>虚拟分配<ul><li>申请独占设备，实际分配虚拟设备</li></ul></li></ul></li><li>虚拟技术<ul><li>在一类物理设备上模逆另一类物理设备的技术<ul><li>通常借助辅存的一部分区域模拟独占设备，将独占设备转为共享设备</li></ul></li><li>虚拟设备<ul><li>用来模拟独占设备的部分辅存称为虚拟设备，虚拟独占设备</li><li>输入井：模拟输入设备的辅存区域</li><li>输出井：模逆输出设备的辅存区域</li></ul></li></ul></li><li>虚拟分配<ul><li>申请独占设备，实际分配虚拟设备</li><li><code>SPOOLING</code>系统是虚拟技术和虚拟分配的实现<ul><li><img src="/2022/03/09/osNote/image-20220102131915385.png" alt="image-20220102131915385"></li></ul></li></ul></li><li><code>SPOOLing</code>系统构成<ul><li>输入井和输出井<ul><li>磁盘上开辟的两个存储区域</li></ul></li><li>输入缓冲区和输出缓冲区<ul><li>内存中开辟的存储区域，暂存输入输出数据，以后在传送到输入井和输出井</li></ul></li><li>预输入程序：控制信息从独占设备输入到缓存</li><li>预输入表：从哪台设备输入，存放在输入井的位置</li><li>缓输出程序：控制信息从缓存输出到独占设备</li><li>缓输出表：输出信息在输出井的位置，从那台设备输出</li><li>井管理程序：控制用户程序与辅存之间的信息交换</li></ul></li><li><code>SPOOLing</code>系统原理小结<ul><li>任务执行前：预先将程序和数据输入到输入井中</li><li>任务运行时：使用数据时，从输入井中取出</li><li>任务运行时：输出数据时，把数据写入输出井</li><li>任务运行完：外设空闲时输出全部数据和信息</li></ul></li><li><code>SPOOLing</code>优点<ul><li>提高了<code>IO</code>速度</li><li>将独占设备改造为“共享设备”<ul><li>实现了虚拟设备功能</li></ul></li></ul></li></ul><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><ul><li><p><code>Linux</code>模块</p><ul><li><code>LKM</code></li><li>一种未经链接的可执行代码</li><li>可以动态的加载或卸载模块</li><li>经过连接称为内核的一部分</li></ul></li><li><p><code>Linux</code>设备驱动（<code>LDD</code>）</p><ul><li><img src="/2022/03/09/osNote/image-20220102134627709.png" alt="image-20220102134627709"></li></ul></li><li><p><code>Linux</code>设备分类</p><ul><li>字符设备<ul><li>以字节为单位逐个进行<code>IO</code>操作</li><li>字符设备中的缓存是可有可无的</li><li>不支持随机访问</li><li>如串口设备</li></ul></li><li>块设备<ul><li>块设备的存取是通过<code>buffer</code>、<code>cache</code>来进行</li><li>可以进行随机访问</li><li>例如：<code>IDE</code>硬盘设备</li><li>支持可安装文件系统</li></ul></li><li>网络设备<ul><li>通过<code>BSD</code>套接口访问</li></ul></li></ul></li><li><p>设备文件</p><ul><li>将设备作为文件看待</li><li>使用文件接口打开、关闭、读写和<code>IO</code>控制设备<ul><li>字符设备和块设备通过设备文件访问</li><li><code>Linux</code></li></ul></li><li>主设备号和次设备号<ul><li>主设备号<ul><li>标识该设备种类，标识驱动程序</li><li>主设备号范围：<code>1</code>-<code>255</code></li><li><code>Linux</code>内核支持动态分配主设备号</li></ul></li><li>次设备号<ul><li>标识同一设备驱动程序的不同硬件设备</li><li>次设备号只在驱动程序内部使用</li></ul></li></ul></li></ul></li><li><p>驱动程序的基本接口</p><ul><li><p>面向用户程序的接口</p></li><li><p>面向<code>IO</code>管理器的接口</p><ol><li>注册函数</li><li>注销函数</li><li>数据结构</li><li>请求队列</li></ol></li><li><p>面向设备的接口</p><ul><li>把用户请求转化为端口操作<code>IN/OUT</code></li></ul><ol><li>无条件传送</li><li>查询传送</li><li>中断传送</li><li><code>DMA</code>传送</li></ol></li></ul></li></ul><h1 id="第九章-文件系统"><a href="#第九章-文件系统" class="headerlink" title="第九章 文件系统"></a>第九章 文件系统</h1><h2 id="文件和文件系统的概念"><a href="#文件和文件系统的概念" class="headerlink" title="文件和文件系统的概念"></a>文件和文件系统的概念</h2><ul><li><p>文件的定义</p><ul><li>文件是系统中信息存放的一种组织形式<ul><li>文件是若干信息项的构成<ul><li>信息项可以是字节，可以是结构化数据</li></ul></li><li>用户通过读写指针来存取文件的信息项</li><li>文件具有文件名，用户通过文件名存取文件</li></ul></li></ul></li><li><p>文件分类</p><ul><li><p>按文件的用途</p></li><li><p>系统文件</p><ul><li>包括操作系统的可执行程序和数据文件，这种文件不对用户开发，仅供系统使用</li></ul></li><li><p>库文件</p><ul><li>系统为用户提供的各种标准函数库和实用程序等，用户只能使用这些文件，而无权进行修改</li></ul></li><li><p>用户文件</p><ul><li>用户创建的文件，如用户可执行文件，源程序，数据文件等</li></ul><hr></li><li><p>按文件的操作权限</p></li><li><p>只读文件</p></li><li><p>读写文件</p></li><li><p>不保护文件</p><hr></li><li><p>按文件的性质</p></li><li><p>普通文件</p><ul><li>指一般的用户文件或系统文件</li></ul></li><li><p>目录文件</p><ul><li>由目录项组成的文件</li><li>目录项：文件名，文件属性，文件存放地址</li></ul></li><li><p>设备文件</p><ul><li>把设备作为文件管理和使用</li></ul></li></ul></li></ul><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><ul><li>文件的结构<ul><li>逻辑结构<ul><li>为用户提供逻辑结构清晰、使用方便的文件</li><li>强调文件信息项的构成方式和用户的存取方式</li></ul></li><li>物理结构<ul><li>文件在存储设备上的存储结构</li><li>强调合理利用存储空间，缩短<code>IO</code>存取时间</li></ul></li></ul></li><li>文件的逻辑结构<ul><li>流式文件<ul><li>信息项是字节，文件长度就是字节的数量</li><li>优点<ul><li>文件无需额外的说明信息或控制信息</li><li>节省存储空间</li></ul></li></ul></li><li>记录式文件<ul><li>信息项由记录组成，一个记录包含若干成员<ul><li>学生记录：姓名，学号，性别，成绩</li><li>学生花名册文件：包含若干个学生记录</li></ul></li><li>特点<ul><li>文件中需保存记录长度和数量等说明信息</li><li>浪费存储空间</li></ul></li></ul></li><li>现代<code>OS</code>中文件是流式文件</li></ul></li><li>文件的存取方法<ul><li>顺序存取<ul><li>按文件信息单位排列的顺序依次存取</li><li>读写指针</li></ul></li><li>随机存取<ul><li>直接存取</li><li>每次存取操作时先确定存取位置</li></ul></li></ul></li></ul><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><ul><li>文件的物理结构<ul><li>文件的物理结构是指文件在存储设备上的存储方式，强调合理利用存储空间，缩短<code>IO</code>存取时间</li></ul></li><li>物理结构的类型<ul><li>连续文件<ul><li>文件按照逻辑顺序存放在存储设备的连续物理块中</li></ul></li><li>串联文件<ul><li>文件信息存放在不连续的存储块中</li><li>每个存储块有一个指针，指向文件的下一个逻辑块所在的存储块</li></ul></li><li>索引文件<ul><li>文件存放在不连续的物理块中，系统建立索引表记录文件的逻辑块和存储块的对应关系</li></ul></li></ul></li></ul><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><ul><li>概念<ul><li>记录当前磁盘的使用情况，创建文件时分配存储空间，删除文件时收回存储空间</li></ul></li><li>记录磁盘空闲块的方法<ul><li>空闲文件目录</li><li>空闲块链</li><li>位示图</li></ul></li><li>空闲文件目录<ul><li>一片连续的空闲区当作一个特殊文件：空闲文件，该文件由多个连续的空闲存储块组成</li><li>所有的空闲文件代表存储设备的空闲空间</li><li>空闲文件目录<ul><li>记录所有空闲文件的目录，每个表项对应一个空闲文件</li></ul></li></ul></li><li>空闲块链<ul><li>把存储设备上的所有空闲块链接在一起，当申请者需要空闲块时，分配程序从链头开始摘取所需要的空闲块，然后调整链首指针，反之当回首空闲块时，把释放的空闲块逐个加载链尾上</li></ul></li><li>位示图<ul><li>从内存中划出若干个字节，每位对应一个存储块<ul><li>该位为1：对应存储块空闲</li><li>该位为0：对应存储块已分配</li></ul></li></ul></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul><li>文件目录<ul><li>文件名址录，记录文件名和存放地址的目录表</li><li>为了对大量文件进行分门别类的管理，提高文件检索的效率，现代操作系统往往将文件的一些属性也记录在目录中</li></ul></li><li>目录文件<ul><li>文件目录以文件形式存于外存，这个文件叫目录文件</li></ul></li><li>文件目录的功能：将文件名转换为外存物理地址的功能</li><li>文件的全名：包括从根目录开始到文件为止的通路上所有子目录路径</li><li>每个文件有唯一的路径名</li><li>两种路径名形式<ul><li>绝对路径名</li><li>相对路径名</li></ul></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>多道批处理系统为什么工作效率比单道的高<ul><li>因为多道批操作系统在内存中存放了多道程序，当某程序因某种原因不能运行放弃<code>CPU</code>时，操作系统调度另一程序投入运行，让<code>CPU</code>尽量忙碌，提高系统效率，而单道批处理系统只能让<code>CPU</code>空闲等待</li></ul></li><li>常见的虚拟机软件能不能理解为操作系统<ul><li>不能，虚拟机只是允许在当前操作系统上运行其他的操作系统，是运行在当前操作系统之上的，是一个应用程序</li></ul></li><li>临界区设计太小或太大有何缺点<ul><li>在保证功能的条件下应该设计的小一些</li><li>临界区太大，会使得其他想要访问临界区的进程等待时间过长，致使并发性变差</li><li>临界区太小，可能导致临界资源不在临界区内，程序并发执行产生混乱</li></ul></li><li>临界区访问机制为什么要实现让权等待原则，锁机制为什么没有满足该原则<ul><li>让权等待原则是指让等待的进程放弃<code>CPU</code>资源，把资源让给其他进程，避免了<code>CPU</code>资源的浪费，提高<code>CPU</code>的利用率</li><li>锁机制的等待程序在未被允许进入临界区之前，一直处于死循环状态，一直占用<code>CPU</code></li></ul></li><li>如何理解参与死锁的进程至少有2个已经占有资源<ul><li>如果参与死锁的进程只有一个占用资源，那么这个占有资源的进程可以继续获取需要的资源，并在有限时间内执行完成，释放占有的资源供其他需要程序的进程使用，这种情况下此进程为发生死锁，产生矛盾；因此参与死锁的进程至少有两个占用资源。</li></ul></li><li>如何证明“按有序资源分配法分配资源并发运行进程不会死锁”<ul><li>有序资源分配法破坏了死锁的环路条件：即<code>A</code>资源使用者等待B资源，B资源使用者等待A资源，形成死锁</li><li>有序资源分配法对资源进行编号，规定进程必须按照编号顺序申请资源，即必须先申请A资源才能申请B资源，那么就不会出现B资源被获取而在等待A资源的情况，所以不会产生死锁</li></ul></li><li>如何理解参与死锁的进程都在等待资源<ul><li>如果某个参与死锁的进程不在等待资源，那么它就会在有限时间内执行完成，并释放占用的资源，即此进程未参与死锁</li></ul></li><li>试述缺页中断的概念和缺页中断响应的过程<ul><li>在地址映射过程中，当所要访问的目的页不在内存中，则系统产生缺页中断</li><li>中断处理程序把所缺的页从页表指定的辅助存储器地址调入内存的某个页框中，并更新页表对应项，修改中断位为0</li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
