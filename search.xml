<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统笔记</title>
      <link href="/2022/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/09/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><h2 id="操作系统的定义和特性"><a href="#操作系统的定义和特性" class="headerlink" title="操作系统的定义和特性"></a>操作系统的定义和特性</h2><ul><li>桌面常见的四大操作系统<ul><li><code>Windows</code>系统</li><li><code>Linux</code>系统<ul><li><code>RedHat</code>小红帽</li></ul></li><li><code>Mac</code>系统</li><li><code>Unix</code>系统</li></ul></li><li>没有安装操作系统的计算机能干什么<ul><li>无法继续启动</li><li>没有安装操作系统的计算机开机进入<code>DOS</code>界面，需要输入指令来进行操作，无法使用鼠标、键盘等，裸机启动过程分为三步（也就是会进入<code>BIOS</code>）：<ol><li>裸机上电后，会启动自检程序，自检程序会对硬件进行检测，判断计算机情况是否正常，若有问题则提示；</li><li>初始化操作，对一些外部设备进行初始化和检测；</li><li>引导程序，引导DOS</li></ol></li></ul></li><li>操作系统的基本功能<ul><li>提供操作界面</li><li>控制程序运行</li><li>管理系统资源</li><li>配置系统参数</li><li>监控系统状态</li><li>工具软件集合</li></ul></li><li>操作系统的定义<ul><li>操作系统是一个大型系统程序，它负责计算机系统软、硬件资源的分配；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境</li><li>简而言之，管理并调度资源，为用户提供接口</li></ul></li><li>不同角度理解操作系统<ul><li>终端用户<ul><li>界面和命令</li></ul></li><li>应用程序员<ul><li>编程接口<code>API</code></li></ul></li><li>系统程序员<ul><li>管理和调度硬件资源</li><li>提供接口</li></ul></li></ul></li><li>操作系统的地位<ul><li><img src="/image-20211231210548905.png" alt="image-20211231210548905"></li></ul></li><li>操作系统的特性（<strong>重点</strong>）<ul><li>并发性<ul><li>同时处理多个任务的能力</li></ul></li><li>共享性<ul><li>为多个并发任务提供资源共享</li></ul></li><li>不确定性<ul><li>具有处理随机事件的能力<ul><li>中断处理的能力</li><li>自动化能力</li></ul></li></ul></li></ul></li></ul><h2 id="操作系统的功能（重点）"><a href="#操作系统的功能（重点）" class="headerlink" title="操作系统的功能（重点）"></a>操作系统的功能（<strong>重点</strong>）</h2><ul><li>进程管理功能、存储管理功能、设备管理功能、文件管理功能</li><li>进程管理<ul><li>处理机分配</li><li><code>CPU</code>管理</li><li>处理机管理</li><li>多个程序如何共享<code>CPU</code></li><li>具体功能：<ul><li>进程控制：创建，暂停，唤醒，撤销</li><li>进程调度：调度策略，优先级</li><li>进程通信：进程间通信</li></ul></li></ul></li><li>存储管理<ul><li>为应用程序运行高效提供内存空间</li><li>支持多道程序设计</li><li>作用：<ul><li>内存分配</li><li>内存共享</li><li>内存保护</li><li>虚拟内存</li></ul></li></ul></li><li>设备管理<ul><li>提供统一的设备使用接口，管理设备分配和使用<ul><li>设备无关性</li><li>设备的传输控制</li><li>设备的驱动</li></ul></li></ul></li><li>文件管理<ul><li>文件和目录的管理</li><li>提供简便统一的信息存取和管理方法，解决信息共享、数据的存取控制等问题<ul><li>存储空间管理</li><li>文件的操作</li><li>目录的操作</li><li>文件和目录的存取权限管理</li></ul></li></ul></li></ul><h2 id="操作系统的性能"><a href="#操作系统的性能" class="headerlink" title="操作系统的性能"></a>操作系统的性能</h2><ul><li>吞吐率<ul><li>在单位时间内处理信息的能力</li></ul></li><li>响应能力<ul><li>从接收数据到输出结果的时间间隔</li></ul></li><li>资源利用率<ul><li>设备使用的频度</li></ul></li><li>可移植性<ul><li>改变硬件环境仍能正常工作的能力：代码修改量</li></ul></li><li>可靠性<ul><li>发现、诊断和恢复系统故障的能力</li></ul></li></ul><h2 id="操作系统的发展历史"><a href="#操作系统的发展历史" class="headerlink" title="操作系统的发展历史"></a>操作系统的发展历史</h2><ul><li><p>计算机硬件发展的四个典型阶段</p><ul><li>电子管时代</li><li>晶体管时代</li><li>集成电路时代</li><li>大规模集成电路时代</li></ul></li><li><p>操作系统发展的四个典型阶段</p><ol><li>手工操作</li><li>单道批处理系统</li><li>多道批处理系统</li><li>分时操作系统</li></ol></li><li><p>手工操作</p><ul><li>使用特点<ul><li>上机：编程（打孔），预约，操作机器（开关/接线）</li><li>程序启动与结束：手工处理</li></ul></li><li>缺点<ul><li>效率低：<code>CPU</code>运行时间少，例：100分钟 = 50分钟(装) + 10(<code>CPU</code>运行) + 40(拆)</li><li>用户独占</li><li>缺少交互</li></ul></li></ul></li><li><p>单道批处理系统</p><ul><li>工作过程<ul><li>管理员将多个作业输入到磁盘形成作业队列</li><li>监控程序依次自动处理磁盘中的每个作业<ul><li>装入—运行—撤出—装入—运行—撤出—……</li></ul></li><li>运行完毕，通知用户取出结果</li></ul></li><li>工作特点<ul><li>一批：作业队列</li><li>自动：识别作业</li><li>单道：串行</li></ul></li><li>单道批处理的两种实现方式<ul><li>联机批处理<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101113211078.png" alt="image-20220101113211078"></li><li>特点：主机控制输入/输出</li><li>缺点：系统效率低</li></ul></li><li>脱机批处理<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101113304832.png" alt="image-20220101113304832"></li><li>特点：卫星机控制输入/输出</li><li>优点：系统效率高</li><li>缺点：调度不灵活；保护问题</li></ul></li></ul></li><li>单道批处理系统中<code>CPU</code>的使用情况<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101113722924.png" alt="image-20220101113722924"></li><li>现象：外设工作时<code>CPU</code>空闲，<code>CPU</code>工作时外设空闲</li><li>结论：<code>CPU</code>和外设效率低</li></ul></li><li>单道批处理系统程序的改进<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101113908340.png" alt="image-20220101113908340"></li><li>程序设计合理<ul><li>使得<code>IO</code>发生时，程序可以继续做一些其他的工作，例如上图中的<code>WhileReading()</code>函数</li></ul></li><li>系统必须提供工具<ul><li>程序可以启动设备和测试设备</li></ul></li></ul></li></ul></li><li><p>多道批处理系统（<strong>重点</strong>）</p><ul><li>多道程序设计技术<ul><li>在内存中存放多道程序，当某道程序因为某种原因（例如请求<code>IO</code>时）不能继续运行，监控程序便调度另一程序投入运行，这样可以使<code>CPU</code>尽量处于忙绿状态，提高系统效率</li></ul></li><li>多道批处理系统<ul><li>采用多道程序设计技术实现的处理系统称为多道批处理系统</li></ul></li><li>多道批处理系统的设计目的<ul><li>提高系统的利用率（或吞吐量）<ul><li><code>CPU</code>和外设并行</li><li>外设之间也并行</li></ul></li></ul></li><li>多道程序相互穿插的运行过程<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101114517467.png" alt="image-20220101114517467"></li><li><code>A、B</code>两道程序相互穿插的运行，使<code>CPU</code>和外设都尽量忙碌</li></ul></li><li>多道程序设计思想<ul><li>多个程序同时在计算机/虚拟机上运行</li><li>物理资源的共享<ul><li>时分：分成多个时段，不同进程错开使用不同时段</li><li>空分：分成多个单元，不同进程同时使用不同单元</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101114840918.png" alt="image-20220101114840918"></li></ul></li></ul></li><li>多道批处理系统的特点<ul><li>多道：内存同时存放多道程序</li><li>并行：宏观上</li><li>串行：微观上</li></ul></li><li>意义：多道技术出现——操作系统形成</li><li>多道批处理系统的缺点<ul><li>作业处理时间长</li><li>运行过程不确定</li><li>交互能力差</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101115115243.png" alt="image-20220101115115243"></li></ul></li><li>60年代硬件的两个重大进展<ul><li>中断技术<ul><li>当<code>CPU</code>收到外部信号（中断信号）后，停止当前的工作，转去处理该外部事件，处理完毕后回到原来工作的中断处（断点）继续原来的工作</li></ul></li><li>通道技术<ul><li>专门处理外设和内存之间的数据传输的处理机</li></ul></li></ul></li></ul></li><li><p>分时技术与多道批批处理系统都能完成多个程序的切换，这两种切换有何差别</p><ul><li>分时技术采用的方法是，主机以很短的时间片为单位把<code>CPU</code>轮流分配给每个终端使用，直到作业被全部运行完，让终端认为自己独占<code>CPU</code></li><li>多道批操作系统是内存中存放了多个程序，程序相互穿插运行，当某道程序没有使用<code>CPU</code>时，系统调度另一程序投入执行；多道批处理本质在微观上还是相当于单道批，但是分时技术可以把多个程序真正地“同时”（差别时间不大）运行</li></ul></li><li><p>分时操作系统</p><ul><li><p>背景</p><ul><li>中断技术</li><li>大规模集成电路</li><li>事务性任务和程序的涌现<ul><li>交互性高</li><li>响应快速</li></ul></li><li>要求：多任务多用户</li></ul></li><li><p>多终端计算机</p><ul><li>主机采用分时技术轮流为每个终端服务，每个终端都感觉到是“独占”主机</li></ul></li><li><p>分时技术（<strong>重点</strong>）</p><ul><li><p>概念</p><ul><li>主机以很短的“<strong>时间片</strong>”为单位，把<code>CPU</code>循环的轮流分配给每个作业（终端/用户）使用，直到全部作业被运行完</li></ul></li><li><p>特点</p><ul><li><p>时间片：较短时间间隔</p></li><li><p>响应及时：独占主机</p></li></ul></li></ul></li><li><p>分时系统的特点</p><ul><li>多路调制性<ul><li>多用户联机使用同一台计算机</li></ul></li><li>独占性<ul><li>用户感觉独占一台计算机</li></ul></li><li>交互性<ul><li>及时响应用户的请求</li></ul></li></ul></li></ul></li><li><p><code>UNIX</code></p><ul><li>第一个实用化的分时操作系统</li><li>革新和创造<ul><li>实现了操作系统的可移植性</li><li>“特殊文件”：外设看作文件</li></ul></li></ul></li><li><p>操作系统的进一步发展</p><ul><li>实时操作系统/嵌入式操作系统</li><li>微机操作系统</li><li>多处理机操作系统</li><li>网络操作系统</li><li>分布式操作系统</li><li>嵌入式操纵系统</li></ul></li></ul><h1 id="第二章-操作系统结构与硬件支持"><a href="#第二章-操作系统结构与硬件支持" class="headerlink" title="第二章 操作系统结构与硬件支持"></a>第二章 操作系统结构与硬件支持</h1><h2 id="操作系统虚拟机（重点）"><a href="#操作系统虚拟机（重点）" class="headerlink" title="操作系统虚拟机（重点）"></a>操作系统虚拟机（重点）</h2><ul><li>面对用户，裸机配置操作系统后称为操作系统虚拟机<ul><li>用户界面</li><li>屏蔽硬件细节</li><li>扩展硬件功能</li><li>系统更安全</li><li>系统更可靠</li><li>效率更高</li></ul></li></ul><h2 id="操作系统的逻辑结构"><a href="#操作系统的逻辑结构" class="headerlink" title="操作系统的逻辑结构"></a>操作系统的逻辑结构</h2><ul><li><p>逻辑结构</p><ul><li><code>OS</code>的设计和实现思路</li></ul></li><li><p>逻辑结构的种类</p><ul><li>整体式结构（单体式结构、宏内核结构）</li><li>微内核结构</li><li>层次式结构</li></ul></li><li><p>整体式结构</p><ul><li>以模块为基本单位构建<ul><li>每个模块具有特定的功能</li></ul></li><li>定义<ul><li>模块化结构/单体内核结构/宏内核结构</li><li>操作系统由大量的过程构成，每个过程都有明确参数列表、返回值类型，大多数过程是可以相互间调用的</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101142121165.png" alt="image-20220101142121165"></li></ul></li><li>优点<ul><li>模块的设计、编码和调试独立</li><li>模块之间可以相互调用</li></ul></li><li>缺点<ul><li>错误容易扩散</li><li>开发和维护困难</li><li>可伸缩性差</li></ul></li><li>实例<code>os</code>——<code>UNIX</code><ul><li>采用单一内核模块（单体结构）实现</li><li>对外提供一组系统调用</li><li>设备驱动与内核其他部分分开</li></ul></li><li>实例<code>os</code>——<code>Linux</code><ul><li>宏内核，单体内核</li><li>支持动态可安装模块</li><li>模块可以在操作系统中动态安装或去除</li><li>模块可以在内核运行时编译或安装</li></ul></li></ul></li><li><p>层次式结构</p><ul><li><p>层次结构的软件例子——<code>TCP/IP</code>协议栈</p></li><li><p>定义</p><ul><li>功能模块按调用次序排成若干层，各层单向依赖或单向调用</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101142104116.png" alt="image-20220101142104116"></li></ul></li><li><p>分层原则</p><ul><li>硬件相关——最底层</li><li>外部特性——最外层</li><li>中间层——调用次序或消息传递顺序</li><li>共性服务——较低层</li><li>活跃功能——较低层</li></ul><ol><li>硬件相关的放在最底层</li><li>与用户策略或用户交互相关的功能放在最顶层</li><li>中间层各层按调用次序或消息传递次序安排</li><li>共性的和活跃的服务放在较低的层次</li></ol></li><li><p>层次结构的优点</p><ul><li>结构清晰，避免循环调用</li><li>整体结构局部化，系统的正确性容易保证</li><li>有利于操作系统的维护、扩充和移植</li></ul></li></ul></li><li><p>微内核结构（客户/服务器结构）</p><ul><li>客户——应用程序</li><li>服务器——操作系统<ul><li>微内核<ul><li>足够小，提供<code>OS</code>最基本的核心功能和服务</li><li>足够与硬件紧密相关的处理</li><li>实现一些较基本的功能</li><li>负责客户与服务器之间的通信</li></ul></li><li>核外服务器<ul><li>完成<code>OS</code>的绝大多数功能，等待用户提供请求</li><li>由若干服务器或进程共同构成<ul><li>例如：进程/线程服务器，虚存服务器，设备管理服务器等，以进程形式运行在用户态</li></ul></li></ul></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101142309979.png" alt="image-20220101142309979"></li></ul></li></ul></li><li><p>微内核和单体内核（宏内核）的比较</p><ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101142441329.png" alt="image-20220101142441329"></li></ul></li></ul><h2 id="操作系统依赖的基本硬件环境"><a href="#操作系统依赖的基本硬件环境" class="headerlink" title="操作系统依赖的基本硬件环境"></a>操作系统依赖的基本硬件环境</h2><h3 id="处理机的态（重点）"><a href="#处理机的态（重点）" class="headerlink" title="处理机的态（重点）"></a>处理机的态（<strong>重点</strong>）</h3><ul><li><p>支持操作系统的最基本的硬件结构</p><ul><li><code>CPU</code>、内存、中断、时钟</li></ul></li><li><p>操作系统考虑的安全问题</p><ul><li>共享/安全<ul><li>防止进程的信息被非法访问</li><li>防止进程随意存取系统资源</li><li>防止进程修改系统安全机制</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101142817081.png" alt="image-20220101142817081"></li></ul></li><li>解决策略<ol><li>软件被设置为可信软件和不可信软件两类<ul><li>保护机制能区分可信软件和不可信软件</li><li>可信软件权限高<ul><li>可以修改安全保护机制</li><li>可以存取系统资源</li></ul></li><li>不可信软件<ul><li>功能受限</li></ul></li><li><code>CPU</code>能区分当前软件的类型并设置不同的工作模式</li></ul></li><li>设置访问屏障<ul><li><code>CPU</code>根据当前的工作模式，限制可使用的指令集</li><li>设置可信软件和不可信软件之间的访问屏障</li></ul></li></ol></li></ul></li><li><p><code>CPU</code></p><ul><li><code>CPU</code>态（<code>Mode</code>）<ul><li><code>CPU</code>的工作状态</li><li>对<strong>资源和指令使用</strong>权限的描述</li></ul></li><li>硬件描述<ul><li>在处理器中包含有一个模式位，表明当前的权限状态</li><li>指令执行前增加“权限状态是否满足”的条件判断</li><li><code>Intel CPU</code><ul><li><code>PE</code>位，<code>PG</code>位</li><li>地址映射机制</li><li>权限核验</li></ul></li></ul></li><li>特权指令<ul><li>类别<ol><li>涉及外部设备的输入/输出指令</li><li>修改特殊寄存器的指令</li><li>改变机器状态的指令</li></ol></li></ul></li><li><code>CPU</code>态的分类<ul><li>核态<ul><li>能够访问所有资源和执行所有指令</li><li>管理程序/<code>OS</code>内核</li></ul></li><li>用户态<ul><li>仅能访问部分资源，其他资源受限</li><li>用户进程</li></ul></li><li>管态<ul><li>介于核态和用户态之间</li></ul></li></ul></li><li>硬件和<code>OS</code>对<code>CPU</code>的观察<ul><li>硬件按“态”来区分<code>CPU</code>的状态</li><li><code>OS</code>按“进程”来区分<code>CPU</code>的状态</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101145115299.png" alt="image-20220101145115299"></li></ul></li><li>用户态和核态之间的转换<ul><li>用户态向核态转换<ul><li>用户请求<code>OS</code>提供服务</li><li>发生中断</li><li>用户进程产生错误（内部中断）</li><li>用户态企图执行特权指令</li></ul></li><li>核态向用户态转换的情形<ul><li>一般是中断返回：<code>IRET</code></li></ul></li></ul></li></ul></li><li><p>内存</p><ul><li>存储器：存储程序和数据的部件</li><li>存储器分类<ul><li>按与<code>CPU</code>的联系<ul><li>主存：直接与<code>CPU</code>交换信息</li><li>辅存：不能直接和<code>CPU</code>交换信息</li></ul></li><li>按存储器（半导体存储器）读写工作方式<ul><li>RAM</li><li>ROM</li></ul></li></ul></li><li>理想体系<ul><li>理想存储体系：速度快、容量大、成本低</li><li>实际存储体系<ul><li>寄存器</li><li>高速缓存</li><li>主存</li><li>磁盘</li></ul></li></ul></li><li>分级存储系统的工作原理<ul><li><code>CPU</code>读取指令或数据时的访问顺序<ol><li>访问缓存</li><li>访问内存</li><li>访问辅存</li></ol></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101150413394.png" alt="image-20220101150413394"></li></ul></li></ul></li><li><p>时钟</p><ul><li>以固定时间间隔产生时钟信号，提供计算机所需的节拍</li><li>时钟的作用：<ul><li>时间片</li><li>提供绝对时间</li><li>提供预定的时间间隔</li></ul></li><li>时钟的类型<ul><li>绝对时钟</li><li>相对时钟</li></ul></li></ul></li></ul><h3 id="中断机制（重点）"><a href="#中断机制（重点）" class="headerlink" title="中断机制（重点）"></a>中断机制（<strong>重点</strong>）</h3><ul><li>中断<ul><li><p>中断定义</p><ul><li>只<code>CPU</code>对突发的外部事件的反应过程或机制</li><li><code>CPU</code>收到外部信号后，停止当前工作，转去处理该外部事件，处理完毕后回到原来工作的地方继续原来的工作</li></ul></li><li><p>引入中断的目的</p><ul><li>实现并发活动</li><li>实现实时处理</li><li>故障自动处理</li></ul></li><li><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101150816219.png" alt="image-20220101150816219"></p></li><li><p>中断的一些概念</p><ul><li><p>中断源</p><ul><li>引起系统中断的事件称为中断源</li></ul></li><li><p>中断类型</p><ul><li><p>强迫中断和自愿中断</p><ul><li>强迫中断：程序没有预期，例如：<code>IO</code>、外部中断</li><li>自愿中断：程序有预期，例如：执行访管指令</li></ul></li><li><p>外中断（中断）和内中断（俘获）</p><ul><li>外中断：由<code>CPU</code>外部事件引起，例如：<code>IO</code>、外部事件</li><li>内中断：由<code>CPU</code>内部事件引起，例如：访管指令、程序中断</li></ul></li><li><p>外中断：不可屏蔽中断和可屏蔽中断</p><ul><li>不可屏蔽中断：中断的原因很紧要，<code>CPU</code>必须响应</li><li>可屏蔽中断：中断的原因不很紧要，<code>CPU</code>可以不响应</li></ul></li></ul></li><li><p>断点</p><ul><li>程序中断的地方，将要执行的下一条指令的地址</li><li><code>CS：IP</code></li></ul></li><li><p>现场</p><ul><li>程序正确运行所依赖的信息集合</li><li><code>PSW</code>程序状态字，<code>PC</code>，相关寄存器</li></ul></li><li><p>进入中断服务程序：破坏主程序的现场</p></li><li><p>现场的两个处理过程</p><ul><li>现场的保护：进入中断服务程序之前，入栈</li><li>现场的恢复：退出中断服务程序之后，出栈</li></ul></li></ul></li><li><p>中断响应过程</p><ol><li>识别中断源</li><li>保护断点和现场</li><li>装入中断服务程序</li><li>进入中断服务程序</li><li>恢复现场和断点</li><li>中断返回：<code>IRET</code></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101152157861.png" alt="image-20220101152157861"></li></ol></li><li><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101152600617.png" alt="image-20220101152600617"></p></li><li><p>中断响应的实质</p><ul><li>交换指令执行地址</li><li>交换<code>CPU</code>的态</li><li>工作<ul><li>现场保护和恢复</li><li>参数传递（通信）</li></ul></li></ul></li></ul></li></ul><h1 id="第三章-用户界面"><a href="#第三章-用户界面" class="headerlink" title="第三章 用户界面"></a>第三章 用户界面</h1><h2 id="用户环境和构造"><a href="#用户环境和构造" class="headerlink" title="用户环境和构造"></a>用户环境和构造</h2><ul><li>用户环境<ul><li>用户工作的软件环境<ul><li>桌面环境</li><li>命令行环境</li></ul></li></ul></li><li>用户环境构造<ul><li>按照用户要求和硬件特性按照和配置操作系统<ul><li>提供操作命令和界面</li><li>提供系统用户手册</li></ul></li></ul></li></ul><h2 id="操作系统的启动"><a href="#操作系统的启动" class="headerlink" title="操作系统的启动"></a>操作系统的启动</h2><ul><li><p>相关背景知识</p><ul><li>实模式和保护模式</li><li><code>BIOS</code>(<code>Basic I/O System</code>)</li><li><code>POST</code>(<code>Power On Self Test</code>)</li><li><code>CMOS</code></li></ul></li><li><p>启动过程</p></li><li><p>操作系统的安装</p><ul><li><code>MBR</code>（主引导程序）</li><li>安装过程</li><li>多操作系统安装和启动</li></ul></li><li><p>实模式（实地址模式）</p><ul><li>程序按照8086寻址方式访问0-<code>FFFFFh</code>（<code>1MB</code>）空间</li><li>寻址方式：物理地址（20位）</li><li><code>CPU</code>单任务运行</li><li>实模式存取的<code>1M</code>空间<ul><li>前面<code>640K</code>：基本内存</li><li>中间<code>128K</code>：显卡显存</li><li>末尾<code>256K</code>：<code>BIOS</code></li></ul></li></ul></li><li><p><code>MBR</code></p><ul><li>和<code>os</code>启动相关的数据和代码</li><li>存放在主启动扇区</li><li><code>MBR</code>读取分区表，查找并确认唯一活动分区，<code>MBR</code>读取活动分区<code>PBR</code>，并加载到内存</li><li><code>PBR</code>控制后续引导进程</li></ul></li><li><p><code>BIOS</code></p><ul><li>基本输入输出系统</li><li>功能：<ul><li><code>CMOS</code>设置</li><li>基本<code>IO</code>设备中断服务</li><li><code>POST</code>上电自检</li><li>系统自举/加载<code>OS</code></li></ul></li></ul></li><li><p><code>POST</code></p><ul><li>加电自检</li><li>初始化基本硬件<ul><li><code>CPU</code>、内存、显卡</li></ul></li></ul></li><li><p>系统自举/加载<code>OS</code></p><ul><li>开机时将<code>OS</code>载入内存并运行，为用户建立用户环境</li></ul></li><li><p>操作系统的启动</p><ul><li>从加电到用户工作环境准备好的过程</li></ul><ol><li>初始引导</li><li>核心初始化</li><li>系统初始化</li></ol></li></ul><ol><li>初始引导<ul><li>目的：把<code>OS</code>内核装入内存并使之开始工作，接管计算机系统</li><li>过程：<ul><li>加电，<code>jump POST</code></li><li>跳入<code>BIOS</code>的启动程序<ul><li>读取第0面0道1扇区的内容</li><li><code>MBR</code>：主启动记录，引导程序</li></ul></li><li>运行引导程序<ul><li>根据相关参数，读取硬盘指定位置的<code>OS</code>内核到内存</li><li>初始化基本参数</li></ul></li><li><code>OS</code>内核：逐步加载<code>OS</code>剩余部分，直到最后完全控制计算机</li></ul></li></ul></li><li>核心初始化<ul><li>目的：<code>OS</code>内核初始化系统的核心数据</li></ul></li><li>系统初始化<ul><li>目的：为用户使用系统做准备，使系统处于待命状态</li></ul></li></ol><h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><ul><li><p>用户界面的定义</p><ul><li><code>OS</code>提供给用户控制计算机的机制，又称用户接口</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101160545346.png" alt="image-20220101160545346"></li></ul></li><li><p>用户界面的类型</p><ul><li><p>操作界面</p></li><li><p>系统调用</p></li></ul></li></ul><h3 id="操作界面"><a href="#操作界面" class="headerlink" title="操作界面"></a>操作界面</h3><ul><li>图形用户接口</li><li>键盘命令<ul><li>普通命令：<code>ls、cd、ps</code>等</li><li>批处理程序：普通命令的集合，批执行</li><li><code>shell</code>：操作系统和用户交互的界面<ul><li><code>shell</code>表现为通过控制台执行用户命令的方式</li><li><code>shell</code>本身不执行命令，仅仅是组织和管理命令</li></ul></li></ul></li></ul><h3 id="系统调用（重点）"><a href="#系统调用（重点）" class="headerlink" title="系统调用（重点）"></a>系统调用（<strong>重点</strong>）</h3><ul><li>系统调用<ul><li>操作系统内核为应用程序提供的一系列服务/函数</li></ul></li><li>特点<ul><li>一般涉及核心资源或硬件的操作</li><li>系统调用运行于核态</li><li>每个系统调用有唯一的编号：<code>ID</code></li><li>系统调用过程会产生中断：自愿中断</li></ul></li><li>具体<code>OS</code>中系统调用的实现<ul><li><code>DOS</code>：<code>int 21h</code></li><li><code>Linux</code>：<code>int 80h</code></li></ul></li><li>访管指令<ul><li>用于实现在用户态下运行的进程调用操作系统内核程序</li><li>执行过程<ol><li>设置模式位</li><li>转入内核某固定位置（自陷中断处理）</li><li>跳转到相应的<code>OS</code>服务例程，执行</li><li>返回用户空间</li></ol></li></ul></li></ul><h1 id="第四章-进程管理"><a href="#第四章-进程管理" class="headerlink" title="第四章 进程管理"></a>第四章 进程管理</h1><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><ul><li>进程定义<ul><li>进程是程序在某个数据集合上的一次运行活动<ul><li>数据集合：软硬件环境，多个进程共存/共享的环境</li></ul></li></ul></li><li>进程的特征<ul><li>动态性：进程是程序的一次执行过程，动态产生/消亡</li><li>并发性：进程可以同其他进程一起向前推进</li><li>异步性：进程按各自的速度向前推进</li><li>独立性：进程是系统分配资源和调度<code>CPU</code>的单位</li></ul></li><li>进程和程序的区别<ul><li>动态和静态<ul><li>进程是动态的：程序的一次执行过程</li><li>程序是静态的：一组指令的有序集合</li></ul></li><li>暂存和长存<ul><li>进程是暂存的：在内存上驻留</li><li>程序是长存的：在介质上长期保存</li></ul></li><li>一个程序可能有多个进程</li></ul></li><li>进程的类型<ul><li>按使用资源的权限<ul><li>系统进程：指系统内核相关的进程</li><li>用户进程：运行于用户态的进程</li></ul></li><li>按对<code>CPU</code>的依赖性<ul><li>偏<code>CPU</code>进程：计算型进程</li><li>偏<code>IO</code>进程：侧重于<code>IO</code>的进程</li></ul></li></ul></li></ul><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><ul><li>进程的状态<ul><li>运行状态：进程已经占有<code>CPU</code>，在<code>CPU</code>上运行</li><li>就绪状态：具有运行条件但由于无<code>CPU</code>，暂时不能运行</li><li>阻塞状态：因为等待某项服务完成或信号到来而不能运行的状态，例如：系统调用，<code>IO</code>操作，合作进程的信号或服务</li><li>进程状态的变迁：<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101185108807.png" alt="image-20220101185108807"></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101185137670.png" alt="image-20220101185137670"></li></ul></li></ul></li><li>支持挂起和解挂操作的进程状态<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101185328397.png" alt="image-20220101185328397"></li></ul></li></ul><h2 id="进程控制块（PCB）"><a href="#进程控制块（PCB）" class="headerlink" title="进程控制块（PCB）"></a>进程控制块（PCB）</h2><ul><li>进程的描述——进程控制块<ul><li>描述进程的状态、资源、和相关进程的关系的一种数据结构</li><li><code>PCB</code>是进程的标志</li><li>创建进程时创建<code>PCB</code>，进程撤销后<code>PCB</code>同时撤销</li></ul></li><li>和进程标识相关的成员变量<ul><li><code>PID</code>：进程ID</li><li><code>PPID</code>：父进程ID</li><li><code>PGID</code>：进程组ID</li></ul></li></ul><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><ul><li>线程的概念<ul><li>线程是进程内的一个执行路径</li><li>一个进程可以包含多个线程</li><li>线程之间共享<code>CPU</code>可以实现并发运行</li><li>创建线程比创建进程开销要小</li><li>线程间通信十分方便</li></ul></li><li>适用场景<ul><li>程序的多个功能需要并发运行</li><li>提高窗口的交互性</li><li>改善程序的结构</li><li>多核<code>CPU</code>上的应用，充分发挥多核性能</li></ul></li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><ul><li><p>进程控制的概念</p><ul><li>在进程的生存全期间，对其全部行为的控制</li><li>四个典型的进程控制<ul><li>创建进程：创建一个具有指定标识ID的进程<ul><li>参数：进程标识、优先级、进程起始地址、<code>CPU</code>初始状态、资源清单等</li></ul></li><li>撤销进程：撤销一个指定的进程<ul><li>收回进程所占有的资源，撤销该进程的<code>PCB</code></li><li>撤销的时机：正常结束、异常结束、外界干预</li><li>参数：被撤销的进程名ID</li></ul></li><li>阻塞进程：停止进程执行，变为阻塞<ul><li>阻塞的时机：请求系统服务、启动某种操作、新数据未到、无新工作</li><li>参数：阻塞原因，不同原因有不同的阻塞队列</li></ul></li><li>唤醒进程：唤醒处于阻塞队列中的某个进程<ul><li>唤醒的时机：系统服务满足，<code>IO</code>完成、新数据到达、进程提出新要求</li><li>参数：被唤醒进程的标识</li></ul></li></ul></li></ul></li><li><p>创建进程的过程</p><ul><li>创建一个空白的<code>PCB</code></li><li>赋予进程标识符ID</li><li>为进程分配空间</li><li>初始化<code>PCB</code>：默认值</li><li>插入相应的进程队列：新进程插入就绪队列</li></ul></li><li><p>进程撤销的实现</p><ul><li>在<code>PCB</code>队列中检索出该<code>PCB</code></li><li>获取该进程的状态</li><li>若该进程处在运行态，立即终止该进程<ul><li>（递归）先撤销子进程</li><li>子进程挂到<code>init</code>进程下</li></ul></li><li>释放进程占有的资源</li><li>将进程从<code>PCB</code>队列中移除</li></ul></li><li><p>进程阻塞的实现</p><ul><li>停止运行</li><li>将<code>PCB</code>运行态改为阻塞态</li><li>插入对应的阻塞队列</li><li>转调度程序</li></ul></li><li><p>原语</p><ul><li>由若干指令构成的具有特定功能的函数</li><li>具有原子性，其操作不可分割</li><li>创建原语、撤销原语、阻塞原语、唤醒原语</li></ul></li><li><p><code>windows</code>进程控制</p><ul><li><code>CreateProcess</code>函数</li></ul></li><li><p><code>Linux</code>进程控制——<code>fork</code></p><ul><li><code>fork</code>创建进程<ul><li>子进程是父进程的复制</li><li>父进程和子进程并发运行（在<code>fork</code>函数之后）</li><li><code>fork</code>的返回值：子进程返回<code>0</code>，父进程返回子进程<code>ID</code>，出错返回<code>-1</code></li></ul></li><li>进程执行特定的功能<ul><li><code>exec</code>函数族，功能：装入一个指定的可执行程序运行，使子进程具有和父进程完全不同的新功能</li></ul></li><li><code>fork</code>常规用法<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101192451127.png" alt="image-20220101192451127"></li></ul></li></ul></li><li><p><code>linux</code>进程控制——<code>wait(int &amp;status)</code></p><ul><li>进程调用<code>wait</code>来阻塞自己<ul><li>检测子进程是否结束<ul><li>未结束：等待子进程结束，继续阻塞</li><li>已结束：<code>wait</code>收集该子进程信息并彻底销毁它后返回</li></ul></li><li><code>Status</code>接收子进程退出时的退出代码<ul><li>若忽略子进程的退出信息：<code>wait(NULL)</code></li></ul></li></ul></li></ul></li><li><p><code>linux</code>进程控制——<code>exit(int status)</code></p><ul><li>调用<code>exit</code>终结进程</li><li>进程终结时要释放资源并向父进程报告<ul><li>利用<code>status</code>向父进程传递退出代码</li><li>变为僵尸进程，保留部分<code>PCB</code>信息供<code>wait</code>收集</li><li>调用<code>schedule</code>函数，选择新进程运行</li></ul></li></ul></li><li><p><code>Linux</code>进程控制——<code>sleep(int nSecond)</code></p><ul><li>进程暂停执行<code>nSecond</code>秒</li></ul></li></ul><h2 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h2><ul><li>进程的互斥关系<ul><li>多个进程由于共享具有独占性的资源，必须协调各进程对资源的存取顺序：确保没有任何两个或以上的进程同时进行资源的存取</li><li>临界资源：一次只允许一个进程独占访问的资源，例如：共享变量<code>i</code></li><li>临界区：进程中访问临界资源的程序段</li><li>临界资源和临界区的共享特点<ul><li>临界资源的访问具有排他性</li><li>并发进程不能同时进入“临界区”</li></ul></li><li>访问临界区的方法<ul><li>锁机制</li><li>信号量</li></ul></li></ul></li><li>进程的同步关系<ul><li>若干合作进程为了共同完成一个任务，需要相互协调运行步伐，一个进程A开始某个操作之前要求另一个进程B必须已经完成另一个操作，否则进程A只能等待</li><li>互斥关系属于特殊的同步关系</li></ul></li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><ul><li>锁机制<ul><li>基本原理<ul><li>设置一个标识<code>S</code>：表明临界资源是否可用</li><li>在进入临界区之前先检查标志是否可用</li><li>进入临界区后，将标志修改为不可用——上锁</li><li>退出临界区，将标志修改为可用——解锁</li></ul></li><li>上锁原语和解锁原语</li></ul></li><li>设置临界区的四个原则<ul><li>忙则等待</li><li>空闲让进</li><li>有限等待</li><li>让权等待：等待进程放弃<code>CPU</code>（锁机制不满足）</li></ul></li></ul><h2 id="信号量和PV操作"><a href="#信号量和PV操作" class="headerlink" title="信号量和PV操作"></a>信号量和<code>PV</code>操作</h2><ul><li><p>信号灯机制</p><ul><li><p>信号灯数据结构</p><ul><li>信号灯定义为一个二元矢量(S, q)</li><li><code>S</code>信号量：整数，初值非负</li><li><code>q</code>队列：进程<code>PCB</code>集合</li></ul></li><li><p>两个操作</p><ul><li><code>P、V</code>操作</li></ul></li><li><p><code>P</code>操作</p><ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101201058298.png" alt="image-20220101201058298"></li></ul></li><li><p><code>V</code>操作</p><ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101201126834.png" alt="image-20220101201126834"></li></ul></li><li><p>信号灯与<code>PV</code>操作的应用</p><ul><li><p>实现进程互斥</p><ul><li><p>实质是实现对临界区的互斥访问</p><p>1个临界资源：允许最多一个进程处于临界区</p><p>M个临界资源：允许最多<code>M</code>个程序同时处于临界区</p></li><li><p>应用过程</p><p>进入临界区之前先执行<code>P</code>操作</p><p>离开临界区之后再执行<code>V</code>操作</p><p><code>S</code>的初值设置要合理（S初值为临界资源的数量）</p></li><li><p>例子：<img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101201527187.png" alt="image-20220101201527187"></p></li></ul></li><li><p>实现进程的同步</p><ul><li><p>同步机制实质</p><p>运行条件不满足时，能让进程暂停</p><p>运行条件满足时，能让进程立即继续</p></li><li><p><code>PV</code>操作应用于进程同步的基本思路</p><p>暂停当前进程：在关键操作之前执行<code>P</code>操作</p><p>继续进程：在关键操作之后执行<code>V</code>操作</p><p>定义有意义的信号量<code>S</code>，并设置合适的初值（不合理的初值会引发死锁）</p></li></ul></li></ul></li></ul></li></ul><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ul><li>生产者、消费者问题</li><li>读者、编者问题</li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><ul><li>进程通信方式<ul><li>低级通信原语<ul><li>交换信息量较少</li></ul></li><li>高级通信原语<ul><li>交换信息较多</li></ul></li></ul></li><li><code>linux</code>软中断通信机制<ul><li><code>kill(pid,sig)</code>：传递软中断信号</li><li><code>signal(sig,func)</code>：注册软中断信号</li><li><code>wait()</code>：用于父子进程间的同步</li><li><code>sleep()</code>：使当前进程睡眠</li></ul></li><li>管道通信<ul><li>父进程创建管道<code>fd[0]</code>读句柄、<code>fd[1]</code>写句柄</li><li>父进程<code>fork</code>、<code>createprocess</code>创建子进程</li><li>单向通信（双向通信创建两个管道）</li><li>特点<ul><li>只允许有血缘关系的进程间通信</li><li>面向字节流</li><li>跟随进程</li></ul></li></ul></li></ul><h1 id="第五章-资源分配与调度"><a href="#第五章-资源分配与调度" class="headerlink" title="第五章 资源分配与调度"></a>第五章 资源分配与调度</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><ul><li>死锁的定义<ul><li>两个或多个进程无限期地等待永远不会发生的条件的一种系统状态</li></ul></li></ul><h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><ul><li>死锁的原因<ul><li>系统资源有限<ul><li>资源数目不足以满足所有进程的需要，引起进程对资源的竞争而产生死锁</li></ul></li><li>并发进程的推进顺序不当<ul><li>进程在运行过程中，请求和释放资源的顺序不当，导致进程产生死锁</li></ul></li></ul></li><li>关于死锁的一些结论<ul><li>陷入死锁的进程至少是2个</li><li>参与死锁的进程至少有两个已经占用资源</li><li>参与死锁的所有进程都在等待资源</li><li>参与死锁的进程是当前系统中所有进程的子集</li><li>死锁会浪费大量的系统资源，甚至导致系统崩溃</li></ul></li><li>死锁的必要条件<ul><li>互斥条件<ul><li>资源具有独占性，进程互斥的使用资源</li></ul></li><li>不剥夺条件<ul><li>进程在释放资源前不能被其他程序剥夺</li></ul></li><li>部分分配条件<ul><li>进程所需要的资源逐步分配，需要时申请和分配</li></ul></li><li>环路条件<ul><li>多个进程构成环路：环中每个进程已经占用的资源被前一进程申请，而自己所需要的新资源又被环中后一进程所占用</li></ul></li></ul></li></ul><h2 id="解决死锁问题的策略"><a href="#解决死锁问题的策略" class="headerlink" title="解决死锁问题的策略"></a>解决死锁问题的策略</h2><ul><li>预防死锁<ul><li>通过设置某些限制条件，破坏死锁四个必要条件中的一个或多个，来防止死锁<ul><li>破坏互斥条件——难</li><li>破坏不剥夺条件——代价大</li><li>破坏部分分配条件——预先静态分配</li><li>破坏环路条件——有序资源分配</li></ul></li><li>由于限制太严格，导致资源利用率和吞吐率降低</li></ul></li><li>避免死锁——银行家算法</li><li>检测和恢复死锁<ul><li>允许死锁发生，但可通过检测机制及时检测出死锁状态，并精确确定与死锁有关的进程和资源，然后采取适当措施，将系统从已发生的死锁中清除，将程序从死锁状态解脱出来</li></ul></li></ul><h1 id="第六章-处理机调度（进程调度）"><a href="#第六章-处理机调度（进程调度）" class="headerlink" title="第六章 处理机调度（进程调度）"></a>第六章 处理机调度（进程调度）</h1><h2 id="进程调度概念"><a href="#进程调度概念" class="headerlink" title="进程调度概念"></a>进程调度概念</h2><ul><li>调度定义<ul><li>在一个队列中，按某种策略选择一个最合适的个体</li></ul></li><li>调度分类<ul><li>长程调度/宏观调度/作业调度</li><li>中程调度/交换调度</li><li>短程调度/进程调度</li><li><code>IO</code>调度/设备调度</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220101213941318.png" alt="image-20220101213941318"></li></ul></li><li>进程调度的目标<ul><li>响应速度尽可能快</li><li>进程处理时间尽可能短</li><li>系统吞吐量尽可能大</li><li>资源利用率尽可能高</li><li>对所有进程要公平</li><li>避免饥饿</li><li>避免死锁</li></ul></li><li>进程调度的量化指标<ul><li>周转时间/平均周转时间</li><li>带权周转时间/平均带权周转时间</li></ul></li><li>周转时间<ul><li>进程提交给计算机到完成所花费的时间<code>t = tc - ts</code><ul><li><code>ts</code>——进程的提交时间</li><li><code>tc</code>——进程的完成时间</li></ul></li><li>意义：说明进程在系统中停留的时间长短</li></ul></li><li>平均周转时间<ul><li><code>t = (t1 + t2 + ...... +tn)/n</code></li><li>平均周转时间越短，意味着这些进程在系统中停留的时间越短，因而系统吞吐量也越大，资源利用率越高</li></ul></li><li>带权周转时间<ul><li><code>w = t/tr</code><ul><li><code>t</code>——进程的周转时间</li><li><code>tr</code>——进程的运行时间</li></ul></li><li>意义：进程在系统中的相对停留时间</li></ul></li><li>平均带权周转时间<ul><li><code>w = (w1 + w2 + ...... +wn)/n</code></li></ul></li></ul><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><ul><li>先来先服务调度<ul><li>晚来但是很短的作业可能需要等待很长时间，不利于短作业</li></ul></li><li>短作业优先调度<ul><li>忽视了等待时间，一个早来但是很长的作业将会得不到调度</li></ul></li><li>响应比高者优先调度<ul><li>响应比 = 加权周转时间</li></ul></li><li>优先数调度<ul><li>优先数 = 静态优先数 + 动态优先数</li><li>静态优先数：在进程创建时确定，在整个进程运行期间不再改变</li><li>动态优先数：动态优先数在进程期间可以改变</li></ul></li><li>循环轮转调度<ul><li>把所有就绪进程按先进先出的原则排成队列，进程以时间片为单位轮流使用<code>CPU</code><ul><li>时间片太大则会退化成先来先服务算法</li><li>时间片太小则会引起进程切换频繁，系统开销增大</li></ul></li></ul></li><li>可变时间片轮转调度</li><li>多重时间片循环调度</li><li>调度方式<ul><li>定义<ul><li>当一进程正在<code>CPU</code>上运行时，若有更高优先级的进程需要运行，系统如何分配<code>CPU</code></li></ul></li><li>非剥夺方式<ul><li>让正在运行的进程继续执行，直到该进程完成或发生某事件而进入完成或阻塞的状态，才把<code>CPU</code>分配给新来的更高优先级的进程</li></ul></li><li>剥夺方式<ul><li>当更高优先级的进程来到时，便暂停正在运行的进程，立即把<code>CPU</code>分配给新来的优先级更高的进程</li></ul></li></ul></li></ul><h2 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h2><ul><li>基本特点<ul><li>基于优先级调度</li><li>支持普通进程，也支持实时进程</li><li>实时进程优先于普通进程</li><li>普通进程公平使用<code>CPU</code>时间</li></ul></li></ul><h1 id="第七章-主存管理"><a href="#第七章-主存管理" class="headerlink" title="第七章 主存管理"></a>第七章 主存管理</h1><h2 id="内存管理的功能"><a href="#内存管理的功能" class="headerlink" title="内存管理的功能"></a>内存管理的功能</h2><ul><li>实际存储体系<ul><li>三级存储体系</li><li><code>Cache</code>+内存+辅存</li><li>基本原理<ul><li>当内存太小不够时，用辅存来支援内存</li><li>暂时不运行的模块换出到辅存上，必要时再换入内存</li></ul></li></ul></li><li>存储管理的功能<ol><li>地址映射</li><li>虚拟存储（存储扩充）</li><li>内存分配</li><li>存储保护</li></ol></li><li>地址映射<ul><li>定义<ul><li>把程序中的地址（虚拟地址/虚地址/逻辑地址）变换为真实的内存地址（实地址/物理地址）的过程</li></ul></li><li>方式<ul><li>固定地址映射</li><li>静态地址映射</li><li>动态地址映射</li></ul></li><li>固态地址映射<ul><li>定义：编程或编译时确定逻辑地址和物理地址间的映射关系</li><li>特点<ul><li>程序加载时必须放到指定的内存区域</li><li>容易产生地址冲突，运行失败</li><li>不能适应多道环境</li></ul></li></ul></li><li>静态地址映射<ul><li>定义：程序装入时由操作系统完成逻辑地址到物理地址的映射<ul><li>保证在运行之前将所有地址都绑定到主存</li></ul></li><li><code>MA = BA + VA</code><ul><li><code>MA</code>——物理地址</li><li><code>BA</code>——装入基址，基址寄存器</li><li><code>VA</code>——逻辑地址</li></ul></li><li>特点<ul><li>程序运行之前确定映射关系</li><li>程序装入后不能移动</li><li>程序占用连续的内存空间</li></ul></li></ul></li><li>动态地址映射<ul><li>定义：在程序执行过程中把逻辑地址转换为物理地址<ul><li>例如：<code>MOV AX, [500]</code>，访问500单元时执行地址转换</li></ul></li><li><code>MA = BA + VA</code><ul><li><code>MA</code>——物理地址</li><li><code>BA</code>——装入基址，基址寄存器</li><li><code>VA</code>——逻辑地址</li></ul></li><li>特点<ul><li>程序占用的内存空间可动态变化<ul><li>若程序移动及时更新基址<code>BA</code></li></ul></li><li>程序不要求占用连续的内存空间<ul><li>需要记录每段放置的基址<code>BA</code></li></ul></li><li>便于多个进程共享代码<ul><li>共享代码作为独立的一段存放</li></ul></li></ul></li></ul></li></ul></li><li>虚拟存储（存储扩充）<ul><li>解决的问题<ul><li>程序过大或过多时，内存不够，不能运行</li><li>多个程序并发时地址冲突，不能运行</li></ul></li><li>虚拟存储的基本原理<ul><li>借助辅存在逻辑上扩充主存，解决内存不足</li><li>过程<ul><li>迁入：将要运行的部分装入内存，把辅存存放的部分临时按需调入内存</li><li>迁出：把当前不运行的部分暂时存放在辅存，尽量腾出足够的内存供进程正常运行</li></ul></li><li>前提：短时间内进程不运行的部分往往占大部分</li><li>用户体验了足够大的线性内存——虚拟内存</li></ul></li><li>程序局部性原理<ul><li>时间局部性<ul><li>一条指令或数据，会在较短的时间内被重复访问</li><li>例如：循环语句</li></ul></li><li>空间局部性<ul><li>任一内存单元及其临近单元会在短时间内被集中访问</li><li>短时间内，<code>CPU</code>对内存的访问往往会集中在一个较小区域内</li><li>例如：表，数组的操作</li></ul></li><li>结论<ul><li>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内，因此，一般情况下，把程序的一部分装入内存在较大概率上也足够让其运行一段时间</li></ul></li></ul></li><li>实现虚拟存储的前提<ul><li>足够的辅存</li><li>适量容量的内存</li><li>地址变换结构</li></ul></li><li>虚拟存储的应用<ul><li>页式虚拟存储</li><li>段式虚拟存储</li></ul></li></ul></li><li>内存分配<ul><li>为程序运行分配足够的内存空间</li><li>需要解决的问题<ul><li>放置策略<ul><li>程序调入内存时将其放在哪个位置</li><li>全部分配或部分分配</li></ul></li><li>调入策略<ul><li>何时把要运行的代码或访问的数据调入内存</li></ul></li><li>淘汰策略<ul><li>迁出哪些代码和数据以腾出内存空间</li></ul></li></ul></li></ul></li><li>存储保护<ul><li>保证内存中的多道程序只能在给定的存储区域活动并互不干扰</li><li>保护方法<ul><li>界址寄存器<ul><li>在<code>CPU</code>中设置一对下限寄存器和上限寄存器，存放程序在内存中的下限地址和上限地址</li><li>基址寄存器和限长寄存器</li><li>适用于连续物理分区中的情形</li></ul></li><li>存储键保护<ul><li>适用于不连续物理分块的情形，也可用于共享中的权限</li></ul></li></ul></li></ul></li></ul><h2 id="物理内存管理"><a href="#物理内存管理" class="headerlink" title="物理内存管理"></a>物理内存管理</h2><ul><li>物理内存管理方法<ul><li>单一区存储管理（不分区存储管理）</li><li>分区存储管理</li><li>内存覆盖技术</li><li>内存交换技术</li></ul></li><li>单一区存储管理<ul><li>内存的用户区不分区，完全被一个程序所占用</li></ul></li></ul><h3 id="分区存储管理"><a href="#分区存储管理" class="headerlink" title="分区存储管理"></a>分区存储管理</h3><ul><li><p>定义：把用户区内存划分成若干大小不等的分区，供不同程序使用</p></li><li><p>分类</p><ul><li>固定分区</li><li>动态分区</li></ul></li><li><p>固定分区</p><ul><li>把内存固定的划分为若干个大小不等的分区供各个程序使用，每个分区的大小和位置都固定，系统运行期间不再重新划分</li><li>分区表：记录分区的位置、大小和使用标志</li><li>例子：<img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102091501217.png" alt="image-20220102091501217"></li><li>使用特点<ul><li>在程序装入之前，内存已被分区，不再改变</li><li>每个分区大小不同，适应于不同大小的程序</li><li>系统需要维护分区表</li></ul></li><li>固定分区缺点<ul><li>浪费内存：程序比所在分区小</li><li>大的程序可能无法运行：程序比最大分区大，无法装入</li></ul></li><li>应用建议<ul><li>程序大小、个数、装入顺序都是固定的情形</li><li>根据分区表安排程序装入顺序</li></ul></li></ul></li><li><p>动态分区</p><ul><li><p>在程序装入时创建分区，使分区的大小刚好与程序的大小相等</p></li><li><p>例子：<img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102091843105.png" alt="image-20220102091843105"></p><p><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102091931479.png" alt="image-20220102091931479"></p></li><li><p>特点</p><ul><li>分区动态建立</li><li>分区的个数和大小均可变</li><li>存在内存碎片</li></ul></li><li><p>动态分区需要解决的问题</p><ul><li>分区的选择</li><li>分区的分配</li><li>分区的回收</li><li>解决内存的碎片问题</li></ul></li><li><p>分区的选择（放置策略）</p><ul><li><p>程序装入空闲区时，尽量往高地址靠拢</p></li><li><p>空闲区表：描述内存空闲区的位置和大小的数据结构</p></li><li><p>分区选择：</p><ul><li>从空闲区表中选择一个空闲区给用户使用</li><li>选择策略/放置策略</li></ul></li><li><p>放置策略</p><ul><li>从排序好的空闲区表中选择第一个大小够大的分区</li><li>选择分区与空闲区表排序方式有关</li></ul></li><li><p>空闲区表的排序原则</p><ul><li>首次适应算法：按空闲区位置递增排序<ul><li>尽可能先利用低地址空间</li></ul></li><li>最佳适应法：按空闲区大小递增排序<ul><li>尽量选择满足要求的最小空闲区</li></ul></li><li>最坏适应法：按空闲区大小递减排序<ul><li>尽量使用最大的空闲区</li><li>仅作一次查找就可以找到所要分区</li></ul></li></ul></li></ul></li><li><p>分区的分配</p><ul><li>从用户选中的分区中分配/分割所需大小给用户</li><li>剩余部分依然作为空闲区登记在空闲区表中</li><li>注意：分割空闲区时，一般把底部分割给用户（因此，空闲区表只需修改大小即可）</li></ul></li><li><p>分区的回收</p><ul><li>回收程序占用的分区（释放区），将其适当处理后登记到空闲区表中，以便再分配</li><li>若释放区与现有空闲区相邻则合并</li></ul></li><li><p>碎片问题</p><ul><li>动态分区的缺点<ul><li>容易产生内存碎片：内存反复分配和分割</li><li>首次适应法，最佳适应法，最坏适应法</li></ul></li><li>解决碎片的方法<ul><li>规定门限值：分割空闲区时，若剩余部分小于门限值，则此空闲区不进行分割，而是全部分配给用户</li><li>内存拼接技术：将所有空闲区集中一起构成一个大的空闲区</li><li>把程序分拆成几个部分装入不同分区，充分利用碎片</li></ul></li></ul></li></ul></li></ul><h3 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h3><ul><li>目的：在较小的内存空间中运行较大的程序</li><li>内存分区<ul><li>常驻区：被某段单独使用且固定的占用的分区，可划分多个</li><li>覆盖区：能被多段共用（覆盖）的区域，可划分多个</li></ul></li><li>工作原理<ul><li>程序划分成若干代码段或数据段</li><li>将程序常用的段装入常驻区</li><li>将程序不常用的段装入覆盖区<ul><li>正在运行的段处于覆盖区</li><li>暂时不运行的段放在硬盘中（覆盖文件）</li><li>即将运行的段装入覆盖区（覆盖旧内容）</li></ul></li><li>意义：减少程序对内存的需求</li><li>例子：<img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102094233950.png" alt="image-20220102094233950"></li></ul></li></ul><h3 id="对换技术"><a href="#对换技术" class="headerlink" title="对换技术"></a>对换技术</h3><ul><li>原理<ul><li>当内存不够时把进程写到磁盘，当进程要运行时重新写回内存</li></ul></li><li>优点<ul><li>增加进程并发数</li><li>不考虑程序结构</li></ul></li><li>缺点<ul><li>换入和换出增加<code>CPU</code>开销</li><li>对换单位太大</li></ul></li></ul><h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><ul><li>物理内存（即实内存）管理<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102094616055.png" alt="image-20220102094616055"></li></ul></li><li>改善物理内存管理的相关技术<ul><li>内存拼接</li><li>对换技术</li><li>覆盖技术</li></ul></li><li>虚拟内存的概念<ul><li>虚拟内存是面向用户的虚拟封闭存储空间</li><li>线性地址空间</li><li>容量<code>4G</code></li><li>封闭空间（进程空间）</li><li>和物理地址分离（地址无冲突）</li><li>程序员编程时使用线性虚拟地址</li></ul></li><li>虚拟内存管理<ul><li>目标<ul><li>使得大的程序能在较小的内存中运行</li><li>使得多个程序能在较小的内存中运行</li><li>使得多个程序并发运行时地址不冲突</li><li>使得内存利用效率高</li></ul></li><li>虚拟内存管理的实现思路<ul><li>把程序一小部分装入内存在较大概率上也足够让其运行一小段时间</li><li>程序的局部性<ul><li>程序在一个有限的时间段内访问的代码和数据往往集中在有限的地址范围内</li></ul></li></ul></li><li>典型虚拟内存管理方式<ul><li>页式虚拟内存管理</li><li>段式虚拟内存管理</li><li>段页式虚拟内存管理</li></ul></li></ul></li></ul><h3 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h3><ul><li>页式虚拟内存管理<ul><li>概念<ul><li>把进程空间（虚拟）和内存空间都划分成等大小的小片<ul><li>进程的小片——页</li><li>内存的小片——页框</li><li>小片的典型大小：<code>1K、2K、4K</code></li></ul></li></ul></li><li>程序装入和使用内存的原则<ul><li>内存以页框为单位分配使用</li><li>进程以页为单位装入内存<ul><li>只把程序部分页装入内存便可运行</li><li>页在内存中占用的页框不必相邻</li><li>需要新页时，按需从硬盘调入内存</li><li>不在运行的页及时删除，腾出空间</li></ul></li></ul></li><li>页式系统中的地址<ul><li>虚拟地址<code>VA</code>是线性的，从0开始</li><li><code>VA</code>分成页号<code>P</code>和页内偏移<code>W</code><ul><li>所处页编号<code>P = VA/页大小</code></li><li>所处页偏移<code>W = VA%页大小</code></li></ul></li></ul></li><li>地址映射过程<ul><li>页面映射表：记录页与页框之间的对应关系，也叫页表</li><li>例子：<img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102100141218.png" alt="image-20220102100141218"></li><li>过程：<ol><li>从<code>VA</code>中分离页号<code>P</code>和页内偏移<code>W</code></li><li>查找页表，以<code>P</code>为索引查找页框号<code>P'</code></li><li>计算物理地址<code>MA = P' * 页大小 + W</code></li></ol></li><li>快表：页表部分存放在<code>Cache</code>中称为快表<ul><li>地址映射时优先访问快表</li><li>合理的页面调度策略能使快表具有较高的命中率</li></ul></li><li>页面的共享<ul><li>在页表中填上共享的页框号，从而实现页面共享</li><li>共享页面在内存中只有一份真实存储，节省内存</li></ul></li></ul></li><li>页表的建立<ul><li>操作系统为每个进程创建一个页表<ul><li>页表长度和首地址存放在进程控制块中</li></ul></li><li>当前运行进程的页表驻留在内存<ul><li>页表长度和首地址由页表长度寄存器和页表首址寄存器指示</li></ul></li></ul></li><li>页表扩充<ul><li>扩充有中断位<code>I</code>和辅存地址的页表</li><li>中断位<code>I</code>——标识该页是否在内存中，为<code>1</code>标识不在内存，为<code>0</code>标识在内存</li><li>辅存地址——该页在辅存上的位置</li><li>扩充有访问位（引用位）和修改位的页表</li><li>访问位——标识该页是否最近被访问</li><li>修改位——标识该页的数据是否已被修改</li></ul></li><li>缺页中断<ul><li>在地址映射的过程中，当要访问的目的页不在内存时，则系统产生异常中断——缺页中断</li><li>缺页中断处理程序<ul><li>中断处理程序把所缺的页从页表指出的辅存地址调入内存的某个页框中，并更新页表中该页对应的页框号以及修改中断位<code>I</code>为0</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102102025891.png" alt="image-20220102102025891"></li></ul></li><li>缺页率：<code>f = 缺页次数/访问页面总次数</code></li><li>缺页中断和普通中断<ul><li>相同点：保护现场、中断处理、恢复现场</li><li>不同点：响应时机：普通中断在指令完成后响应，缺页中断在指令执行时响应</li></ul></li></ul></li><li>二级页表<ul><li>页表实现时的问题<ul><li>页表全部装入过度消耗内存（<code>4M</code>）</li><li>难以找到连续的<code>1k</code>个页框存放页表</li></ul></li><li>解决办法<ul><li>仅将页表的部分内容调入内存</li><li>将<code>4M</code>的超大页表分拆存储到离散的<code>1k</code>个页框中</li></ul></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102102800509.png" alt="image-20220102102800509"></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102102814871.png" alt="image-20220102102814871"></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102102824123.png" alt="image-20220102102824123"></li></ul></li><li>淘汰策略<ul><li>选择淘汰哪一页的规则称为淘汰策略</li><li>页面抖动：页面在内存和辅存之间频繁交换的现象</li><li>好的淘汰策略<ul><li>较低的缺页率</li><li>页面抖动较少</li></ul></li><li>常用的淘汰算法<ul><li>最佳算法</li><li>先进先出算法</li><li>最久未使用算法</li><li>最不经常使用算法</li></ul></li></ul></li><li>最佳算法<ul><li>淘汰不再需要或最远的将来才会使用的页面</li></ul></li><li>先进先出淘汰算法<ul><li>淘汰在内存中停留时间最长的页面</li></ul></li><li>最久未使用淘汰算法<ul><li>淘汰最长时间未使用的页面</li></ul></li><li>最不经常使用淘汰算法<ul><li>选择到当前时间为止被访问次数最少的页面</li><li>每页设置访问计数器，每当页面被访问时，该页面的访问计数器加一</li><li>发生缺页中断时，淘汰计数值最小的页面，并将<strong>所有计数</strong>清零</li></ul></li><li>页面大小选择<ul><li>页面过大：浪费内存，极限是分区存储</li><li>页面过小：页面增多，页表长度增加，浪费内存，换页频繁，系统效率低</li></ul></li><li>影响缺页次数的因素<ul><li>淘汰算法</li><li>分配给进程的页框数</li><li>页本身的大小：页面越小越容易缺页</li><li>程序的编制方法<ul><li>局部性越好，越不容易缺页</li><li>跳转或分支越多越容易缺页</li></ul></li></ul></li><li>页式系统的不足<ul><li>页面划分无逻辑含义</li><li>页的共享不灵活</li><li>页内碎片</li></ul></li></ul></li></ul><h3 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h3><ul><li>进程分段<ul><li>把进程按逻辑意义划分成多个段，每段有段名，长度不定，进程由多段组成</li><li>例如：一个具有代码段、数据段、堆栈段的进程</li></ul></li><li>段式内存管理系统的内存分配<ul><li>以段为单位装入，每段分配相邻的内存</li><li>但是段与段之间不要求相邻</li></ul></li><li>段式系统的虚拟地址<ul><li>段式虚拟地址<code>VA</code>包含段号<code>S</code>和段内偏移<code>W</code></li></ul></li><li>段表<ul><li>记录每段在内存中映射的位置</li><li>段号|段长|基地址</li><li>段表的字段<ul><li>段号<code>S</code>——段的唯一编号</li><li>段长<code>L</code>——该段的长度</li><li>基地址<code>B</code>——该段在内存中的首地址</li></ul></li></ul></li><li>段式地址的映射机制<ul><li>过程<ol><li>由逻辑地址<code>VA</code>分离出(<code>S</code>,<code>W</code>)</li><li>查询段表：检索段号<code>S</code>，查询该段基地址<code>B</code>和长度<code>L</code></li><li>物理地址<code>MA = B + W</code></li></ol></li></ul></li><li>段表的扩充<ul><li>基本字段：段号，长度，基址</li><li>扩展字段：中断位，访问位，修改位，<code>R/W/X</code></li></ul></li><li>段的共享<ul><li>共享段在内存中只有一份存储</li><li>共享段被进程映射到自己的空间（写入段表）</li><li>所有共享的模块都可以设置为单独的段</li></ul></li><li>段式系统的缺点<ul><li>段需要连续的存储空间</li><li>段的最大尺寸收到内存大小的限制</li><li>在辅存中管理可变尺寸的段比较困难</li></ul></li><li>段式系统与页式系统<ul><li>地址空间的区别<ul><li>页式系统：一位地址空间</li><li>段式系统：二维地址空间</li></ul></li><li>段与页的区别<ul><li>段长可变——页面固定大小</li><li>段的划分有意义——页面划分无意义</li><li>段方便共享——页面不方便共享</li><li>段用户可见——页面用户不可见</li><li>段偏移有溢出——页偏移无溢出</li><li>段式系统不会产生碎片问题——页式系统会产生碎片</li></ul></li></ul></li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><ul><li>在段式存储管理中结合页式存储管理技术</li><li>在段中划分页面</li><li>段页式系统的地址构成：段号|页号|页内偏移<ul><li>逻辑地址：段号<code>S</code>，页号<code>P</code>，页内偏移<code>W</code></li><li>内存按页划分，按页装入</li></ul></li><li>段页式地址的映射结构<ul><li>同时采用段表和页表实现地址映射<ul><li>系统为每个进程建立一个段表</li><li>系统为每个段建立一个页表</li><li>段表给出每段的页表基地址和页表长度（段长）</li><li>页表给出每页对应的框</li></ul></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102110251274.png" alt="image-20220102110251274"></li></ul></li></ul><h2 id="Linux存储管理"><a href="#Linux存储管理" class="headerlink" title="Linux存储管理"></a>Linux存储管理</h2><ul><li><code>/proc</code>文件系统<ul><li>特点<ul><li>内存文件系统</li><li>为用户访问内核信息提供接口<ul><li>例：<code>CPU</code>信息</li><li>例：内核信息（进程信息）</li></ul></li></ul></li></ul></li></ul><h1 id="第八章-设备管理（输入-x2F-输出管理）"><a href="#第八章-设备管理（输入-x2F-输出管理）" class="headerlink" title="第八章 设备管理（输入/输出管理）"></a>第八章 设备管理（输入/输出管理）</h1><h2 id="设备管理概述"><a href="#设备管理概述" class="headerlink" title="设备管理概述"></a>设备管理概述</h2><ul><li>设备管理功能<ul><li>状态跟踪<ul><li>生成设备管理器的数据结构，动态的记录各种设备的状态</li></ul></li><li>设备分配<ul><li>设备分配功能是设备管理的基本任务</li></ul></li><li>设备映射<ul><li>设备的两种名字：设备逻辑名、设备物理名</li><li>从应用软件的角度看，逻辑设备是一类物理设备的抽象</li><li>从设备管理程序的角度看，物理设备是逻辑设备的实例</li><li>设备独立性<ul><li>逻辑设备对用户透明</li><li>用户使用统一规范的方式使用设备</li></ul></li></ul></li><li>设备控制和设备驱动<ul><li>对物理设备进行控制，实现<code>IO</code>操作</li><li>把来自应用的服务请求（例如：读写命令）转换为一系列<code>IO</code>指令，控制设备完成相关操作</li><li>向用户提供统一的设备使用接口：<code>read、write</code></li><li>设备驱动程序的特点<ul><li>设备驱动程序与硬件密切相关</li><li>每类设备都要配置特定的驱动程序</li></ul></li></ul></li><li>缓冲区管理<ul><li>组织<code>IO</code>缓冲区</li></ul></li></ul></li></ul><h2 id="缓存技术"><a href="#缓存技术" class="headerlink" title="缓存技术"></a>缓存技术</h2><ul><li>缓冲作用<ol><li>连接有着不同数据传输速度的设备</li><li>协调数据记录大小的不一致</li><li>正确执行应用程序的语义拷贝<ul><li><code>write(Data,Len)</code>向磁盘写入<code>Data</code></li><li>方法：<ul><li>内核写完再返回（实时性差）</li><li>内核设置缓冲区，完成内核复制即返回，之后由内核把缓冲区写到磁盘（实时性好）</li></ul></li></ul></li></ol></li><li>提前读和延后写<ul><li>存储设备</li><li>提高数据传输效率</li><li>减少进程访问目标设备的次数</li></ul></li><li>提前读<ul><li>进程处理一个输入数据时，直接从<code>IO</code>缓冲区读入，正确的数据已被提前读入到<code>IO</code>缓冲区中<ul><li>结论：内核提前从输入设备把数据读到<code>IO</code>缓冲区中</li><li>但不一定是正确数据</li><li>注意同步问题</li></ul></li></ul></li><li>延后写<ul><li>进程输出数据时，仅把数据写入<code>IO</code>缓冲区，此后，待输出设备空闲时，内核把<code>IO</code>缓冲区的数据写入输出设备<ul><li>结论：用户处理数据的同时内核输出（有延后）前一数据</li></ul></li></ul></li><li>常用的缓冲技术——环形缓冲<ul><li>若干缓冲单元首尾链接成一个环：环形缓存区</li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102134336158.png" alt="image-20220102134336158"></li><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102134419834.png" alt="image-20220102134419834"></li></ul></li></ul><h2 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h2><ul><li>设备分配方法<ul><li>独享分配</li><li>共享分配</li><li>虚拟分配</li></ul></li><li>独占设备<ul><li>每次只能供一个进程单独使用的设备<ul><li>打印机、键盘、鼠标等</li></ul></li></ul></li><li>共享设备<ul><li>允许多个进程同时使用的设备<ul><li>块设备、硬盘等</li></ul></li></ul></li><li>虚拟设备<ul><li>借助虚拟技术，在共享设备上模逆独占型设备<ul><li>一般是辅存上模逆独占型设备</li></ul></li></ul></li><li>设备分配<ul><li>独享分配<ul><li>申请成功——开始使用——用完释放</li></ul></li><li>共享分配<ul><li>即时申请即时分配，不阻塞</li></ul></li><li>虚拟分配<ul><li>申请独占设备，实际分配虚拟设备</li></ul></li></ul></li><li>虚拟技术<ul><li>在一类物理设备上模逆另一类物理设备的技术<ul><li>通常借助辅存的一部分区域模拟独占设备，将独占设备转为共享设备</li></ul></li><li>虚拟设备<ul><li>用来模拟独占设备的部分辅存称为虚拟设备，虚拟独占设备</li><li>输入井：模拟输入设备的辅存区域</li><li>输出井：模逆输出设备的辅存区域</li></ul></li></ul></li><li>虚拟分配<ul><li>申请独占设备，实际分配虚拟设备</li><li><code>SPOOLING</code>系统是虚拟技术和虚拟分配的实现<ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102131915385.png" alt="image-20220102131915385"></li></ul></li></ul></li><li><code>SPOOLing</code>系统构成<ul><li>输入井和输出井<ul><li>磁盘上开辟的两个存储区域</li></ul></li><li>输入缓冲区和输出缓冲区<ul><li>内存中开辟的存储区域，暂存输入输出数据，以后在传送到输入井和输出井</li></ul></li><li>预输入程序：控制信息从独占设备输入到缓存</li><li>预输入表：从哪台设备输入，存放在输入井的位置</li><li>缓输出程序：控制信息从缓存输出到独占设备</li><li>缓输出表：输出信息在输出井的位置，从那台设备输出</li><li>井管理程序：控制用户程序与辅存之间的信息交换</li></ul></li><li><code>SPOOLing</code>系统原理小结<ul><li>任务执行前：预先将程序和数据输入到输入井中</li><li>任务运行时：使用数据时，从输入井中取出</li><li>任务运行时：输出数据时，把数据写入输出井</li><li>任务运行完：外设空闲时输出全部数据和信息</li></ul></li><li><code>SPOOLing</code>优点<ul><li>提高了<code>IO</code>速度</li><li>将独占设备改造为“共享设备”<ul><li>实现了虚拟设备功能</li></ul></li></ul></li></ul><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><ul><li><p><code>Linux</code>模块</p><ul><li><code>LKM</code></li><li>一种未经链接的可执行代码</li><li>可以动态的加载或卸载模块</li><li>经过连接称为内核的一部分</li></ul></li><li><p><code>Linux</code>设备驱动（<code>LDD</code>）</p><ul><li><img src="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/image-20220102134627709.png" alt="image-20220102134627709"></li></ul></li><li><p><code>Linux</code>设备分类</p><ul><li>字符设备<ul><li>以字节为单位逐个进行<code>IO</code>操作</li><li>字符设备中的缓存是可有可无的</li><li>不支持随机访问</li><li>如串口设备</li></ul></li><li>块设备<ul><li>块设备的存取是通过<code>buffer</code>、<code>cache</code>来进行</li><li>可以进行随机访问</li><li>例如：<code>IDE</code>硬盘设备</li><li>支持可安装文件系统</li></ul></li><li>网络设备<ul><li>通过<code>BSD</code>套接口访问</li></ul></li></ul></li><li><p>设备文件</p><ul><li>将设备作为文件看待</li><li>使用文件接口打开、关闭、读写和<code>IO</code>控制设备<ul><li>字符设备和块设备通过设备文件访问</li><li><code>Linux</code></li></ul></li><li>主设备号和次设备号<ul><li>主设备号<ul><li>标识该设备种类，标识驱动程序</li><li>主设备号范围：<code>1</code>-<code>255</code></li><li><code>Linux</code>内核支持动态分配主设备号</li></ul></li><li>次设备号<ul><li>标识同一设备驱动程序的不同硬件设备</li><li>次设备号只在驱动程序内部使用</li></ul></li></ul></li></ul></li><li><p>驱动程序的基本接口</p><ul><li><p>面向用户程序的接口</p></li><li><p>面向<code>IO</code>管理器的接口</p><ol><li>注册函数</li><li>注销函数</li><li>数据结构</li><li>请求队列</li></ol></li><li><p>面向设备的接口</p><ul><li>把用户请求转化为端口操作<code>IN/OUT</code></li></ul><ol><li>无条件传送</li><li>查询传送</li><li>中断传送</li><li><code>DMA</code>传送</li></ol></li></ul></li></ul><h1 id="第九章-文件系统"><a href="#第九章-文件系统" class="headerlink" title="第九章 文件系统"></a>第九章 文件系统</h1><h2 id="文件和文件系统的概念"><a href="#文件和文件系统的概念" class="headerlink" title="文件和文件系统的概念"></a>文件和文件系统的概念</h2><ul><li><p>文件的定义</p><ul><li>文件是系统中信息存放的一种组织形式<ul><li>文件是若干信息项的构成<ul><li>信息项可以是字节，可以是结构化数据</li></ul></li><li>用户通过读写指针来存取文件的信息项</li><li>文件具有文件名，用户通过文件名存取文件</li></ul></li></ul></li><li><p>文件分类</p><ul><li><p>按文件的用途</p></li><li><p>系统文件</p><ul><li>包括操作系统的可执行程序和数据文件，这种文件不对用户开发，仅供系统使用</li></ul></li><li><p>库文件</p><ul><li>系统为用户提供的各种标准函数库和实用程序等，用户只能使用这些文件，而无权进行修改</li></ul></li><li><p>用户文件</p><ul><li>用户创建的文件，如用户可执行文件，源程序，数据文件等</li></ul><hr></li><li><p>按文件的操作权限</p></li><li><p>只读文件</p></li><li><p>读写文件</p></li><li><p>不保护文件</p><hr></li><li><p>按文件的性质</p></li><li><p>普通文件</p><ul><li>指一般的用户文件或系统文件</li></ul></li><li><p>目录文件</p><ul><li>由目录项组成的文件</li><li>目录项：文件名，文件属性，文件存放地址</li></ul></li><li><p>设备文件</p><ul><li>把设备作为文件管理和使用</li></ul></li></ul></li></ul><h2 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h2><ul><li>文件的结构<ul><li>逻辑结构<ul><li>为用户提供逻辑结构清晰、使用方便的文件</li><li>强调文件信息项的构成方式和用户的存取方式</li></ul></li><li>物理结构<ul><li>文件在存储设备上的存储结构</li><li>强调合理利用存储空间，缩短<code>IO</code>存取时间</li></ul></li></ul></li><li>文件的逻辑结构<ul><li>流式文件<ul><li>信息项是字节，文件长度就是字节的数量</li><li>优点<ul><li>文件无需额外的说明信息或控制信息</li><li>节省存储空间</li></ul></li></ul></li><li>记录式文件<ul><li>信息项由记录组成，一个记录包含若干成员<ul><li>学生记录：姓名，学号，性别，成绩</li><li>学生花名册文件：包含若干个学生记录</li></ul></li><li>特点<ul><li>文件中需保存记录长度和数量等说明信息</li><li>浪费存储空间</li></ul></li></ul></li><li>现代<code>OS</code>中文件是流式文件</li></ul></li><li>文件的存取方法<ul><li>顺序存取<ul><li>按文件信息单位排列的顺序依次存取</li><li>读写指针</li></ul></li><li>随机存取<ul><li>直接存取</li><li>每次存取操作时先确定存取位置</li></ul></li></ul></li></ul><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><ul><li>文件的物理结构<ul><li>文件的物理结构是指文件在存储设备上的存储方式，强调合理利用存储空间，缩短<code>IO</code>存取时间</li></ul></li><li>物理结构的类型<ul><li>连续文件<ul><li>文件按照逻辑顺序存放在存储设备的连续物理块中</li></ul></li><li>串联文件<ul><li>文件信息存放在不连续的存储块中</li><li>每个存储块有一个指针，指向文件的下一个逻辑块所在的存储块</li></ul></li><li>索引文件<ul><li>文件存放在不连续的物理块中，系统建立索引表记录文件的逻辑块和存储块的对应关系</li></ul></li></ul></li></ul><h2 id="文件存储空间管理"><a href="#文件存储空间管理" class="headerlink" title="文件存储空间管理"></a>文件存储空间管理</h2><ul><li>概念<ul><li>记录当前磁盘的使用情况，创建文件时分配存储空间，删除文件时收回存储空间</li></ul></li><li>记录磁盘空闲块的方法<ul><li>空闲文件目录</li><li>空闲块链</li><li>位示图</li></ul></li><li>空闲文件目录<ul><li>一片连续的空闲区当作一个特殊文件：空闲文件，该文件由多个连续的空闲存储块组成</li><li>所有的空闲文件代表存储设备的空闲空间</li><li>空闲文件目录<ul><li>记录所有空闲文件的目录，每个表项对应一个空闲文件</li></ul></li></ul></li><li>空闲块链<ul><li>把存储设备上的所有空闲块链接在一起，当申请者需要空闲块时，分配程序从链头开始摘取所需要的空闲块，然后调整链首指针，反之当回首空闲块时，把释放的空闲块逐个加载链尾上</li></ul></li><li>位示图<ul><li>从内存中划出若干个字节，每位对应一个存储块<ul><li>该位为1：对应存储块空闲</li><li>该位为0：对应存储块已分配</li></ul></li></ul></li></ul><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><ul><li>文件目录<ul><li>文件名址录，记录文件名和存放地址的目录表</li><li>为了对大量文件进行分门别类的管理，提高文件检索的效率，现代操作系统往往将文件的一些属性也记录在目录中</li></ul></li><li>目录文件<ul><li>文件目录以文件形式存于外存，这个文件叫目录文件</li></ul></li><li>文件目录的功能：将文件名转换为外存物理地址的功能</li><li>文件的全名：包括从根目录开始到文件为止的通路上所有子目录路径</li><li>每个文件有唯一的路径名</li><li>两种路径名形式<ul><li>绝对路径名</li><li>相对路径名</li></ul></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><ul><li>多道批处理系统为什么工作效率比单道的高<ul><li>因为多道批操作系统在内存中存放了多道程序，当某程序因某种原因不能运行放弃<code>CPU</code>时，操作系统调度另一程序投入运行，让<code>CPU</code>尽量忙碌，提高系统效率，而单道批处理系统只能让<code>CPU</code>空闲等待</li></ul></li><li>常见的虚拟机软件能不能理解为操作系统<ul><li>不能，虚拟机只是允许在当前操作系统上运行其他的操作系统，是运行在当前操作系统之上的，是一个应用程序</li></ul></li><li>临界区设计太小或太大有何缺点<ul><li>在保证功能的条件下应该设计的小一些</li><li>临界区太大，会使得其他想要访问临界区的进程等待时间过长，致使并发性变差</li><li>临界区太小，可能导致临界资源不在临界区内，程序并发执行产生混乱</li></ul></li><li>临界区访问机制为什么要实现让权等待原则，锁机制为什么没有满足该原则<ul><li>让权等待原则是指让等待的进程放弃<code>CPU</code>资源，把资源让给其他进程，避免了<code>CPU</code>资源的浪费，提高<code>CPU</code>的利用率</li><li>锁机制的等待程序在未被允许进入临界区之前，一直处于死循环状态，一直占用<code>CPU</code></li></ul></li><li>如何理解参与死锁的进程至少有2个已经占有资源<ul><li>如果参与死锁的进程只有一个占用资源，那么这个占有资源的进程可以继续获取需要的资源，并在有限时间内执行完成，释放占有的资源供其他需要程序的进程使用，这种情况下此进程为发生死锁，产生矛盾；因此参与死锁的进程至少有两个占用资源。</li></ul></li><li>如何证明“按有序资源分配法分配资源并发运行进程不会死锁”<ul><li>有序资源分配法破坏了死锁的环路条件：即<code>A</code>资源使用者等待B资源，B资源使用者等待A资源，形成死锁</li><li>有序资源分配法对资源进行编号，规定进程必须按照编号顺序申请资源，即必须先申请A资源才能申请B资源，那么就不会出现B资源被获取而在等待A资源的情况，所以不会产生死锁</li></ul></li><li>如何理解参与死锁的进程都在等待资源<ul><li>如果某个参与死锁的进程不在等待资源，那么它就会在有限时间内执行完成，并释放占用的资源，即此进程未参与死锁</li></ul></li><li>试述缺页中断的概念和缺页中断响应的过程<ul><li>在地址映射过程中，当所要访问的目的页不在内存中，则系统产生缺页中断</li><li>中断处理程序把所缺的页从页表指定的辅助存储器地址调入内存的某个页框中，并更新页表对应项，修改中断位为0</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>my new post</title>
      <link href="/2022/03/08/my-new-post/"/>
      <url>/2022/03/08/my-new-post/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/08/hello-world/"/>
      <url>/2022/03/08/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
